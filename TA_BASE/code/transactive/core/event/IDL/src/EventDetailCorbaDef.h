// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __EventDetailCorbaDef_hh__
#define __EventDetailCorbaDef_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif



#ifndef __GenericMessageCorbaDef_hh_EXTERNAL_GUARD__
#define __GenericMessageCorbaDef_hh_EXTERNAL_GUARD__
#include <GenericMessageCorbaDef.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Core

_CORBA_MODULE_BEG

  struct EvSequenceNumber {
    typedef _CORBA_ConstrType_Fix_Var<EvSequenceNumber> _var_type;

    
    ::CORBA::ULong ulHighOrder;

    ::CORBA::ULong ulLowOrder;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EvSequenceNumber::_var_type EvSequenceNumber_var;

  typedef EvSequenceNumber& EvSequenceNumber_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EvSequenceNumber;

  struct EventDetailCorbaDef {
    typedef _CORBA_ConstrType_Variable_Var<EventDetailCorbaDef> _var_type;

    
    ::CORBA::String_member eventID;

    ::CORBA::String_member sourceTable;

    MillisecondTime createTime;

    ::CORBA::ULong subsystemKey;

    ::CORBA::Long physicalSubsystemKey;

    ::CORBA::ULong locationKey;

    ::CORBA::ULong severityKey;

    ::CORBA::String_member severityname;

    ::CORBA::String_member assetname;

    ::CORBA::String_member description;

    ::CORBA::ULong eventTypeKey;

    ::CORBA::String_member eventTypeName;

    ::CORBA::String_member alarmID;

    ::CORBA::ULong alarmTypeKey;

    ::CORBA::String_member value;

    ::CORBA::String_member mms;

    ::CORBA::String_member decisionSupportState;

    ::CORBA::String_member avalanceState;

    ::CORBA::ULong operatorKey;

    ::CORBA::String_member operatorName;

    ::CORBA::String_member alarmComment;

    ::CORBA::ULong eventLevel;

    ::CORBA::String_member alarmAckedBy;

    ::CORBA::String_member alarmStatus;

    ::CORBA::String_member sessionID;

    ::CORBA::ULong sessionLocation;

    ::CORBA::Long profileID;

    ::CORBA::ULong actionID;

    ::CORBA::String_member operatorMode;

    ::CORBA::ULong entitykey;

    ::CORBA::String_member avlheadID;

    ::CORBA::ULong systemKey;

    EvSequenceNumber eventSequence;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EventDetailCorbaDef::_var_type EventDetailCorbaDef_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EventDetailCorbaDef,EventDetailCorbaDef_var > EventDetailCorbaDef_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventDetailCorbaDef;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_octetSeq;

  class octetSeq_var;

  class octetSeq : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef octetSeq_var _var_type;
    inline octetSeq() {}
    inline octetSeq(const octetSeq& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline octetSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline octetSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline octetSeq& operator = (const octetSeq& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class octetSeq_out;

  class octetSeq_var {
  public:
    inline octetSeq_var() : _pd_seq(0) {}
    inline octetSeq_var(octetSeq* _s) : _pd_seq(_s) {}
    inline octetSeq_var(const octetSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new octetSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~octetSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline octetSeq_var& operator = (octetSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline octetSeq_var& operator = (const octetSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new octetSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline octetSeq* operator -> () { return _pd_seq; }
    inline const octetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator octetSeq& () const { return *_pd_seq; }
#else
    inline operator const octetSeq& () const { return *_pd_seq; }
    inline operator octetSeq& () { return *_pd_seq; }
#endif
      
    inline const octetSeq& in() const { return *_pd_seq; }
    inline octetSeq&       inout()    { return *_pd_seq; }
    inline octetSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline octetSeq* _retn() { octetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class octetSeq_out;
    
  private:
    octetSeq* _pd_seq;
  };

  class octetSeq_out {
  public:
    inline octetSeq_out(octetSeq*& _s) : _data(_s) { _data = 0; }
    inline octetSeq_out(octetSeq_var& _s)
      : _data(_s._pd_seq) { _s = (octetSeq*) 0; }
    inline octetSeq_out(const octetSeq_out& _s) : _data(_s._data) {}
    inline octetSeq_out& operator = (const octetSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline octetSeq_out& operator = (octetSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator octetSeq*&()  { return _data; }
    inline octetSeq*& ptr()       { return _data; }
    inline octetSeq* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    octetSeq*& _data;

  private:
    octetSeq_out();
    octetSeq_out& operator=(const octetSeq_var&);
  };

  struct EventSerializeCorbaDef {
    typedef _CORBA_ConstrType_Variable_Var<EventSerializeCorbaDef> _var_type;

    
    ::CORBA::String_member eventID;

    MillisecondTime createTime;

    octetSeq eventDetail;

    ::CORBA::Boolean entityInfoValid;

    ::CORBA::Boolean sessionInfoValid;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EventSerializeCorbaDef::_var_type EventSerializeCorbaDef_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EventSerializeCorbaDef,EventSerializeCorbaDef_var > EventSerializeCorbaDef_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventSerializeCorbaDef;

  struct EventInfoCorbaDef {
    typedef _CORBA_ConstrType_Variable_Var<EventInfoCorbaDef> _var_type;

    
    ::CORBA::Boolean isEntityInfoValid;

    ::CORBA::Boolean isSessionInfoValid;

    EventDetailCorbaDef eventDetail;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EventInfoCorbaDef::_var_type EventInfoCorbaDef_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EventInfoCorbaDef,EventInfoCorbaDef_var > EventInfoCorbaDef_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventInfoCorbaDef;

  struct EvDataPkgCorbaDef {
    typedef _CORBA_ConstrType_Variable_Var<EvDataPkgCorbaDef> _var_type;

    
    ::CORBA::ULong ulDataSize;

    octetSeq eventDetail;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EvDataPkgCorbaDef::_var_type EvDataPkgCorbaDef_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EvDataPkgCorbaDef,EvDataPkgCorbaDef_var > EvDataPkgCorbaDef_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EvDataPkgCorbaDef;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventSequence;

  class EventSequence_var;

  class EventSequence : public _CORBA_Unbounded_Sequence< EventDetailCorbaDef >  {
  public:
    typedef EventSequence_var _var_type;
    inline EventSequence() {}
    inline EventSequence(const EventSequence& _s)
      : _CORBA_Unbounded_Sequence< EventDetailCorbaDef > (_s) {}

    inline EventSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< EventDetailCorbaDef > (_max) {}
    inline EventSequence(_CORBA_ULong _max, _CORBA_ULong _len, EventDetailCorbaDef* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< EventDetailCorbaDef > (_max, _len, _val, _rel) {}

  

    inline EventSequence& operator = (const EventSequence& _s) {
      _CORBA_Unbounded_Sequence< EventDetailCorbaDef > ::operator=(_s);
      return *this;
    }
  };

  class EventSequence_out;

  class EventSequence_var {
  public:
    inline EventSequence_var() : _pd_seq(0) {}
    inline EventSequence_var(EventSequence* _s) : _pd_seq(_s) {}
    inline EventSequence_var(const EventSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new EventSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~EventSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline EventSequence_var& operator = (EventSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline EventSequence_var& operator = (const EventSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new EventSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline EventDetailCorbaDef& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline EventSequence* operator -> () { return _pd_seq; }
    inline const EventSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator EventSequence& () const { return *_pd_seq; }
#else
    inline operator const EventSequence& () const { return *_pd_seq; }
    inline operator EventSequence& () { return *_pd_seq; }
#endif
      
    inline const EventSequence& in() const { return *_pd_seq; }
    inline EventSequence&       inout()    { return *_pd_seq; }
    inline EventSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline EventSequence* _retn() { EventSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class EventSequence_out;
    
  private:
    EventSequence* _pd_seq;
  };

  class EventSequence_out {
  public:
    inline EventSequence_out(EventSequence*& _s) : _data(_s) { _data = 0; }
    inline EventSequence_out(EventSequence_var& _s)
      : _data(_s._pd_seq) { _s = (EventSequence*) 0; }
    inline EventSequence_out(const EventSequence_out& _s) : _data(_s._data) {}
    inline EventSequence_out& operator = (const EventSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline EventSequence_out& operator = (EventSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator EventSequence*&()  { return _data; }
    inline EventSequence*& ptr()       { return _data; }
    inline EventSequence* operator->() { return _data; }

    inline EventDetailCorbaDef& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    EventSequence*& _data;

  private:
    EventSequence_out();
    EventSequence_out& operator=(const EventSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventSzSequence;

  class EventSzSequence_var;

  class EventSzSequence : public _CORBA_Unbounded_Sequence< EventSerializeCorbaDef >  {
  public:
    typedef EventSzSequence_var _var_type;
    inline EventSzSequence() {}
    inline EventSzSequence(const EventSzSequence& _s)
      : _CORBA_Unbounded_Sequence< EventSerializeCorbaDef > (_s) {}

    inline EventSzSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< EventSerializeCorbaDef > (_max) {}
    inline EventSzSequence(_CORBA_ULong _max, _CORBA_ULong _len, EventSerializeCorbaDef* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< EventSerializeCorbaDef > (_max, _len, _val, _rel) {}

  

    inline EventSzSequence& operator = (const EventSzSequence& _s) {
      _CORBA_Unbounded_Sequence< EventSerializeCorbaDef > ::operator=(_s);
      return *this;
    }
  };

  class EventSzSequence_out;

  class EventSzSequence_var {
  public:
    inline EventSzSequence_var() : _pd_seq(0) {}
    inline EventSzSequence_var(EventSzSequence* _s) : _pd_seq(_s) {}
    inline EventSzSequence_var(const EventSzSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new EventSzSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~EventSzSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline EventSzSequence_var& operator = (EventSzSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline EventSzSequence_var& operator = (const EventSzSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new EventSzSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline EventSerializeCorbaDef& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline EventSzSequence* operator -> () { return _pd_seq; }
    inline const EventSzSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator EventSzSequence& () const { return *_pd_seq; }
#else
    inline operator const EventSzSequence& () const { return *_pd_seq; }
    inline operator EventSzSequence& () { return *_pd_seq; }
#endif
      
    inline const EventSzSequence& in() const { return *_pd_seq; }
    inline EventSzSequence&       inout()    { return *_pd_seq; }
    inline EventSzSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline EventSzSequence* _retn() { EventSzSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class EventSzSequence_out;
    
  private:
    EventSzSequence* _pd_seq;
  };

  class EventSzSequence_out {
  public:
    inline EventSzSequence_out(EventSzSequence*& _s) : _data(_s) { _data = 0; }
    inline EventSzSequence_out(EventSzSequence_var& _s)
      : _data(_s._pd_seq) { _s = (EventSzSequence*) 0; }
    inline EventSzSequence_out(const EventSzSequence_out& _s) : _data(_s._data) {}
    inline EventSzSequence_out& operator = (const EventSzSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline EventSzSequence_out& operator = (EventSzSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator EventSzSequence*&()  { return _data; }
    inline EventSzSequence*& ptr()       { return _data; }
    inline EventSzSequence* operator->() { return _data; }

    inline EventSerializeCorbaDef& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    EventSzSequence*& _data;

  private:
    EventSzSequence_out();
    EventSzSequence_out& operator=(const EventSzSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventInfoSequence;

  class EventInfoSequence_var;

  class EventInfoSequence : public _CORBA_Unbounded_Sequence< EventInfoCorbaDef >  {
  public:
    typedef EventInfoSequence_var _var_type;
    inline EventInfoSequence() {}
    inline EventInfoSequence(const EventInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< EventInfoCorbaDef > (_s) {}

    inline EventInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< EventInfoCorbaDef > (_max) {}
    inline EventInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, EventInfoCorbaDef* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< EventInfoCorbaDef > (_max, _len, _val, _rel) {}

  

    inline EventInfoSequence& operator = (const EventInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< EventInfoCorbaDef > ::operator=(_s);
      return *this;
    }
  };

  class EventInfoSequence_out;

  class EventInfoSequence_var {
  public:
    inline EventInfoSequence_var() : _pd_seq(0) {}
    inline EventInfoSequence_var(EventInfoSequence* _s) : _pd_seq(_s) {}
    inline EventInfoSequence_var(const EventInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new EventInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~EventInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline EventInfoSequence_var& operator = (EventInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline EventInfoSequence_var& operator = (const EventInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new EventInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline EventInfoCorbaDef& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline EventInfoSequence* operator -> () { return _pd_seq; }
    inline const EventInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator EventInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const EventInfoSequence& () const { return *_pd_seq; }
    inline operator EventInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const EventInfoSequence& in() const { return *_pd_seq; }
    inline EventInfoSequence&       inout()    { return *_pd_seq; }
    inline EventInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline EventInfoSequence* _retn() { EventInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class EventInfoSequence_out;
    
  private:
    EventInfoSequence* _pd_seq;
  };

  class EventInfoSequence_out {
  public:
    inline EventInfoSequence_out(EventInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline EventInfoSequence_out(EventInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (EventInfoSequence*) 0; }
    inline EventInfoSequence_out(const EventInfoSequence_out& _s) : _data(_s._data) {}
    inline EventInfoSequence_out& operator = (const EventInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline EventInfoSequence_out& operator = (EventInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator EventInfoSequence*&()  { return _data; }
    inline EventInfoSequence*& ptr()       { return _data; }
    inline EventInfoSequence* operator->() { return _data; }

    inline EventInfoCorbaDef& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    EventInfoSequence*& _data;

  private:
    EventInfoSequence_out();
    EventInfoSequence_out& operator=(const EventInfoSequence_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EvSequenceNumber& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::EvSequenceNumber* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EvSequenceNumber*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EvSequenceNumber*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventDetailCorbaDef& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventDetailCorbaDef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventDetailCorbaDef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventDetailCorbaDef*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::octetSeq& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::octetSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::octetSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::octetSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventSerializeCorbaDef& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventSerializeCorbaDef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventSerializeCorbaDef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventSerializeCorbaDef*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventInfoCorbaDef& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventInfoCorbaDef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventInfoCorbaDef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventInfoCorbaDef*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EvDataPkgCorbaDef& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::EvDataPkgCorbaDef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EvDataPkgCorbaDef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EvDataPkgCorbaDef*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventSzSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventSzSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventSzSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventSzSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::EventInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::EventInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EventInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::EventInfoSequence*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventDetailCorbaDef
#endif

#endif  // __EventDetailCorbaDef_hh__

