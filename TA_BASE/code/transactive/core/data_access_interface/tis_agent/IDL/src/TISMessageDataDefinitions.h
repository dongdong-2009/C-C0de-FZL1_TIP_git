// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __TISMessageDataDefinitions_hh__
#define __TISMessageDataDefinitions_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Core

_CORBA_MODULE_BEG

  enum EDisplayMode { SCROLL_LEFT, SCROLL_RIGHT, SCROLL_UP, SCROLL_DOWN, NORMAL_STATIONARY, BLINKING, WIPING, SNOW, INSTANT_ON_STIS, SCROLL_LEFT_STIS, SCROLL_RIGHT_STIS, ROLL_UP_STIS, ROLL_DOWN_STIS, WIPE_LEFT_STIS, WIPE_RIGHT_STIS, LEFT_MULTIPLE_WIPING_STIS, RIGHT_MULTIPLE_WIPING_STIS, CURTAIN_OPEN_STIS, CURTAIN_CLOSE_STIS, RANDOM_ORDER_STIS, CENTER_SPREAD_STIS, TWO_ENDS_SPREAD_STIS, FLASHING_STIS, BLINKING_STIS, COLOR_CHANGE_STIS, DROPPING_STIS /*, __max_EDisplayMode=0xffffffff */ };
  typedef EDisplayMode& EDisplayMode_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EDisplayMode;

  enum EJustification { LEFT, CENTRED, RIGHT /*, __max_EJustification=0xffffffff */ };
  typedef EJustification& EJustification_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EJustification;

  enum ELibrarySection { EMERGENCY_SECTION, NORMAL_SECTION /*, __max_ELibrarySection=0xffffffff */ };
  typedef ELibrarySection& ELibrarySection_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELibrarySection;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainList;

  class TrainList_var;

  class TrainList : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef TrainList_var _var_type;
    inline TrainList() {}
    inline TrainList(const TrainList& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline TrainList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline TrainList(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline TrainList& operator = (const TrainList& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class TrainList_out;

  class TrainList_var {
  public:
    inline TrainList_var() : _pd_seq(0) {}
    inline TrainList_var(TrainList* _s) : _pd_seq(_s) {}
    inline TrainList_var(const TrainList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TrainList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TrainList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TrainList_var& operator = (TrainList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TrainList_var& operator = (const TrainList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TrainList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TrainList* operator -> () { return _pd_seq; }
    inline const TrainList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TrainList& () const { return *_pd_seq; }
#else
    inline operator const TrainList& () const { return *_pd_seq; }
    inline operator TrainList& () { return *_pd_seq; }
#endif
      
    inline const TrainList& in() const { return *_pd_seq; }
    inline TrainList&       inout()    { return *_pd_seq; }
    inline TrainList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TrainList* _retn() { TrainList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TrainList_out;
    
  private:
    TrainList* _pd_seq;
  };

  class TrainList_out {
  public:
    inline TrainList_out(TrainList*& _s) : _data(_s) { _data = 0; }
    inline TrainList_out(TrainList_var& _s)
      : _data(_s._pd_seq) { _s = (TrainList*) 0; }
    inline TrainList_out(const TrainList_out& _s) : _data(_s._data) {}
    inline TrainList_out& operator = (const TrainList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TrainList_out& operator = (TrainList* _s) {
      _data = _s;
      return *this;
    }
    inline operator TrainList*&()  { return _data; }
    inline TrainList*& ptr()       { return _data; }
    inline TrainList* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TrainList*& _data;

  private:
    TrainList_out();
    TrainList_out& operator=(const TrainList_var&);
  };

  enum EPIDSelection { ENTIRE_TRAIN, ALL_CAR1, ALL_CAR2, ALL_CAR3, CAR1_PID1, CAR1_PID2, CAR1_PID3, CAR1_PID4, CAR2_PID1, CAR2_PID2, CAR2_PID3, CAR2_PID4, CAR3_PID1, CAR3_PID2, CAR3_PID3, CAR3_PID4 /*, __max_EPIDSelection=0xffffffff */ };
  typedef EPIDSelection& EPIDSelection_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EPIDSelection;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainPIDList;

  // Need to declare <<= for elem type, as GCC expands templates early
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
   friend inline void operator >>= (EPIDSelection, cdrStream&);
   friend inline void operator <<= (EPIDSelection&, cdrStream&);
#endif

  class TrainPIDList_var;

  class TrainPIDList : public _CORBA_Unbounded_Sequence_w_FixSizeElement< EPIDSelection, 4, 4 >  {
  public:
    typedef TrainPIDList_var _var_type;
    inline TrainPIDList() {}
    inline TrainPIDList(const TrainPIDList& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< EPIDSelection, 4, 4 > (_s) {}

    inline TrainPIDList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< EPIDSelection, 4, 4 > (_max) {}
    inline TrainPIDList(_CORBA_ULong _max, _CORBA_ULong _len, EPIDSelection* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< EPIDSelection, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline TrainPIDList& operator = (const TrainPIDList& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< EPIDSelection, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class TrainPIDList_out;

  class TrainPIDList_var {
  public:
    inline TrainPIDList_var() : _pd_seq(0) {}
    inline TrainPIDList_var(TrainPIDList* _s) : _pd_seq(_s) {}
    inline TrainPIDList_var(const TrainPIDList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TrainPIDList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TrainPIDList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TrainPIDList_var& operator = (TrainPIDList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TrainPIDList_var& operator = (const TrainPIDList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TrainPIDList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline EPIDSelection& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TrainPIDList* operator -> () { return _pd_seq; }
    inline const TrainPIDList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TrainPIDList& () const { return *_pd_seq; }
#else
    inline operator const TrainPIDList& () const { return *_pd_seq; }
    inline operator TrainPIDList& () { return *_pd_seq; }
#endif
      
    inline const TrainPIDList& in() const { return *_pd_seq; }
    inline TrainPIDList&       inout()    { return *_pd_seq; }
    inline TrainPIDList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TrainPIDList* _retn() { TrainPIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TrainPIDList_out;
    
  private:
    TrainPIDList* _pd_seq;
  };

  class TrainPIDList_out {
  public:
    inline TrainPIDList_out(TrainPIDList*& _s) : _data(_s) { _data = 0; }
    inline TrainPIDList_out(TrainPIDList_var& _s)
      : _data(_s._pd_seq) { _s = (TrainPIDList*) 0; }
    inline TrainPIDList_out(const TrainPIDList_out& _s) : _data(_s._data) {}
    inline TrainPIDList_out& operator = (const TrainPIDList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TrainPIDList_out& operator = (TrainPIDList* _s) {
      _data = _s;
      return *this;
    }
    inline operator TrainPIDList*&()  { return _data; }
    inline TrainPIDList*& ptr()       { return _data; }
    inline TrainPIDList* operator->() { return _data; }

    inline EPIDSelection& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TrainPIDList*& _data;

  private:
    TrainPIDList_out();
    TrainPIDList_out& operator=(const TrainPIDList_var&);
  };

  enum ETTISLEDFontSize { TTIS_FONT_SIZE_SMALL, TTIS_FONT_SIZE_LARGE /*, __max_ETTISLEDFontSize=0xffffffff */ };
  typedef ETTISLEDFontSize& ETTISLEDFontSize_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETTISLEDFontSize;

  enum ETTISLEDIntensity { NORMAL, HIGH /*, __max_ETTISLEDIntensity=0xffffffff */ };
  typedef ETTISLEDIntensity& ETTISLEDIntensity_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETTISLEDIntensity;

  enum ETTISMessagePriority { TTIS_PRIORITY_1, TTIS_PRIORITY_2, TTIS_PRIORITY_3, TTIS_PRIORITY_4, TTIS_PRIORITY_5, TTIS_PRIORITY_6, TTIS_PRIORITY_7, TTIS_PRIORITY_8 /*, __max_ETTISMessagePriority=0xffffffff */ };
  typedef ETTISMessagePriority& ETTISMessagePriority_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETTISMessagePriority;

  enum ETTISClearType { CLEAR_ALL, CLEAR_EMERGENCY, CLEAR_NORMAL, CLEAR_PRIORITY6 /*, __max_ETTISClearType=0xffffffff */ };
  typedef ETTISClearType& ETTISClearType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETTISClearType;

  struct TTISMessageResetParameters {
    typedef _CORBA_ConstrType_Variable_Var<TTISMessageResetParameters> _var_type;

    
    TrainPIDList pidList;

    ETTISClearType messageType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TTISMessageResetParameters::_var_type TTISMessageResetParameters_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TTISMessageResetParameters,TTISMessageResetParameters_var > TTISMessageResetParameters_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TTISMessageResetParameters;

  struct TTISPredefinedMessageParameters {
    typedef _CORBA_ConstrType_Variable_Var<TTISPredefinedMessageParameters> _var_type;

    
    TrainPIDList pidList;

    ::CORBA::ULong libraryVersion;

    ::CORBA::Octet perRun;

    ::CORBA::UShort messageId;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TTISPredefinedMessageParameters::_var_type TTISPredefinedMessageParameters_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TTISPredefinedMessageParameters,TTISPredefinedMessageParameters_var > TTISPredefinedMessageParameters_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TTISPredefinedMessageParameters;

  struct TTISFreeTextMessageParameters {
    typedef _CORBA_ConstrType_Variable_Var<TTISFreeTextMessageParameters> _var_type;

    
    TrainPIDList pidList;

    ETTISLEDFontSize fontSize;

    EJustification justification;

    ETTISLEDIntensity intensity;

    EDisplayMode displayMode;

    ::CORBA::Octet perRun;

    ::CORBA::String_member message;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TTISFreeTextMessageParameters::_var_type TTISFreeTextMessageParameters_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TTISFreeTextMessageParameters,TTISFreeTextMessageParameters_var > TTISFreeTextMessageParameters_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TTISFreeTextMessageParameters;

  enum TisCommandType { TisFreeTextMessageCommand, TisPredefinedMessageCommand, TisClearCommand /*, __max_TisCommandType=0xffffffff */ };
  typedef TisCommandType& TisCommandType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisCommandType;

  struct TTISDisplayResult {
    typedef _CORBA_ConstrType_Variable_Var<TTISDisplayResult> _var_type;

    
    ::CORBA::Octet trainId;

    ::CORBA::String_member sessionId;

    ::CORBA::Long timestamp;

    ::CORBA::Boolean success;

    ::CORBA::String_member errorDetails;

    TisCommandType originalCommand;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TTISDisplayResult::_var_type TTISDisplayResult_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TTISDisplayResult,TTISDisplayResult_var > TTISDisplayResult_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TTISDisplayResult;

  struct TrainDataVersion {
    typedef _CORBA_ConstrType_Fix_Var<TrainDataVersion> _var_type;

    
    ::CORBA::Octet trainNumber;

    ::CORBA::ULong predefinedLibraryVersion;

    ::CORBA::ULong nextPredefinedLibraryVersion;

    ::CORBA::UShort trainTimeScheduleVersion;

    ::CORBA::UShort nextTrainTimeScheduleVersion;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TrainDataVersion::_var_type TrainDataVersion_var;

  typedef TrainDataVersion& TrainDataVersion_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDataVersion;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDataVersionList;

  class TrainDataVersionList_var;

  class TrainDataVersionList : public _CORBA_Unbounded_Sequence< TrainDataVersion >  {
  public:
    typedef TrainDataVersionList_var _var_type;
    inline TrainDataVersionList() {}
    inline TrainDataVersionList(const TrainDataVersionList& _s)
      : _CORBA_Unbounded_Sequence< TrainDataVersion > (_s) {}

    inline TrainDataVersionList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TrainDataVersion > (_max) {}
    inline TrainDataVersionList(_CORBA_ULong _max, _CORBA_ULong _len, TrainDataVersion* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TrainDataVersion > (_max, _len, _val, _rel) {}

  

    inline TrainDataVersionList& operator = (const TrainDataVersionList& _s) {
      _CORBA_Unbounded_Sequence< TrainDataVersion > ::operator=(_s);
      return *this;
    }
  };

  class TrainDataVersionList_out;

  class TrainDataVersionList_var {
  public:
    inline TrainDataVersionList_var() : _pd_seq(0) {}
    inline TrainDataVersionList_var(TrainDataVersionList* _s) : _pd_seq(_s) {}
    inline TrainDataVersionList_var(const TrainDataVersionList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TrainDataVersionList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TrainDataVersionList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TrainDataVersionList_var& operator = (TrainDataVersionList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TrainDataVersionList_var& operator = (const TrainDataVersionList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TrainDataVersionList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TrainDataVersion& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TrainDataVersionList* operator -> () { return _pd_seq; }
    inline const TrainDataVersionList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TrainDataVersionList& () const { return *_pd_seq; }
#else
    inline operator const TrainDataVersionList& () const { return *_pd_seq; }
    inline operator TrainDataVersionList& () { return *_pd_seq; }
#endif
      
    inline const TrainDataVersionList& in() const { return *_pd_seq; }
    inline TrainDataVersionList&       inout()    { return *_pd_seq; }
    inline TrainDataVersionList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TrainDataVersionList* _retn() { TrainDataVersionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TrainDataVersionList_out;
    
  private:
    TrainDataVersionList* _pd_seq;
  };

  class TrainDataVersionList_out {
  public:
    inline TrainDataVersionList_out(TrainDataVersionList*& _s) : _data(_s) { _data = 0; }
    inline TrainDataVersionList_out(TrainDataVersionList_var& _s)
      : _data(_s._pd_seq) { _s = (TrainDataVersionList*) 0; }
    inline TrainDataVersionList_out(const TrainDataVersionList_out& _s) : _data(_s._data) {}
    inline TrainDataVersionList_out& operator = (const TrainDataVersionList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TrainDataVersionList_out& operator = (TrainDataVersionList* _s) {
      _data = _s;
      return *this;
    }
    inline operator TrainDataVersionList*&()  { return _data; }
    inline TrainDataVersionList*& ptr()       { return _data; }
    inline TrainDataVersionList* operator->() { return _data; }

    inline TrainDataVersion& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TrainDataVersionList*& _data;

  private:
    TrainDataVersionList_out();
    TrainDataVersionList_out& operator=(const TrainDataVersionList_var&);
  };

  struct TrainDownload {
    typedef _CORBA_ConstrType_Fix_Var<TrainDownload> _var_type;

    
    ::CORBA::Octet trainNumber;

    ::CORBA::Boolean predefinedDownloadInProgress;

    ::CORBA::Boolean timeScheduleDownloadInProgress;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TrainDownload::_var_type TrainDownload_var;

  typedef TrainDownload& TrainDownload_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDownload;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDownloadList;

  class TrainDownloadList_var;

  class TrainDownloadList : public _CORBA_Unbounded_Sequence< TrainDownload >  {
  public:
    typedef TrainDownloadList_var _var_type;
    inline TrainDownloadList() {}
    inline TrainDownloadList(const TrainDownloadList& _s)
      : _CORBA_Unbounded_Sequence< TrainDownload > (_s) {}

    inline TrainDownloadList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TrainDownload > (_max) {}
    inline TrainDownloadList(_CORBA_ULong _max, _CORBA_ULong _len, TrainDownload* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TrainDownload > (_max, _len, _val, _rel) {}

  

    inline TrainDownloadList& operator = (const TrainDownloadList& _s) {
      _CORBA_Unbounded_Sequence< TrainDownload > ::operator=(_s);
      return *this;
    }
  };

  class TrainDownloadList_out;

  class TrainDownloadList_var {
  public:
    inline TrainDownloadList_var() : _pd_seq(0) {}
    inline TrainDownloadList_var(TrainDownloadList* _s) : _pd_seq(_s) {}
    inline TrainDownloadList_var(const TrainDownloadList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TrainDownloadList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TrainDownloadList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TrainDownloadList_var& operator = (TrainDownloadList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TrainDownloadList_var& operator = (const TrainDownloadList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TrainDownloadList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TrainDownload& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TrainDownloadList* operator -> () { return _pd_seq; }
    inline const TrainDownloadList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TrainDownloadList& () const { return *_pd_seq; }
#else
    inline operator const TrainDownloadList& () const { return *_pd_seq; }
    inline operator TrainDownloadList& () { return *_pd_seq; }
#endif
      
    inline const TrainDownloadList& in() const { return *_pd_seq; }
    inline TrainDownloadList&       inout()    { return *_pd_seq; }
    inline TrainDownloadList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TrainDownloadList* _retn() { TrainDownloadList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TrainDownloadList_out;
    
  private:
    TrainDownloadList* _pd_seq;
  };

  class TrainDownloadList_out {
  public:
    inline TrainDownloadList_out(TrainDownloadList*& _s) : _data(_s) { _data = 0; }
    inline TrainDownloadList_out(TrainDownloadList_var& _s)
      : _data(_s._pd_seq) { _s = (TrainDownloadList*) 0; }
    inline TrainDownloadList_out(const TrainDownloadList_out& _s) : _data(_s._data) {}
    inline TrainDownloadList_out& operator = (const TrainDownloadList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TrainDownloadList_out& operator = (TrainDownloadList* _s) {
      _data = _s;
      return *this;
    }
    inline operator TrainDownloadList*&()  { return _data; }
    inline TrainDownloadList*& ptr()       { return _data; }
    inline TrainDownloadList* operator->() { return _data; }

    inline TrainDownload& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TrainDownloadList*& _data;

  private:
    TrainDownloadList_out();
    TrainDownloadList_out& operator=(const TrainDownloadList_var&);
  };

  enum EDownloadChangeType { LibraryDownloadStart, LibraryDownloadFinish, LibraryUpgrade, ScheduleDownloadStart, ScheduleDownloadFinish, ScheduleUpgrade /*, __max_EDownloadChangeType=0xffffffff */ };
  typedef EDownloadChangeType& EDownloadChangeType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EDownloadChangeType;

  struct TrainDownloadStatus {
    typedef _CORBA_ConstrType_Variable_Var<TrainDownloadStatus> _var_type;

    
    ::CORBA::Octet trainNumber;

    EDownloadChangeType type;

    ::CORBA::Boolean success;

    ::CORBA::String_member errorDetails;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TrainDownloadStatus::_var_type TrainDownloadStatus_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TrainDownloadStatus,TrainDownloadStatus_var > TrainDownloadStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDownloadStatus;

  enum ETimeScheduleChangeType { Added, Deleted, Modified /*, __max_ETimeScheduleChangeType=0xffffffff */ };
  typedef ETimeScheduleChangeType& ETimeScheduleChangeType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETimeScheduleChangeType;

  struct TimeScheduleChange {
    typedef _CORBA_ConstrType_Fix_Var<TimeScheduleChange> _var_type;

    
    ::CORBA::ULong timeSchedulePkey;

    ETimeScheduleChangeType changeType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TimeScheduleChange::_var_type TimeScheduleChange_var;

  typedef TimeScheduleChange& TimeScheduleChange_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TimeScheduleChange;

  struct TrainDataVersionAlarms {
    typedef _CORBA_ConstrType_Variable_Var<TrainDataVersionAlarms> _var_type;

    
    ::CORBA::Octet trainNumber;

    ::CORBA::String_member messageLibraryMistmatchAlarm;

    ::CORBA::ULong iscsLibraryVersion;

    ::CORBA::ULong trainLibraryVersion;

    ::CORBA::String_member timeScheduleMistmatchAlarm;

    ::CORBA::UShort iscsScheduleVersion;

    ::CORBA::UShort trainScheduleVersion;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TrainDataVersionAlarms::_var_type TrainDataVersionAlarms_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TrainDataVersionAlarms,TrainDataVersionAlarms_var > TrainDataVersionAlarms_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDataVersionAlarms;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainDataVersionAlarmList;

  class TrainDataVersionAlarmList_var;

  class TrainDataVersionAlarmList : public _CORBA_Unbounded_Sequence< TrainDataVersionAlarms >  {
  public:
    typedef TrainDataVersionAlarmList_var _var_type;
    inline TrainDataVersionAlarmList() {}
    inline TrainDataVersionAlarmList(const TrainDataVersionAlarmList& _s)
      : _CORBA_Unbounded_Sequence< TrainDataVersionAlarms > (_s) {}

    inline TrainDataVersionAlarmList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TrainDataVersionAlarms > (_max) {}
    inline TrainDataVersionAlarmList(_CORBA_ULong _max, _CORBA_ULong _len, TrainDataVersionAlarms* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TrainDataVersionAlarms > (_max, _len, _val, _rel) {}

  

    inline TrainDataVersionAlarmList& operator = (const TrainDataVersionAlarmList& _s) {
      _CORBA_Unbounded_Sequence< TrainDataVersionAlarms > ::operator=(_s);
      return *this;
    }
  };

  class TrainDataVersionAlarmList_out;

  class TrainDataVersionAlarmList_var {
  public:
    inline TrainDataVersionAlarmList_var() : _pd_seq(0) {}
    inline TrainDataVersionAlarmList_var(TrainDataVersionAlarmList* _s) : _pd_seq(_s) {}
    inline TrainDataVersionAlarmList_var(const TrainDataVersionAlarmList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TrainDataVersionAlarmList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TrainDataVersionAlarmList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TrainDataVersionAlarmList_var& operator = (TrainDataVersionAlarmList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TrainDataVersionAlarmList_var& operator = (const TrainDataVersionAlarmList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TrainDataVersionAlarmList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TrainDataVersionAlarms& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TrainDataVersionAlarmList* operator -> () { return _pd_seq; }
    inline const TrainDataVersionAlarmList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TrainDataVersionAlarmList& () const { return *_pd_seq; }
#else
    inline operator const TrainDataVersionAlarmList& () const { return *_pd_seq; }
    inline operator TrainDataVersionAlarmList& () { return *_pd_seq; }
#endif
      
    inline const TrainDataVersionAlarmList& in() const { return *_pd_seq; }
    inline TrainDataVersionAlarmList&       inout()    { return *_pd_seq; }
    inline TrainDataVersionAlarmList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TrainDataVersionAlarmList* _retn() { TrainDataVersionAlarmList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TrainDataVersionAlarmList_out;
    
  private:
    TrainDataVersionAlarmList* _pd_seq;
  };

  class TrainDataVersionAlarmList_out {
  public:
    inline TrainDataVersionAlarmList_out(TrainDataVersionAlarmList*& _s) : _data(_s) { _data = 0; }
    inline TrainDataVersionAlarmList_out(TrainDataVersionAlarmList_var& _s)
      : _data(_s._pd_seq) { _s = (TrainDataVersionAlarmList*) 0; }
    inline TrainDataVersionAlarmList_out(const TrainDataVersionAlarmList_out& _s) : _data(_s._data) {}
    inline TrainDataVersionAlarmList_out& operator = (const TrainDataVersionAlarmList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TrainDataVersionAlarmList_out& operator = (TrainDataVersionAlarmList* _s) {
      _data = _s;
      return *this;
    }
    inline operator TrainDataVersionAlarmList*&()  { return _data; }
    inline TrainDataVersionAlarmList*& ptr()       { return _data; }
    inline TrainDataVersionAlarmList* operator->() { return _data; }

    inline TrainDataVersionAlarms& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TrainDataVersionAlarmList*& _data;

  private:
    TrainDataVersionAlarmList_out();
    TrainDataVersionAlarmList_out& operator=(const TrainDataVersionAlarmList_var&);
  };

  enum ELcdFontSize { LCD_SMALL_FONT, LCD_MEDIUM_FONT, LCD_LARGE_FONT /*, __max_ELcdFontSize=0xffffffff */ };
  typedef ELcdFontSize& ELcdFontSize_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELcdFontSize;

  enum ELcdFontColour { BLACK, WHITE, RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, ORANGE /*, __max_ELcdFontColour=0xffffffff */ };
  typedef ELcdFontColour& ELcdFontColour_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELcdFontColour;

  enum EScrollSpeed { SCROLL_SLOW, SCROLL_MEDIUM, SCROLL_FAST /*, __max_EScrollSpeed=0xffffffff */ };
  typedef EScrollSpeed& EScrollSpeed_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EScrollSpeed;

  enum EFontType { DEFAULT_PLASMA_FONT, TIMES_NEW_ROMAN, ARIAL, COURIER_NEW, PLASMA_FONT_RESERVED4, PLASMA_FONT_RESERVED5, PLASMA_FONT_RESERVED6, PLASMA_FONT_RESERVED7, PLASMA_FONT_RESERVED8, PLASMA_FONT_RESERVED9 /*, __max_EFontType=0xffffffff */ };
  typedef EFontType& EFontType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EFontType;

  enum EPlasmaColour { PLASMA_BLACK, PLASMA_WHITE, PLASMA_RED, PLASMA_GREEN, PLASMA_BLUE, PLASMA_YELLOW, PLASMA_CYAN, PLASMA_MAGENTA, PLASMA_ORANGE, PLASMA_BROWN, PLASMA_GREY, PLASMA_LIGHT_BLUE, PLASMA_LIGHT_GREEN, PLASMA_LIGHT_RED, PLASMA_COLOUR_RESERVED_E, PLASMA_COLOUR_RESERVED_F /*, __max_EPlasmaColour=0xffffffff */ };
  typedef EPlasmaColour& EPlasmaColour_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EPlasmaColour;

  enum EPlasmaFontSize { PLASMA_FONT_SIZE_UNUSED, PLASMA_FONT_SIZE_24, PLASMA_FONT_SIZE_36, PLASMA_FONT_SIZE_42, PLASMA_FONT_SIZE_48, PLASMA_FONT_SIZE_60, PLASMA_FONT_SIZE_72, PLASMA_FONT_SIZE_96, PLASMA_FONT_SIZE_128 /*, __max_EPlasmaFontSize=0xffffffff */ };
  typedef EPlasmaFontSize& EPlasmaFontSize_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EPlasmaFontSize;

  enum EStationType { DEPARTURE, ARRIVAL /*, __max_EStationType=0xffffffff */ };
  typedef EStationType& EStationType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EStationType;

  enum ELEDColour { LED_RED, LED_GREEN, LED_ORANGE /*, __max_ELEDColour=0xffffffff */ };
  typedef ELEDColour& ELEDColour_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELEDColour;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELEDFontColour;

  typedef ELEDColour ELEDFontColour;
  typedef ELEDColour_out ELEDFontColour_out;

  enum ELEDFontSize { FONT_SIZE_SMALL, FONT_SIZE_MEDIUM, FONT_SIZE_LARGE /*, __max_ELEDFontSize=0xffffffff */ };
  typedef ELEDFontSize& ELEDFontSize_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELEDFontSize;

  enum ELEDIntensity { INTENSITY_LOW, INTENSITY_MEDIUM, INTENSITY_HIGH /*, __max_ELEDIntensity=0xffffffff */ };
  typedef ELEDIntensity& ELEDIntensity_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ELEDIntensity;

  enum EStatusRequestType { STATUS_REQUEST_OCC, STATUS_REQUEST_STATION /*, __max_EStatusRequestType=0xffffffff */ };
  typedef EStatusRequestType& EStatusRequestType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EStatusRequestType;

  enum ERATISMessageType { RATIS_IN_NEW, RATIS_OUT_NEW, RATIS_IN_UPDATE, RATIS_OUT_UPDATE, RATIS_IN_CLEAR, RATIS_OUT_CLEAR /*, __max_ERATISMessageType=0xffffffff */ };
  typedef ERATISMessageType& ERATISMessageType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ERATISMessageType;

  enum ERATISMessageStatus { APPROVED, NOT_APPROVED, REJECTED, APPROVE_FAILED /*, __max_ERATISMessageStatus=0xffffffff */ };
  typedef ERATISMessageStatus& ERATISMessageStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ERATISMessageStatus;

  enum EPIDControl { TURN_ON, TURN_OFF /*, __max_EPIDControl=0xffffffff */ };
  typedef EPIDControl& EPIDControl_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EPIDControl;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PIDList;

  class PIDList_var;

  class PIDList : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef PIDList_var _var_type;
    inline PIDList() {}
    inline PIDList(const PIDList& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline PIDList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline PIDList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline PIDList& operator = (const PIDList& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class PIDList_out;

  class PIDList_var {
  public:
    inline PIDList_var() : _pd_seq(0) {}
    inline PIDList_var(PIDList* _s) : _pd_seq(_s) {}
    inline PIDList_var(const PIDList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PIDList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PIDList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PIDList_var& operator = (PIDList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PIDList_var& operator = (const PIDList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PIDList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PIDList* operator -> () { return _pd_seq; }
    inline const PIDList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PIDList& () const { return *_pd_seq; }
#else
    inline operator const PIDList& () const { return *_pd_seq; }
    inline operator PIDList& () { return *_pd_seq; }
#endif
      
    inline const PIDList& in() const { return *_pd_seq; }
    inline PIDList&       inout()    { return *_pd_seq; }
    inline PIDList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PIDList* _retn() { PIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PIDList_out;
    
  private:
    PIDList* _pd_seq;
  };

  class PIDList_out {
  public:
    inline PIDList_out(PIDList*& _s) : _data(_s) { _data = 0; }
    inline PIDList_out(PIDList_var& _s)
      : _data(_s._pd_seq) { _s = (PIDList*) 0; }
    inline PIDList_out(const PIDList_out& _s) : _data(_s._data) {}
    inline PIDList_out& operator = (const PIDList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PIDList_out& operator = (PIDList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PIDList*&()  { return _data; }
    inline PIDList*& ptr()       { return _data; }
    inline PIDList* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PIDList*& _data;

  private:
    PIDList_out();
    PIDList_out& operator=(const PIDList_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LevelList;

  class LevelList_var;

  class LevelList : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef LevelList_var _var_type;
    inline LevelList() {}
    inline LevelList(const LevelList& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline LevelList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline LevelList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline LevelList& operator = (const LevelList& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class LevelList_out;

  class LevelList_var {
  public:
    inline LevelList_var() : _pd_seq(0) {}
    inline LevelList_var(LevelList* _s) : _pd_seq(_s) {}
    inline LevelList_var(const LevelList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LevelList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LevelList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LevelList_var& operator = (LevelList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LevelList_var& operator = (const LevelList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LevelList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LevelList* operator -> () { return _pd_seq; }
    inline const LevelList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LevelList& () const { return *_pd_seq; }
#else
    inline operator const LevelList& () const { return *_pd_seq; }
    inline operator LevelList& () { return *_pd_seq; }
#endif
      
    inline const LevelList& in() const { return *_pd_seq; }
    inline LevelList&       inout()    { return *_pd_seq; }
    inline LevelList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LevelList* _retn() { LevelList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LevelList_out;
    
  private:
    LevelList* _pd_seq;
  };

  class LevelList_out {
  public:
    inline LevelList_out(LevelList*& _s) : _data(_s) { _data = 0; }
    inline LevelList_out(LevelList_var& _s)
      : _data(_s._pd_seq) { _s = (LevelList*) 0; }
    inline LevelList_out(const LevelList_out& _s) : _data(_s._data) {}
    inline LevelList_out& operator = (const LevelList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LevelList_out& operator = (LevelList* _s) {
      _data = _s;
      return *this;
    }
    inline operator LevelList*&()  { return _data; }
    inline LevelList*& ptr()       { return _data; }
    inline LevelList* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LevelList*& _data;

  private:
    LevelList_out();
    LevelList_out& operator=(const LevelList_var&);
  };

  struct STISDestination {
    typedef _CORBA_ConstrType_Variable_Var<STISDestination> _var_type;

    
    ::CORBA::String_member station;

    LevelList levels;

    PIDList pids;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef STISDestination::_var_type STISDestination_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< STISDestination,STISDestination_var > STISDestination_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_STISDestination;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_STISDestinationList;

  class STISDestinationList_var;

  class STISDestinationList : public _CORBA_Unbounded_Sequence< STISDestination >  {
  public:
    typedef STISDestinationList_var _var_type;
    inline STISDestinationList() {}
    inline STISDestinationList(const STISDestinationList& _s)
      : _CORBA_Unbounded_Sequence< STISDestination > (_s) {}

    inline STISDestinationList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< STISDestination > (_max) {}
    inline STISDestinationList(_CORBA_ULong _max, _CORBA_ULong _len, STISDestination* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< STISDestination > (_max, _len, _val, _rel) {}

  

    inline STISDestinationList& operator = (const STISDestinationList& _s) {
      _CORBA_Unbounded_Sequence< STISDestination > ::operator=(_s);
      return *this;
    }
  };

  class STISDestinationList_out;

  class STISDestinationList_var {
  public:
    inline STISDestinationList_var() : _pd_seq(0) {}
    inline STISDestinationList_var(STISDestinationList* _s) : _pd_seq(_s) {}
    inline STISDestinationList_var(const STISDestinationList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new STISDestinationList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~STISDestinationList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline STISDestinationList_var& operator = (STISDestinationList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline STISDestinationList_var& operator = (const STISDestinationList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new STISDestinationList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline STISDestination& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline STISDestinationList* operator -> () { return _pd_seq; }
    inline const STISDestinationList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator STISDestinationList& () const { return *_pd_seq; }
#else
    inline operator const STISDestinationList& () const { return *_pd_seq; }
    inline operator STISDestinationList& () { return *_pd_seq; }
#endif
      
    inline const STISDestinationList& in() const { return *_pd_seq; }
    inline STISDestinationList&       inout()    { return *_pd_seq; }
    inline STISDestinationList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline STISDestinationList* _retn() { STISDestinationList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class STISDestinationList_out;
    
  private:
    STISDestinationList* _pd_seq;
  };

  class STISDestinationList_out {
  public:
    inline STISDestinationList_out(STISDestinationList*& _s) : _data(_s) { _data = 0; }
    inline STISDestinationList_out(STISDestinationList_var& _s)
      : _data(_s._pd_seq) { _s = (STISDestinationList*) 0; }
    inline STISDestinationList_out(const STISDestinationList_out& _s) : _data(_s._data) {}
    inline STISDestinationList_out& operator = (const STISDestinationList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline STISDestinationList_out& operator = (STISDestinationList* _s) {
      _data = _s;
      return *this;
    }
    inline operator STISDestinationList*&()  { return _data; }
    inline STISDestinationList*& ptr()       { return _data; }
    inline STISDestinationList* operator->() { return _data; }

    inline STISDestination& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    STISDestinationList*& _data;

  private:
    STISDestinationList_out();
    STISDestinationList_out& operator=(const STISDestinationList_var&);
  };

  struct DisplayAttributes {
    typedef _CORBA_ConstrType_Fix_Var<DisplayAttributes> _var_type;

    
    EDisplayMode displayMode;

    EScrollSpeed scrollSpeed;

    ::CORBA::Short repeatInterval;

    ::CORBA::Short displayTime;

    ::CORBA::Octet perRun;

    EJustification justification;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DisplayAttributes::_var_type DisplayAttributes_var;

  typedef DisplayAttributes& DisplayAttributes_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisplayAttributes;

  struct PlasmaAttributes {
    typedef _CORBA_ConstrType_Fix_Var<PlasmaAttributes> _var_type;

    
    EFontType fontType;

    EPlasmaFontSize fontSize;

    EPlasmaColour fontColour;

    EPlasmaColour backgroundColour;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PlasmaAttributes::_var_type PlasmaAttributes_var;

  typedef PlasmaAttributes& PlasmaAttributes_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PlasmaAttributes;

  struct STISAttributes {
    typedef _CORBA_ConstrType_Fix_Var<STISAttributes> _var_type;

    
    EDisplayMode displayMode;

    EScrollSpeed scrollSpeed;

    ::CORBA::UShort repeatInterval;

    ::CORBA::UShort displayTime;

    EJustification justification;

    ELcdFontSize lcdFontSize;

    ELcdFontColour lcdFontColour;

    ELEDFontSize ledFontSize;

    ELEDFontColour ledFontColour;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef STISAttributes::_var_type STISAttributes_var;

  typedef STISAttributes& STISAttributes_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_STISAttributes;

  struct LEDAttributes {
    typedef _CORBA_ConstrType_Fix_Var<LEDAttributes> _var_type;

    
    ELEDFontSize fontSize;

    ELEDFontColour fontColour;

    ELEDIntensity intensity;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LEDAttributes::_var_type LEDAttributes_var;

  typedef LEDAttributes& LEDAttributes_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LEDAttributes;

  struct LCDAttributesSTIS {
    typedef _CORBA_ConstrType_Fix_Var<LCDAttributesSTIS> _var_type;

    
    ELcdFontSize fontSize;

    ELcdFontColour fontColour;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LCDAttributesSTIS::_var_type LCDAttributesSTIS_var;

  typedef LCDAttributesSTIS& LCDAttributesSTIS_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LCDAttributesSTIS;

  struct TimeScheduleVersion {
    typedef _CORBA_ConstrType_Fix_Var<TimeScheduleVersion> _var_type;

    
    ::CORBA::UShort version;

    ::CORBA::ULong timeScheduleKey;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TimeScheduleVersion::_var_type TimeScheduleVersion_var;

  typedef TimeScheduleVersion& TimeScheduleVersion_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TimeScheduleVersion;

  enum IfSendSuccess { Pass, Fail, NA /*, __max_IfSendSuccess=0xffffffff */ };
  typedef IfSendSuccess& IfSendSuccess_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IfSendSuccess;

  struct CurrentDisplayingMessage {
    typedef _CORBA_ConstrType_Variable_Var<CurrentDisplayingMessage> _var_type;

    
    ::CORBA::WString_member messageContent;

    ::CORBA::String_member startTime;

    ::CORBA::String_member endTime;

    ::CORBA::Short priority;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CurrentDisplayingMessage::_var_type CurrentDisplayingMessage_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< CurrentDisplayingMessage,CurrentDisplayingMessage_var > CurrentDisplayingMessage_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CurrentDisplayingMessage;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(TA_Base_Core::EDisplayMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EDisplayMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::DROPPING_STIS) {
    _e = (TA_Base_Core::EDisplayMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EDisplayMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EDisplayMode& _s);

inline void operator >>=(TA_Base_Core::EJustification _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EJustification& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::RIGHT) {
    _e = (TA_Base_Core::EJustification) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EJustification _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EJustification& _s);

inline void operator >>=(TA_Base_Core::ELibrarySection _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELibrarySection& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::NORMAL_SECTION) {
    _e = (TA_Base_Core::ELibrarySection) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELibrarySection _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELibrarySection& _s);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainList*& _sp);

inline void operator >>=(TA_Base_Core::EPIDSelection _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EPIDSelection& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::CAR3_PID4) {
    _e = (TA_Base_Core::EPIDSelection) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EPIDSelection _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EPIDSelection& _s);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainPIDList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainPIDList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainPIDList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainPIDList*& _sp);

inline void operator >>=(TA_Base_Core::ETTISLEDFontSize _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ETTISLEDFontSize& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::TTIS_FONT_SIZE_LARGE) {
    _e = (TA_Base_Core::ETTISLEDFontSize) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ETTISLEDFontSize _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ETTISLEDFontSize& _s);

inline void operator >>=(TA_Base_Core::ETTISLEDIntensity _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ETTISLEDIntensity& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::HIGH) {
    _e = (TA_Base_Core::ETTISLEDIntensity) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ETTISLEDIntensity _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ETTISLEDIntensity& _s);

inline void operator >>=(TA_Base_Core::ETTISMessagePriority _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ETTISMessagePriority& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::TTIS_PRIORITY_8) {
    _e = (TA_Base_Core::ETTISMessagePriority) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ETTISMessagePriority _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ETTISMessagePriority& _s);

inline void operator >>=(TA_Base_Core::ETTISClearType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ETTISClearType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::CLEAR_PRIORITY6) {
    _e = (TA_Base_Core::ETTISClearType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ETTISClearType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ETTISClearType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TTISMessageResetParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TTISMessageResetParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TTISMessageResetParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TTISMessageResetParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TTISPredefinedMessageParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TTISPredefinedMessageParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TTISPredefinedMessageParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TTISPredefinedMessageParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TTISFreeTextMessageParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TTISFreeTextMessageParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TTISFreeTextMessageParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TTISFreeTextMessageParameters*& _sp);

inline void operator >>=(TA_Base_Core::TisCommandType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::TisCommandType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::TisClearCommand) {
    _e = (TA_Base_Core::TisCommandType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::TisCommandType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TisCommandType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TTISDisplayResult& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TTISDisplayResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TTISDisplayResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TTISDisplayResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDataVersion& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDataVersion* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDataVersion*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDataVersion*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDataVersionList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDataVersionList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDownload& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDownload* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDownload*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDownload*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDownloadList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDownloadList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDownloadList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDownloadList*& _sp);

inline void operator >>=(TA_Base_Core::EDownloadChangeType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EDownloadChangeType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::ScheduleUpgrade) {
    _e = (TA_Base_Core::EDownloadChangeType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EDownloadChangeType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EDownloadChangeType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDownloadStatus& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDownloadStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDownloadStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDownloadStatus*& _sp);

inline void operator >>=(TA_Base_Core::ETimeScheduleChangeType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ETimeScheduleChangeType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::Modified) {
    _e = (TA_Base_Core::ETimeScheduleChangeType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ETimeScheduleChangeType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ETimeScheduleChangeType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TimeScheduleChange& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TimeScheduleChange* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TimeScheduleChange*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TimeScheduleChange*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionAlarms& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDataVersionAlarms* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDataVersionAlarms*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionAlarms*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionAlarmList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::TrainDataVersionAlarmList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TrainDataVersionAlarmList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TrainDataVersionAlarmList*& _sp);

inline void operator >>=(TA_Base_Core::ELcdFontSize _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELcdFontSize& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::LCD_LARGE_FONT) {
    _e = (TA_Base_Core::ELcdFontSize) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELcdFontSize _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELcdFontSize& _s);

inline void operator >>=(TA_Base_Core::ELcdFontColour _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELcdFontColour& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::ORANGE) {
    _e = (TA_Base_Core::ELcdFontColour) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELcdFontColour _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELcdFontColour& _s);

inline void operator >>=(TA_Base_Core::EScrollSpeed _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EScrollSpeed& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::SCROLL_FAST) {
    _e = (TA_Base_Core::EScrollSpeed) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EScrollSpeed _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EScrollSpeed& _s);

inline void operator >>=(TA_Base_Core::EFontType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EFontType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::PLASMA_FONT_RESERVED9) {
    _e = (TA_Base_Core::EFontType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EFontType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EFontType& _s);

inline void operator >>=(TA_Base_Core::EPlasmaColour _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EPlasmaColour& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::PLASMA_COLOUR_RESERVED_F) {
    _e = (TA_Base_Core::EPlasmaColour) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EPlasmaColour _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EPlasmaColour& _s);

inline void operator >>=(TA_Base_Core::EPlasmaFontSize _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EPlasmaFontSize& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::PLASMA_FONT_SIZE_128) {
    _e = (TA_Base_Core::EPlasmaFontSize) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EPlasmaFontSize _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EPlasmaFontSize& _s);

inline void operator >>=(TA_Base_Core::EStationType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EStationType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::ARRIVAL) {
    _e = (TA_Base_Core::EStationType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EStationType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EStationType& _s);

inline void operator >>=(TA_Base_Core::ELEDColour _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELEDColour& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::LED_ORANGE) {
    _e = (TA_Base_Core::ELEDColour) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELEDColour _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELEDColour& _s);

inline void operator >>=(TA_Base_Core::ELEDFontSize _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELEDFontSize& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::FONT_SIZE_LARGE) {
    _e = (TA_Base_Core::ELEDFontSize) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELEDFontSize _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELEDFontSize& _s);

inline void operator >>=(TA_Base_Core::ELEDIntensity _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ELEDIntensity& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::INTENSITY_HIGH) {
    _e = (TA_Base_Core::ELEDIntensity) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ELEDIntensity _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ELEDIntensity& _s);

inline void operator >>=(TA_Base_Core::EStatusRequestType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EStatusRequestType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::STATUS_REQUEST_STATION) {
    _e = (TA_Base_Core::EStatusRequestType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EStatusRequestType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EStatusRequestType& _s);

inline void operator >>=(TA_Base_Core::ERATISMessageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ERATISMessageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::RATIS_OUT_CLEAR) {
    _e = (TA_Base_Core::ERATISMessageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ERATISMessageType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ERATISMessageType& _s);

inline void operator >>=(TA_Base_Core::ERATISMessageStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::ERATISMessageStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::APPROVE_FAILED) {
    _e = (TA_Base_Core::ERATISMessageStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::ERATISMessageStatus _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ERATISMessageStatus& _s);

inline void operator >>=(TA_Base_Core::EPIDControl _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EPIDControl& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::TURN_OFF) {
    _e = (TA_Base_Core::EPIDControl) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EPIDControl _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EPIDControl& _s);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::PIDList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::PIDList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::PIDList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::PIDList*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::LevelList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::LevelList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::LevelList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::LevelList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::STISDestination& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::STISDestination* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::STISDestination*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::STISDestination*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::STISDestinationList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::STISDestinationList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::STISDestinationList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::STISDestinationList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::DisplayAttributes& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::DisplayAttributes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::DisplayAttributes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::DisplayAttributes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::PlasmaAttributes& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::PlasmaAttributes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::PlasmaAttributes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::PlasmaAttributes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::STISAttributes& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::STISAttributes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::STISAttributes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::STISAttributes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::LEDAttributes& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::LEDAttributes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::LEDAttributes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::LEDAttributes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::LCDAttributesSTIS& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::LCDAttributesSTIS* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::LCDAttributesSTIS*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::LCDAttributesSTIS*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::TimeScheduleVersion& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::TimeScheduleVersion* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::TimeScheduleVersion*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::TimeScheduleVersion*& _sp);

inline void operator >>=(TA_Base_Core::IfSendSuccess _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::IfSendSuccess& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::NA) {
    _e = (TA_Base_Core::IfSendSuccess) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::IfSendSuccess _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::IfSendSuccess& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::CurrentDisplayingMessage& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::CurrentDisplayingMessage* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::CurrentDisplayingMessage*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::CurrentDisplayingMessage*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_TISMessageDataDefinitions
#endif

#endif  // __TISMessageDataDefinitions_hh__

