// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __ProcessManagementDataDefinitionsCorbaDef_hh__
#define __ProcessManagementDataDefinitionsCorbaDef_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Core

_CORBA_MODULE_BEG

  _CORBA_MODULE_VARINT const ::CORBA::UShort DEFAULT_MGR_PORT _init_in_decl_( = 6666 );

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProcessId;

  typedef ::CORBA::ULong ProcessId;
  typedef ::CORBA::ULong_out ProcessId_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DateTime_ul;

  typedef ::CORBA::ULong DateTime_ul;
  typedef ::CORBA::ULong_out DateTime_ul_out;

  enum EManagedProcessTerminateCode { RequestedTerminate, InitError, CommsError, UserExit, DependencyFailure, TimeoutError, FatalError, AccessDenied, NoActiveSession, RightsError, ConfigError, NotKnown /*, __max_EManagedProcessTerminateCode=0xffffffff */ };
  typedef EManagedProcessTerminateCode& EManagedProcessTerminateCode_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EManagedProcessTerminateCode;

  enum EOperationMode { Control, Monitor, NotApplicable, Standby /*, __max_EOperationMode=0xffffffff */ };
  typedef EOperationMode& EOperationMode_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EOperationMode;

  enum EFocusType { GetFocus, Minimise, Maximise /*, __max_EFocusType=0xffffffff */ };
  typedef EFocusType& EFocusType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EFocusType;

  enum EProcessStatus { Unstarted, Startup, GoingToControl, GoingToMonitor, RunningControl, RunningMonitor, Terminating, NotRunning, Stopped, RunningStandby, GoingToStandby /*, __max_EProcessStatus=0xffffffff */ };
  typedef EProcessStatus& EProcessStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EProcessStatus;

  enum AgentStatusEnum { Normal, Abnormal, AgentFault /*, __max_AgentStatusEnum=0xffffffff */ };
  typedef AgentStatusEnum& AgentStatusEnum_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AgentStatusEnum;

  struct ProcessData {
    typedef _CORBA_ConstrType_Variable_Var<ProcessData> _var_type;

    
    ::CORBA::String_member ProcessId;

    DateTime_ul started;

    ::CORBA::String_member host;

    EProcessStatus state;

    EProcessStatus requestedState;

    EOperationMode operationMode;

    ::CORBA::UShort restarts;

    ::CORBA::String_member debugLevel;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ProcessData::_var_type ProcessData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ProcessData,ProcessData_var > ProcessData_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProcessData;

  class BadParam : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member reason;

  

    inline BadParam() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    BadParam(const BadParam&);
    BadParam(const char* i_reason);
    BadParam& operator=(const BadParam&);
    virtual ~BadParam();
    virtual void _raise() const;
    static BadParam* _downcast(::CORBA::Exception*);
    static const BadParam* _downcast(const ::CORBA::Exception*);
    static inline BadParam* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BadParam;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProcessDataSeq;

  class ProcessDataSeq_var;

  class ProcessDataSeq : public _CORBA_Unbounded_Sequence< ProcessData >  {
  public:
    typedef ProcessDataSeq_var _var_type;
    inline ProcessDataSeq() {}
    inline ProcessDataSeq(const ProcessDataSeq& _s)
      : _CORBA_Unbounded_Sequence< ProcessData > (_s) {}

    inline ProcessDataSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ProcessData > (_max) {}
    inline ProcessDataSeq(_CORBA_ULong _max, _CORBA_ULong _len, ProcessData* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ProcessData > (_max, _len, _val, _rel) {}

  

    inline ProcessDataSeq& operator = (const ProcessDataSeq& _s) {
      _CORBA_Unbounded_Sequence< ProcessData > ::operator=(_s);
      return *this;
    }
  };

  class ProcessDataSeq_out;

  class ProcessDataSeq_var {
  public:
    inline ProcessDataSeq_var() : _pd_seq(0) {}
    inline ProcessDataSeq_var(ProcessDataSeq* _s) : _pd_seq(_s) {}
    inline ProcessDataSeq_var(const ProcessDataSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ProcessDataSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ProcessDataSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ProcessDataSeq_var& operator = (ProcessDataSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ProcessDataSeq_var& operator = (const ProcessDataSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ProcessDataSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ProcessData& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ProcessDataSeq* operator -> () { return _pd_seq; }
    inline const ProcessDataSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ProcessDataSeq& () const { return *_pd_seq; }
#else
    inline operator const ProcessDataSeq& () const { return *_pd_seq; }
    inline operator ProcessDataSeq& () { return *_pd_seq; }
#endif
      
    inline const ProcessDataSeq& in() const { return *_pd_seq; }
    inline ProcessDataSeq&       inout()    { return *_pd_seq; }
    inline ProcessDataSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ProcessDataSeq* _retn() { ProcessDataSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ProcessDataSeq_out;
    
  private:
    ProcessDataSeq* _pd_seq;
  };

  class ProcessDataSeq_out {
  public:
    inline ProcessDataSeq_out(ProcessDataSeq*& _s) : _data(_s) { _data = 0; }
    inline ProcessDataSeq_out(ProcessDataSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ProcessDataSeq*) 0; }
    inline ProcessDataSeq_out(const ProcessDataSeq_out& _s) : _data(_s._data) {}
    inline ProcessDataSeq_out& operator = (const ProcessDataSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ProcessDataSeq_out& operator = (ProcessDataSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ProcessDataSeq*&()  { return _data; }
    inline ProcessDataSeq*& ptr()       { return _data; }
    inline ProcessDataSeq* operator->() { return _data; }

    inline ProcessData& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ProcessDataSeq*& _data;

  private:
    ProcessDataSeq_out();
    ProcessDataSeq_out& operator=(const ProcessDataSeq_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE TA_Base_Core

_CORBA_MODULE_BEG

  struct RunParam {
    typedef _CORBA_ConstrType_Variable_Var<RunParam> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::String_member value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RunParam::_var_type RunParam_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< RunParam,RunParam_var > RunParam_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RunParam;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RunParamSeq;

  class RunParamSeq_var;

  class RunParamSeq : public _CORBA_Unbounded_Sequence< RunParam >  {
  public:
    typedef RunParamSeq_var _var_type;
    inline RunParamSeq() {}
    inline RunParamSeq(const RunParamSeq& _s)
      : _CORBA_Unbounded_Sequence< RunParam > (_s) {}

    inline RunParamSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< RunParam > (_max) {}
    inline RunParamSeq(_CORBA_ULong _max, _CORBA_ULong _len, RunParam* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< RunParam > (_max, _len, _val, _rel) {}

  

    inline RunParamSeq& operator = (const RunParamSeq& _s) {
      _CORBA_Unbounded_Sequence< RunParam > ::operator=(_s);
      return *this;
    }
  };

  class RunParamSeq_out;

  class RunParamSeq_var {
  public:
    inline RunParamSeq_var() : _pd_seq(0) {}
    inline RunParamSeq_var(RunParamSeq* _s) : _pd_seq(_s) {}
    inline RunParamSeq_var(const RunParamSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RunParamSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RunParamSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RunParamSeq_var& operator = (RunParamSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RunParamSeq_var& operator = (const RunParamSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RunParamSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline RunParam& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RunParamSeq* operator -> () { return _pd_seq; }
    inline const RunParamSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RunParamSeq& () const { return *_pd_seq; }
#else
    inline operator const RunParamSeq& () const { return *_pd_seq; }
    inline operator RunParamSeq& () { return *_pd_seq; }
#endif
      
    inline const RunParamSeq& in() const { return *_pd_seq; }
    inline RunParamSeq&       inout()    { return *_pd_seq; }
    inline RunParamSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RunParamSeq* _retn() { RunParamSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RunParamSeq_out;
    
  private:
    RunParamSeq* _pd_seq;
  };

  class RunParamSeq_out {
  public:
    inline RunParamSeq_out(RunParamSeq*& _s) : _data(_s) { _data = 0; }
    inline RunParamSeq_out(RunParamSeq_var& _s)
      : _data(_s._pd_seq) { _s = (RunParamSeq*) 0; }
    inline RunParamSeq_out(const RunParamSeq_out& _s) : _data(_s._data) {}
    inline RunParamSeq_out& operator = (const RunParamSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RunParamSeq_out& operator = (RunParamSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator RunParamSeq*&()  { return _data; }
    inline RunParamSeq*& ptr()       { return _data; }
    inline RunParamSeq* operator->() { return _data; }

    inline RunParam& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RunParamSeq*& _data;

  private:
    RunParamSeq_out();
    RunParamSeq_out& operator=(const RunParamSeq_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_TA_Base_Core
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(TA_Base_Core::EManagedProcessTerminateCode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EManagedProcessTerminateCode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::NotKnown) {
    _e = (TA_Base_Core::EManagedProcessTerminateCode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EManagedProcessTerminateCode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EManagedProcessTerminateCode& _s);

inline void operator >>=(TA_Base_Core::EOperationMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EOperationMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::Standby) {
    _e = (TA_Base_Core::EOperationMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EOperationMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EOperationMode& _s);

inline void operator >>=(TA_Base_Core::EFocusType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EFocusType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::Maximise) {
    _e = (TA_Base_Core::EFocusType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EFocusType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EFocusType& _s);

inline void operator >>=(TA_Base_Core::EProcessStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::EProcessStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::GoingToStandby) {
    _e = (TA_Base_Core::EProcessStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::EProcessStatus _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::EProcessStatus& _s);

inline void operator >>=(TA_Base_Core::AgentStatusEnum _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Core::AgentStatusEnum& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Core::AgentFault) {
    _e = (TA_Base_Core::AgentStatusEnum) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Core::AgentStatusEnum _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::AgentStatusEnum& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::ProcessData& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::ProcessData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ProcessData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::ProcessData*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::BadParam& _s);
void operator<<=(::CORBA::Any& _a, const TA_Base_Core::BadParam* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::BadParam*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::ProcessDataSeq& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::ProcessDataSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::ProcessDataSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::ProcessDataSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Core::RunParam& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Core::RunParam* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::RunParam*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::RunParam*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Core::RunParamSeq& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Core::RunParamSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Core::RunParamSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Core::RunParamSeq*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_ProcessManagementDataDefinitionsCorbaDef
#endif

#endif  // __ProcessManagementDataDefinitionsCorbaDef_hh__

