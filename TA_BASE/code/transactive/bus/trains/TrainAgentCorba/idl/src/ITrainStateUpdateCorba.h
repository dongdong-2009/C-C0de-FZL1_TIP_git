// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __ITrainStateUpdateCorba_hh__
#define __ITrainStateUpdateCorba_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif



#ifndef __ITrainCommonCorba_hh_EXTERNAL_GUARD__
#define __ITrainCommonCorba_hh_EXTERNAL_GUARD__
#include <ITrainCommonCorba.h>
#endif
#ifndef __ITrainExceptionsCorba_hh_EXTERNAL_GUARD__
#define __ITrainExceptionsCorba_hh_EXTERNAL_GUARD__
#include <ITrainExceptionsCorba.h>
#endif
#ifndef __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <CommonExceptionsCorbaDef.h>
#endif
#ifndef __ITrainCctvCorba_hh_EXTERNAL_GUARD__
#define __ITrainCctvCorba_hh_EXTERNAL_GUARD__
#include <ITrainCctvCorba.h>
#endif
#ifndef __ITrainInformationCorba_hh_EXTERNAL_GUARD__
#define __ITrainInformationCorba_hh_EXTERNAL_GUARD__
#include <ITrainInformationCorba.h>
#endif
#ifndef __ITrainPaCorba_hh_EXTERNAL_GUARD__
#define __ITrainPaCorba_hh_EXTERNAL_GUARD__
#include <ITrainPaCorba.h>
#endif
#ifndef __ITrainPecCorba_hh_EXTERNAL_GUARD__
#define __ITrainPecCorba_hh_EXTERNAL_GUARD__
#include <ITrainPecCorba.h>
#endif
#ifndef __ITrainRadioGroupCorba_hh_EXTERNAL_GUARD__
#define __ITrainRadioGroupCorba_hh_EXTERNAL_GUARD__
#include <ITrainRadioGroupCorba.h>
#endif
#ifndef __ITrainTisCorba_hh_EXTERNAL_GUARD__
#define __ITrainTisCorba_hh_EXTERNAL_GUARD__
#include <ITrainTisCorba.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

#ifndef __TA__Base__Bus_mITrainStateUpdateCorba__
#define __TA__Base__Bus_mITrainStateUpdateCorba__

  class ITrainStateUpdateCorba;
  class _objref_ITrainStateUpdateCorba;
  class _impl_ITrainStateUpdateCorba;
  
  typedef _objref_ITrainStateUpdateCorba* ITrainStateUpdateCorba_ptr;
  typedef ITrainStateUpdateCorba_ptr ITrainStateUpdateCorbaRef;

  class ITrainStateUpdateCorba_Helper {
  public:
    typedef ITrainStateUpdateCorba_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ITrainStateUpdateCorba, ITrainStateUpdateCorba_Helper> ITrainStateUpdateCorba_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ITrainStateUpdateCorba,ITrainStateUpdateCorba_Helper > ITrainStateUpdateCorba_out;

#endif

  // interface ITrainStateUpdateCorba
  class ITrainStateUpdateCorba {
  public:
    // Declarations for this interface type.
    typedef ITrainStateUpdateCorba_ptr _ptr_type;
    typedef ITrainStateUpdateCorba_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct NonDutyTrainTSI {
      typedef _CORBA_ConstrType_Variable_Var<NonDutyTrainTSI> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member trainTsi;

      ::CORBA::ULong trainLocation;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef NonDutyTrainTSI::_var_type NonDutyTrainTSI_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< NonDutyTrainTSI,NonDutyTrainTSI_var > NonDutyTrainTSI_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_NonDutyTrainTSI;

    enum ETrainResource { CoreResource, TrainAlarmResource, TrainCctvResource, TrainTisResource, TrainPaResource, TrainCallResource, TrainPecResource /*, __max_ETrainResource=0xffffffff */ };
    typedef ETrainResource& ETrainResource_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETrainResource;

    struct RadioCallDetails {
      typedef _CORBA_ConstrType_Variable_Var<RadioCallDetails> _var_type;

      
      ::CORBA::ULong consoleId;

      ::CORBA::ULong callId;

      ::CORBA::String_member sessionId;

      ::CORBA::String_member calledTsi;

      ETrainResource resourceType;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioCallDetails::_var_type RadioCallDetails_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioCallDetails,RadioCallDetails_var > RadioCallDetails_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioCallDetails;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioCallDetailsList;

    class RadioCallDetailsList_var;

    class RadioCallDetailsList : public _CORBA_Unbounded_Sequence< RadioCallDetails >  {
    public:
      typedef RadioCallDetailsList_var _var_type;
      inline RadioCallDetailsList() {}
      inline RadioCallDetailsList(const RadioCallDetailsList& _s)
        : _CORBA_Unbounded_Sequence< RadioCallDetails > (_s) {}

      inline RadioCallDetailsList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< RadioCallDetails > (_max) {}
      inline RadioCallDetailsList(_CORBA_ULong _max, _CORBA_ULong _len, RadioCallDetails* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< RadioCallDetails > (_max, _len, _val, _rel) {}

    

      inline RadioCallDetailsList& operator = (const RadioCallDetailsList& _s) {
        _CORBA_Unbounded_Sequence< RadioCallDetails > ::operator=(_s);
        return *this;
      }
    };

    class RadioCallDetailsList_out;

    class RadioCallDetailsList_var {
    public:
      inline RadioCallDetailsList_var() : _pd_seq(0) {}
      inline RadioCallDetailsList_var(RadioCallDetailsList* _s) : _pd_seq(_s) {}
      inline RadioCallDetailsList_var(const RadioCallDetailsList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RadioCallDetailsList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RadioCallDetailsList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RadioCallDetailsList_var& operator = (RadioCallDetailsList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RadioCallDetailsList_var& operator = (const RadioCallDetailsList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RadioCallDetailsList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline RadioCallDetails& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RadioCallDetailsList* operator -> () { return _pd_seq; }
      inline const RadioCallDetailsList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RadioCallDetailsList& () const { return *_pd_seq; }
#else
      inline operator const RadioCallDetailsList& () const { return *_pd_seq; }
      inline operator RadioCallDetailsList& () { return *_pd_seq; }
#endif
        
      inline const RadioCallDetailsList& in() const { return *_pd_seq; }
      inline RadioCallDetailsList&       inout()    { return *_pd_seq; }
      inline RadioCallDetailsList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RadioCallDetailsList* _retn() { RadioCallDetailsList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RadioCallDetailsList_out;
      
    private:
      RadioCallDetailsList* _pd_seq;
    };

    class RadioCallDetailsList_out {
    public:
      inline RadioCallDetailsList_out(RadioCallDetailsList*& _s) : _data(_s) { _data = 0; }
      inline RadioCallDetailsList_out(RadioCallDetailsList_var& _s)
        : _data(_s._pd_seq) { _s = (RadioCallDetailsList*) 0; }
      inline RadioCallDetailsList_out(const RadioCallDetailsList_out& _s) : _data(_s._data) {}
      inline RadioCallDetailsList_out& operator = (const RadioCallDetailsList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RadioCallDetailsList_out& operator = (RadioCallDetailsList* _s) {
        _data = _s;
        return *this;
      }
      inline operator RadioCallDetailsList*&()  { return _data; }
      inline RadioCallDetailsList*& ptr()       { return _data; }
      inline RadioCallDetailsList* operator->() { return _data; }

      inline RadioCallDetails& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RadioCallDetailsList*& _data;

    private:
      RadioCallDetailsList_out();
      RadioCallDetailsList_out& operator=(const RadioCallDetailsList_var&);
    };

    struct SavedTrainSelection {
      typedef _CORBA_ConstrType_Variable_Var<SavedTrainSelection> _var_type;

      
      ::CORBA::String_member name;

      ITrainCommonCorba::TrainList trains;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SavedTrainSelection::_var_type SavedTrainSelection_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SavedTrainSelection,SavedTrainSelection_var > SavedTrainSelection_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SavedTrainSelection;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SavedTrainSelectionSequence;

    class SavedTrainSelectionSequence_var;

    class SavedTrainSelectionSequence : public _CORBA_Unbounded_Sequence< SavedTrainSelection >  {
    public:
      typedef SavedTrainSelectionSequence_var _var_type;
      inline SavedTrainSelectionSequence() {}
      inline SavedTrainSelectionSequence(const SavedTrainSelectionSequence& _s)
        : _CORBA_Unbounded_Sequence< SavedTrainSelection > (_s) {}

      inline SavedTrainSelectionSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SavedTrainSelection > (_max) {}
      inline SavedTrainSelectionSequence(_CORBA_ULong _max, _CORBA_ULong _len, SavedTrainSelection* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SavedTrainSelection > (_max, _len, _val, _rel) {}

    

      inline SavedTrainSelectionSequence& operator = (const SavedTrainSelectionSequence& _s) {
        _CORBA_Unbounded_Sequence< SavedTrainSelection > ::operator=(_s);
        return *this;
      }
    };

    class SavedTrainSelectionSequence_out;

    class SavedTrainSelectionSequence_var {
    public:
      inline SavedTrainSelectionSequence_var() : _pd_seq(0) {}
      inline SavedTrainSelectionSequence_var(SavedTrainSelectionSequence* _s) : _pd_seq(_s) {}
      inline SavedTrainSelectionSequence_var(const SavedTrainSelectionSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SavedTrainSelectionSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SavedTrainSelectionSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SavedTrainSelectionSequence_var& operator = (SavedTrainSelectionSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SavedTrainSelectionSequence_var& operator = (const SavedTrainSelectionSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SavedTrainSelectionSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SavedTrainSelection& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SavedTrainSelectionSequence* operator -> () { return _pd_seq; }
      inline const SavedTrainSelectionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SavedTrainSelectionSequence& () const { return *_pd_seq; }
#else
      inline operator const SavedTrainSelectionSequence& () const { return *_pd_seq; }
      inline operator SavedTrainSelectionSequence& () { return *_pd_seq; }
#endif
        
      inline const SavedTrainSelectionSequence& in() const { return *_pd_seq; }
      inline SavedTrainSelectionSequence&       inout()    { return *_pd_seq; }
      inline SavedTrainSelectionSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SavedTrainSelectionSequence* _retn() { SavedTrainSelectionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SavedTrainSelectionSequence_out;
      
    private:
      SavedTrainSelectionSequence* _pd_seq;
    };

    class SavedTrainSelectionSequence_out {
    public:
      inline SavedTrainSelectionSequence_out(SavedTrainSelectionSequence*& _s) : _data(_s) { _data = 0; }
      inline SavedTrainSelectionSequence_out(SavedTrainSelectionSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SavedTrainSelectionSequence*) 0; }
      inline SavedTrainSelectionSequence_out(const SavedTrainSelectionSequence_out& _s) : _data(_s._data) {}
      inline SavedTrainSelectionSequence_out& operator = (const SavedTrainSelectionSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SavedTrainSelectionSequence_out& operator = (SavedTrainSelectionSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SavedTrainSelectionSequence*&()  { return _data; }
      inline SavedTrainSelectionSequence*& ptr()       { return _data; }
      inline SavedTrainSelectionSequence* operator->() { return _data; }

      inline SavedTrainSelection& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SavedTrainSelectionSequence*& _data;

    private:
      SavedTrainSelectionSequence_out();
      SavedTrainSelectionSequence_out& operator=(const SavedTrainSelectionSequence_var&);
    };

    struct AlarmState {
      typedef _CORBA_ConstrType_Variable_Var<AlarmState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member atcAlarmId;

      ::CORBA::String_member oa1AlarmId;

      ::CORBA::String_member radioModeAlarmId;

      ::CORBA::String_member cctvPreConflictAlarmId;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AlarmState::_var_type AlarmState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AlarmState,AlarmState_var > AlarmState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlarmState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlarmStateList;

    class AlarmStateList_var;

    class AlarmStateList : public _CORBA_Unbounded_Sequence< AlarmState >  {
    public:
      typedef AlarmStateList_var _var_type;
      inline AlarmStateList() {}
      inline AlarmStateList(const AlarmStateList& _s)
        : _CORBA_Unbounded_Sequence< AlarmState > (_s) {}

      inline AlarmStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AlarmState > (_max) {}
      inline AlarmStateList(_CORBA_ULong _max, _CORBA_ULong _len, AlarmState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AlarmState > (_max, _len, _val, _rel) {}

    

      inline AlarmStateList& operator = (const AlarmStateList& _s) {
        _CORBA_Unbounded_Sequence< AlarmState > ::operator=(_s);
        return *this;
      }
    };

    class AlarmStateList_out;

    class AlarmStateList_var {
    public:
      inline AlarmStateList_var() : _pd_seq(0) {}
      inline AlarmStateList_var(AlarmStateList* _s) : _pd_seq(_s) {}
      inline AlarmStateList_var(const AlarmStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new AlarmStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~AlarmStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline AlarmStateList_var& operator = (AlarmStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AlarmStateList_var& operator = (const AlarmStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new AlarmStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline AlarmState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AlarmStateList* operator -> () { return _pd_seq; }
      inline const AlarmStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AlarmStateList& () const { return *_pd_seq; }
#else
      inline operator const AlarmStateList& () const { return *_pd_seq; }
      inline operator AlarmStateList& () { return *_pd_seq; }
#endif
        
      inline const AlarmStateList& in() const { return *_pd_seq; }
      inline AlarmStateList&       inout()    { return *_pd_seq; }
      inline AlarmStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AlarmStateList* _retn() { AlarmStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AlarmStateList_out;
      
    private:
      AlarmStateList* _pd_seq;
    };

    class AlarmStateList_out {
    public:
      inline AlarmStateList_out(AlarmStateList*& _s) : _data(_s) { _data = 0; }
      inline AlarmStateList_out(AlarmStateList_var& _s)
        : _data(_s._pd_seq) { _s = (AlarmStateList*) 0; }
      inline AlarmStateList_out(const AlarmStateList_out& _s) : _data(_s._data) {}
      inline AlarmStateList_out& operator = (const AlarmStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AlarmStateList_out& operator = (AlarmStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator AlarmStateList*&()  { return _data; }
      inline AlarmStateList*& ptr()       { return _data; }
      inline AlarmStateList* operator->() { return _data; }

      inline AlarmState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AlarmStateList*& _data;

    private:
      AlarmStateList_out();
      AlarmStateList_out& operator=(const AlarmStateList_var&);
    };

    enum ETrainCallType { NoCall, TrainCallOcc, OccCallTrain /*, __max_ETrainCallType=0xffffffff */ };
    typedef ETrainCallType& ETrainCallType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETrainCallType;

    struct CallState {
      typedef _CORBA_ConstrType_Variable_Var<CallState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::Boolean incomingCall;

      ::CORBA::Long incomingCallTime;

      ETrainCallType callType;

      ::CORBA::String_member sessionId;

      ::CORBA::ULong consoleId;

      ::CORBA::ULong callId;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef CallState::_var_type CallState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< CallState,CallState_var > CallState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallStateList;

    class CallStateList_var;

    class CallStateList : public _CORBA_Unbounded_Sequence< CallState >  {
    public:
      typedef CallStateList_var _var_type;
      inline CallStateList() {}
      inline CallStateList(const CallStateList& _s)
        : _CORBA_Unbounded_Sequence< CallState > (_s) {}

      inline CallStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< CallState > (_max) {}
      inline CallStateList(_CORBA_ULong _max, _CORBA_ULong _len, CallState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< CallState > (_max, _len, _val, _rel) {}

    

      inline CallStateList& operator = (const CallStateList& _s) {
        _CORBA_Unbounded_Sequence< CallState > ::operator=(_s);
        return *this;
      }
    };

    class CallStateList_out;

    class CallStateList_var {
    public:
      inline CallStateList_var() : _pd_seq(0) {}
      inline CallStateList_var(CallStateList* _s) : _pd_seq(_s) {}
      inline CallStateList_var(const CallStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CallStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CallStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CallStateList_var& operator = (CallStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CallStateList_var& operator = (const CallStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CallStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline CallState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CallStateList* operator -> () { return _pd_seq; }
      inline const CallStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CallStateList& () const { return *_pd_seq; }
#else
      inline operator const CallStateList& () const { return *_pd_seq; }
      inline operator CallStateList& () { return *_pd_seq; }
#endif
        
      inline const CallStateList& in() const { return *_pd_seq; }
      inline CallStateList&       inout()    { return *_pd_seq; }
      inline CallStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CallStateList* _retn() { CallStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CallStateList_out;
      
    private:
      CallStateList* _pd_seq;
    };

    class CallStateList_out {
    public:
      inline CallStateList_out(CallStateList*& _s) : _data(_s) { _data = 0; }
      inline CallStateList_out(CallStateList_var& _s)
        : _data(_s._pd_seq) { _s = (CallStateList*) 0; }
      inline CallStateList_out(const CallStateList_out& _s) : _data(_s._data) {}
      inline CallStateList_out& operator = (const CallStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CallStateList_out& operator = (CallStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator CallStateList*&()  { return _data; }
      inline CallStateList*& ptr()       { return _data; }
      inline CallStateList* operator->() { return _data; }

      inline CallState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CallStateList*& _data;

    private:
      CallStateList_out();
      CallStateList_out& operator=(const CallStateList_var&);
    };

    struct PaState {
      typedef _CORBA_ConstrType_Variable_Var<PaState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member sessionId;

      ITrainPaCorba::AnnouncementId liveAnnouncementId;

      ::CORBA::ULong liveAnnouncemenConsoleId;

      ::CORBA::ULong liveAnnouncementCallId;

      ::CORBA::String_member liveAnnouncementStaticGroup;

      ::CORBA::Octet autoContinueAckCount;

      ::CORBA::Boolean continueRequired;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PaState::_var_type PaState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PaState,PaState_var > PaState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PaState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PaStateList;

    class PaStateList_var;

    class PaStateList : public _CORBA_Unbounded_Sequence< PaState >  {
    public:
      typedef PaStateList_var _var_type;
      inline PaStateList() {}
      inline PaStateList(const PaStateList& _s)
        : _CORBA_Unbounded_Sequence< PaState > (_s) {}

      inline PaStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< PaState > (_max) {}
      inline PaStateList(_CORBA_ULong _max, _CORBA_ULong _len, PaState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< PaState > (_max, _len, _val, _rel) {}

    

      inline PaStateList& operator = (const PaStateList& _s) {
        _CORBA_Unbounded_Sequence< PaState > ::operator=(_s);
        return *this;
      }
    };

    class PaStateList_out;

    class PaStateList_var {
    public:
      inline PaStateList_var() : _pd_seq(0) {}
      inline PaStateList_var(PaStateList* _s) : _pd_seq(_s) {}
      inline PaStateList_var(const PaStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new PaStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~PaStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline PaStateList_var& operator = (PaStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline PaStateList_var& operator = (const PaStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new PaStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline PaState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline PaStateList* operator -> () { return _pd_seq; }
      inline const PaStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator PaStateList& () const { return *_pd_seq; }
#else
      inline operator const PaStateList& () const { return *_pd_seq; }
      inline operator PaStateList& () { return *_pd_seq; }
#endif
        
      inline const PaStateList& in() const { return *_pd_seq; }
      inline PaStateList&       inout()    { return *_pd_seq; }
      inline PaStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline PaStateList* _retn() { PaStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class PaStateList_out;
      
    private:
      PaStateList* _pd_seq;
    };

    class PaStateList_out {
    public:
      inline PaStateList_out(PaStateList*& _s) : _data(_s) { _data = 0; }
      inline PaStateList_out(PaStateList_var& _s)
        : _data(_s._pd_seq) { _s = (PaStateList*) 0; }
      inline PaStateList_out(const PaStateList_out& _s) : _data(_s._data) {}
      inline PaStateList_out& operator = (const PaStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline PaStateList_out& operator = (PaStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator PaStateList*&()  { return _data; }
      inline PaStateList*& ptr()       { return _data; }
      inline PaStateList* operator->() { return _data; }

      inline PaState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      PaStateList*& _data;

    private:
      PaStateList_out();
      PaStateList_out& operator=(const PaStateList_var&);
    };

    struct PecState {
      typedef _CORBA_ConstrType_Variable_Var<PecState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member sessionId;

      ::CORBA::ULong consoleId;

      ::CORBA::ULong callId;

      ::CORBA::Octet autoContinueCounter;

      ITrainPecCorba::PecPointCollection activePecPoints;

      ::CORBA::Boolean continueRequired;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PecState::_var_type PecState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PecState,PecState_var > PecState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PecState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PecStateList;

    class PecStateList_var;

    class PecStateList : public _CORBA_Unbounded_Sequence< PecState >  {
    public:
      typedef PecStateList_var _var_type;
      inline PecStateList() {}
      inline PecStateList(const PecStateList& _s)
        : _CORBA_Unbounded_Sequence< PecState > (_s) {}

      inline PecStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< PecState > (_max) {}
      inline PecStateList(_CORBA_ULong _max, _CORBA_ULong _len, PecState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< PecState > (_max, _len, _val, _rel) {}

    

      inline PecStateList& operator = (const PecStateList& _s) {
        _CORBA_Unbounded_Sequence< PecState > ::operator=(_s);
        return *this;
      }
    };

    class PecStateList_out;

    class PecStateList_var {
    public:
      inline PecStateList_var() : _pd_seq(0) {}
      inline PecStateList_var(PecStateList* _s) : _pd_seq(_s) {}
      inline PecStateList_var(const PecStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new PecStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~PecStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline PecStateList_var& operator = (PecStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline PecStateList_var& operator = (const PecStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new PecStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline PecState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline PecStateList* operator -> () { return _pd_seq; }
      inline const PecStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator PecStateList& () const { return *_pd_seq; }
#else
      inline operator const PecStateList& () const { return *_pd_seq; }
      inline operator PecStateList& () { return *_pd_seq; }
#endif
        
      inline const PecStateList& in() const { return *_pd_seq; }
      inline PecStateList&       inout()    { return *_pd_seq; }
      inline PecStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline PecStateList* _retn() { PecStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class PecStateList_out;
      
    private:
      PecStateList* _pd_seq;
    };

    class PecStateList_out {
    public:
      inline PecStateList_out(PecStateList*& _s) : _data(_s) { _data = 0; }
      inline PecStateList_out(PecStateList_var& _s)
        : _data(_s._pd_seq) { _s = (PecStateList*) 0; }
      inline PecStateList_out(const PecStateList_out& _s) : _data(_s._data) {}
      inline PecStateList_out& operator = (const PecStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline PecStateList_out& operator = (PecStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator PecStateList*&()  { return _data; }
      inline PecStateList*& ptr()       { return _data; }
      inline PecStateList* operator->() { return _data; }

      inline PecState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      PecStateList*& _data;

    private:
      PecStateList_out();
      PecStateList_out& operator=(const PecStateList_var&);
    };

    enum ETtisDownloadType { TtisNone, TtisLibrary, TtisSchedule /*, __max_ETtisDownloadType=0xffffffff */ };
    typedef ETtisDownloadType& ETtisDownloadType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisDownloadType;

    struct TtdFrame {
      typedef _CORBA_ConstrType_Variable_Var<TtdFrame> _var_type;

      
      typedef _CORBA_Unbounded_Sequence_Octet _data_seq;
      _data_seq data;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TtdFrame::_var_type TtdFrame_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TtdFrame,TtdFrame_var > TtdFrame_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtdFrame;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtdFrameList;

    class TtdFrameList_var;

    class TtdFrameList : public _CORBA_Unbounded_Sequence< TtdFrame >  {
    public:
      typedef TtdFrameList_var _var_type;
      inline TtdFrameList() {}
      inline TtdFrameList(const TtdFrameList& _s)
        : _CORBA_Unbounded_Sequence< TtdFrame > (_s) {}

      inline TtdFrameList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TtdFrame > (_max) {}
      inline TtdFrameList(_CORBA_ULong _max, _CORBA_ULong _len, TtdFrame* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TtdFrame > (_max, _len, _val, _rel) {}

    

      inline TtdFrameList& operator = (const TtdFrameList& _s) {
        _CORBA_Unbounded_Sequence< TtdFrame > ::operator=(_s);
        return *this;
      }
    };

    class TtdFrameList_out;

    class TtdFrameList_var {
    public:
      inline TtdFrameList_var() : _pd_seq(0) {}
      inline TtdFrameList_var(TtdFrameList* _s) : _pd_seq(_s) {}
      inline TtdFrameList_var(const TtdFrameList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TtdFrameList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TtdFrameList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TtdFrameList_var& operator = (TtdFrameList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TtdFrameList_var& operator = (const TtdFrameList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TtdFrameList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TtdFrame& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TtdFrameList* operator -> () { return _pd_seq; }
      inline const TtdFrameList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TtdFrameList& () const { return *_pd_seq; }
#else
      inline operator const TtdFrameList& () const { return *_pd_seq; }
      inline operator TtdFrameList& () { return *_pd_seq; }
#endif
        
      inline const TtdFrameList& in() const { return *_pd_seq; }
      inline TtdFrameList&       inout()    { return *_pd_seq; }
      inline TtdFrameList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TtdFrameList* _retn() { TtdFrameList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TtdFrameList_out;
      
    private:
      TtdFrameList* _pd_seq;
    };

    class TtdFrameList_out {
    public:
      inline TtdFrameList_out(TtdFrameList*& _s) : _data(_s) { _data = 0; }
      inline TtdFrameList_out(TtdFrameList_var& _s)
        : _data(_s._pd_seq) { _s = (TtdFrameList*) 0; }
      inline TtdFrameList_out(const TtdFrameList_out& _s) : _data(_s._data) {}
      inline TtdFrameList_out& operator = (const TtdFrameList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TtdFrameList_out& operator = (TtdFrameList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TtdFrameList*&()  { return _data; }
      inline TtdFrameList*& ptr()       { return _data; }
      inline TtdFrameList* operator->() { return _data; }

      inline TtdFrame& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TtdFrameList*& _data;

    private:
      TtdFrameList_out();
      TtdFrameList_out& operator=(const TtdFrameList_var&);
    };

    struct TisState {
      typedef _CORBA_ConstrType_Variable_Var<TisState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ETtisDownloadType downloadType;

      TtdFrameList currentDownload;

      ::CORBA::UShort currentDownloadVersion;

      ::CORBA::String_member sessionId;

      ::CORBA::String_member transferTsi;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TisState::_var_type TisState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TisState,TisState_var > TisState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisStateList;

    class TisStateList_var;

    class TisStateList : public _CORBA_Unbounded_Sequence< TisState >  {
    public:
      typedef TisStateList_var _var_type;
      inline TisStateList() {}
      inline TisStateList(const TisStateList& _s)
        : _CORBA_Unbounded_Sequence< TisState > (_s) {}

      inline TisStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TisState > (_max) {}
      inline TisStateList(_CORBA_ULong _max, _CORBA_ULong _len, TisState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TisState > (_max, _len, _val, _rel) {}

    

      inline TisStateList& operator = (const TisStateList& _s) {
        _CORBA_Unbounded_Sequence< TisState > ::operator=(_s);
        return *this;
      }
    };

    class TisStateList_out;

    class TisStateList_var {
    public:
      inline TisStateList_var() : _pd_seq(0) {}
      inline TisStateList_var(TisStateList* _s) : _pd_seq(_s) {}
      inline TisStateList_var(const TisStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TisStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TisStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TisStateList_var& operator = (TisStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TisStateList_var& operator = (const TisStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TisStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TisState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TisStateList* operator -> () { return _pd_seq; }
      inline const TisStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TisStateList& () const { return *_pd_seq; }
#else
      inline operator const TisStateList& () const { return *_pd_seq; }
      inline operator TisStateList& () { return *_pd_seq; }
#endif
        
      inline const TisStateList& in() const { return *_pd_seq; }
      inline TisStateList&       inout()    { return *_pd_seq; }
      inline TisStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TisStateList* _retn() { TisStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TisStateList_out;
      
    private:
      TisStateList* _pd_seq;
    };

    class TisStateList_out {
    public:
      inline TisStateList_out(TisStateList*& _s) : _data(_s) { _data = 0; }
      inline TisStateList_out(TisStateList_var& _s)
        : _data(_s._pd_seq) { _s = (TisStateList*) 0; }
      inline TisStateList_out(const TisStateList_out& _s) : _data(_s._data) {}
      inline TisStateList_out& operator = (const TisStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TisStateList_out& operator = (TisStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TisStateList*&()  { return _data; }
      inline TisStateList*& ptr()       { return _data; }
      inline TisStateList* operator->() { return _data; }

      inline TisState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TisStateList*& _data;

    private:
      TisStateList_out();
      TisStateList_out& operator=(const TisStateList_var&);
    };

    struct FullLocalState {
      typedef _CORBA_ConstrType_Variable_Var<FullLocalState> _var_type;

      
      ITrainInformationCorba::AgentOperationMode operationMode;

      RadioCallDetailsList ongoingCalls;

      SavedTrainSelectionSequence selectionLists;

      AlarmStateList alarmStates;

      CallStateList callStates;

      PaStateList paStates;

      PecStateList pecStates;

      TisStateList tisStates;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef FullLocalState::_var_type FullLocalState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< FullLocalState,FullLocalState_var > FullLocalState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FullLocalState;

    struct CctvState {
      typedef _CORBA_ConstrType_Fix_Var<CctvState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ITrainCctvCorba::ECctvSwitchMode cctvSwitchMode;

      ::CORBA::Octet item1;

      ::CORBA::Octet item2;

      ::CORBA::Octet item3;

      ::CORBA::Octet item4;

      ITrainCommonCorba::TrainId preConflictTrain;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef CctvState::_var_type CctvState_var;

    typedef CctvState& CctvState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CctvState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CctvStateList;

    class CctvStateList_var;

    class CctvStateList : public _CORBA_Unbounded_Sequence< CctvState >  {
    public:
      typedef CctvStateList_var _var_type;
      inline CctvStateList() {}
      inline CctvStateList(const CctvStateList& _s)
        : _CORBA_Unbounded_Sequence< CctvState > (_s) {}

      inline CctvStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< CctvState > (_max) {}
      inline CctvStateList(_CORBA_ULong _max, _CORBA_ULong _len, CctvState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< CctvState > (_max, _len, _val, _rel) {}

    

      inline CctvStateList& operator = (const CctvStateList& _s) {
        _CORBA_Unbounded_Sequence< CctvState > ::operator=(_s);
        return *this;
      }
    };

    class CctvStateList_out;

    class CctvStateList_var {
    public:
      inline CctvStateList_var() : _pd_seq(0) {}
      inline CctvStateList_var(CctvStateList* _s) : _pd_seq(_s) {}
      inline CctvStateList_var(const CctvStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CctvStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CctvStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CctvStateList_var& operator = (CctvStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CctvStateList_var& operator = (const CctvStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CctvStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline CctvState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CctvStateList* operator -> () { return _pd_seq; }
      inline const CctvStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CctvStateList& () const { return *_pd_seq; }
#else
      inline operator const CctvStateList& () const { return *_pd_seq; }
      inline operator CctvStateList& () { return *_pd_seq; }
#endif
        
      inline const CctvStateList& in() const { return *_pd_seq; }
      inline CctvStateList&       inout()    { return *_pd_seq; }
      inline CctvStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CctvStateList* _retn() { CctvStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CctvStateList_out;
      
    private:
      CctvStateList* _pd_seq;
    };

    class CctvStateList_out {
    public:
      inline CctvStateList_out(CctvStateList*& _s) : _data(_s) { _data = 0; }
      inline CctvStateList_out(CctvStateList_var& _s)
        : _data(_s._pd_seq) { _s = (CctvStateList*) 0; }
      inline CctvStateList_out(const CctvStateList_out& _s) : _data(_s._data) {}
      inline CctvStateList_out& operator = (const CctvStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CctvStateList_out& operator = (CctvStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator CctvStateList*&()  { return _data; }
      inline CctvStateList*& ptr()       { return _data; }
      inline CctvStateList* operator->() { return _data; }

      inline CctvState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CctvStateList*& _data;

    private:
      CctvStateList_out();
      CctvStateList_out& operator=(const CctvStateList_var&);
    };

    enum ETimsOrigin { MpuBackup, MpuMain /*, __max_ETimsOrigin=0xffffffff */ };
    typedef ETimsOrigin& ETimsOrigin_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETimsOrigin;

    struct CommsState {
      typedef _CORBA_ConstrType_Variable_Var<CommsState> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member primaryMpuTsi;

      ::CORBA::String_member secondaryMpuTsi;

      ETimsOrigin activeMpu;

      ::CORBA::UShort paLibraryVersion;

      ::CORBA::UShort ttisLibraryVersion;

      ::CORBA::UShort ttisScheduleVersion;

      ::CORBA::Boolean oa1Valid;

      ::CORBA::Boolean atcValid;

      ::CORBA::ULong communicatingLocation;

      ::CORBA::Long timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef CommsState::_var_type CommsState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< CommsState,CommsState_var > CommsState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CommsState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CommsStateList;

    class CommsStateList_var;

    class CommsStateList : public _CORBA_Unbounded_Sequence< CommsState >  {
    public:
      typedef CommsStateList_var _var_type;
      inline CommsStateList() {}
      inline CommsStateList(const CommsStateList& _s)
        : _CORBA_Unbounded_Sequence< CommsState > (_s) {}

      inline CommsStateList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< CommsState > (_max) {}
      inline CommsStateList(_CORBA_ULong _max, _CORBA_ULong _len, CommsState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< CommsState > (_max, _len, _val, _rel) {}

    

      inline CommsStateList& operator = (const CommsStateList& _s) {
        _CORBA_Unbounded_Sequence< CommsState > ::operator=(_s);
        return *this;
      }
    };

    class CommsStateList_out;

    class CommsStateList_var {
    public:
      inline CommsStateList_var() : _pd_seq(0) {}
      inline CommsStateList_var(CommsStateList* _s) : _pd_seq(_s) {}
      inline CommsStateList_var(const CommsStateList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CommsStateList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CommsStateList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CommsStateList_var& operator = (CommsStateList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CommsStateList_var& operator = (const CommsStateList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CommsStateList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline CommsState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CommsStateList* operator -> () { return _pd_seq; }
      inline const CommsStateList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CommsStateList& () const { return *_pd_seq; }
#else
      inline operator const CommsStateList& () const { return *_pd_seq; }
      inline operator CommsStateList& () { return *_pd_seq; }
#endif
        
      inline const CommsStateList& in() const { return *_pd_seq; }
      inline CommsStateList&       inout()    { return *_pd_seq; }
      inline CommsStateList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CommsStateList* _retn() { CommsStateList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CommsStateList_out;
      
    private:
      CommsStateList* _pd_seq;
    };

    class CommsStateList_out {
    public:
      inline CommsStateList_out(CommsStateList*& _s) : _data(_s) { _data = 0; }
      inline CommsStateList_out(CommsStateList_var& _s)
        : _data(_s._pd_seq) { _s = (CommsStateList*) 0; }
      inline CommsStateList_out(const CommsStateList_out& _s) : _data(_s._data) {}
      inline CommsStateList_out& operator = (const CommsStateList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CommsStateList_out& operator = (CommsStateList* _s) {
        _data = _s;
        return *this;
      }
      inline operator CommsStateList*&()  { return _data; }
      inline CommsStateList*& ptr()       { return _data; }
      inline CommsStateList* operator->() { return _data; }

      inline CommsState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CommsStateList*& _data;

    private:
      CommsStateList_out();
      CommsStateList_out& operator=(const CommsStateList_var&);
    };

    struct FullGlobalState {
      typedef _CORBA_ConstrType_Variable_Var<FullGlobalState> _var_type;

      
      CommsStateList commsStates;

      CctvStateList cctvStates;

      ITrainRadioGroupCorba::TrainRadioGroupList radioGroupList;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef FullGlobalState::_var_type FullGlobalState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< FullGlobalState,FullGlobalState_var > FullGlobalState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FullGlobalState;

  
  };

  class _objref_ITrainStateUpdateCorba :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ITrainStateUpdateCorba::FullLocalState* getLocalState();
    ITrainStateUpdateCorba::FullGlobalState* getGlobalState();

    inline _objref_ITrainStateUpdateCorba()  { _PR_setobj(0); }  // nil
    _objref_ITrainStateUpdateCorba(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ITrainStateUpdateCorba();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ITrainStateUpdateCorba(const _objref_ITrainStateUpdateCorba&);
    _objref_ITrainStateUpdateCorba& operator = (const _objref_ITrainStateUpdateCorba&);
    // not implemented

    friend class ITrainStateUpdateCorba;
  };

  class _pof_ITrainStateUpdateCorba : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ITrainStateUpdateCorba() : _OMNI_NS(proxyObjectFactory)(ITrainStateUpdateCorba::_PD_repoId) {}
    virtual ~_pof_ITrainStateUpdateCorba();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ITrainStateUpdateCorba :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ITrainStateUpdateCorba();

    virtual ITrainStateUpdateCorba::FullLocalState* getLocalState() = 0;
    virtual ITrainStateUpdateCorba::FullGlobalState* getGlobalState() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ITrainStateUpdateCorba;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  class ITrainStateUpdateCorba :
    public virtual TA_Base_Bus::_impl_ITrainStateUpdateCorba,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ITrainStateUpdateCorba();

    inline ::TA_Base_Bus::ITrainStateUpdateCorba_ptr _this() {
      return (::TA_Base_Bus::ITrainStateUpdateCorba_ptr) _do_this(::TA_Base_Bus::ITrainStateUpdateCorba::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::NonDutyTrainTSI& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::NonDutyTrainTSI* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::NonDutyTrainTSI*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::NonDutyTrainTSI*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainStateUpdateCorba::ETrainResource _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainStateUpdateCorba::ETrainResource& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainStateUpdateCorba::TrainPecResource) {
    _e = (TA_Base_Bus::ITrainStateUpdateCorba::ETrainResource) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETrainResource _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETrainResource& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetails& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetails* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetails*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetails*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetailsList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetailsList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetailsList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::RadioCallDetailsList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelection& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelection* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelection*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelection*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelectionSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelectionSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelectionSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::SavedTrainSelectionSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::AlarmState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::AlarmState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::AlarmState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::AlarmState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::AlarmStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::AlarmStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::AlarmStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::AlarmStateList*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainStateUpdateCorba::ETrainCallType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainStateUpdateCorba::ETrainCallType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainStateUpdateCorba::OccCallTrain) {
    _e = (TA_Base_Bus::ITrainStateUpdateCorba::ETrainCallType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETrainCallType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETrainCallType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CallState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CallState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CallState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CallState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CallStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CallStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CallStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CallStateList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PaState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PaState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PaState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PaState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PaStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PaStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PaStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PaStateList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PecState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PecState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PecState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PecState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PecStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PecStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::PecStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::PecStateList*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainStateUpdateCorba::ETtisDownloadType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainStateUpdateCorba::ETtisDownloadType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainStateUpdateCorba::TtisSchedule) {
    _e = (TA_Base_Bus::ITrainStateUpdateCorba::ETtisDownloadType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETtisDownloadType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETtisDownloadType& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TtdFrame& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TtdFrame* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TtdFrame*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TtdFrame*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TtdFrameList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TtdFrameList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TtdFrameList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TtdFrameList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TisState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TisState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TisState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TisState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TisStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TisStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::TisStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::TisStateList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::FullLocalState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::FullLocalState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::FullLocalState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::FullLocalState*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CctvState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CctvState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CctvState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CctvState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CctvStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CctvStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CctvStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CctvStateList*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainStateUpdateCorba::ETimsOrigin _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainStateUpdateCorba::ETimsOrigin& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainStateUpdateCorba::MpuMain) {
    _e = (TA_Base_Bus::ITrainStateUpdateCorba::ETimsOrigin) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETimsOrigin _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::ETimsOrigin& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CommsState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CommsState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CommsState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CommsState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CommsStateList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CommsStateList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::CommsStateList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::CommsStateList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::FullGlobalState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::FullGlobalState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba::FullGlobalState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainStateUpdateCorba::FullGlobalState*& _sp);

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba_ptr _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainStateUpdateCorba_ptr& _s);



inline void
TA_Base_Bus::ITrainStateUpdateCorba::_marshalObjRef(::TA_Base_Bus::ITrainStateUpdateCorba_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainStateUpdateCorba
#endif

#endif  // __ITrainStateUpdateCorba_hh__

