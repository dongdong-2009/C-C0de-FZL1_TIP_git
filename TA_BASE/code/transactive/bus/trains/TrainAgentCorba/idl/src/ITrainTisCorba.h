// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __ITrainTisCorba_hh__
#define __ITrainTisCorba_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif



#ifndef __ITrainCommonCorba_hh_EXTERNAL_GUARD__
#define __ITrainCommonCorba_hh_EXTERNAL_GUARD__
#include <ITrainCommonCorba.h>
#endif
#ifndef __ITrainExceptionsCorba_hh_EXTERNAL_GUARD__
#define __ITrainExceptionsCorba_hh_EXTERNAL_GUARD__
#include <ITrainExceptionsCorba.h>
#endif
#ifndef __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <CommonExceptionsCorbaDef.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

#ifndef __TA__Base__Bus_mITrainTisCorba__
#define __TA__Base__Bus_mITrainTisCorba__

  class ITrainTisCorba;
  class _objref_ITrainTisCorba;
  class _impl_ITrainTisCorba;
  
  typedef _objref_ITrainTisCorba* ITrainTisCorba_ptr;
  typedef ITrainTisCorba_ptr ITrainTisCorbaRef;

  class ITrainTisCorba_Helper {
  public:
    typedef ITrainTisCorba_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ITrainTisCorba, ITrainTisCorba_Helper> ITrainTisCorba_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ITrainTisCorba,ITrainTisCorba_Helper > ITrainTisCorba_out;

#endif

  // interface ITrainTisCorba
  class ITrainTisCorba {
  public:
    // Declarations for this interface type.
    typedef ITrainTisCorba_ptr _ptr_type;
    typedef ITrainTisCorba_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct TisLibraryVersionUpdate {
      typedef _CORBA_ConstrType_Fix_Var<TisLibraryVersionUpdate> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::UShort libraryVersion;

      ::CORBA::UShort scheduleVersion;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TisLibraryVersionUpdate::_var_type TisLibraryVersionUpdate_var;

    typedef TisLibraryVersionUpdate& TisLibraryVersionUpdate_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisLibraryVersionUpdate;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisLibraryVersionList;

    class TisLibraryVersionList_var;

    class TisLibraryVersionList : public _CORBA_Unbounded_Sequence< TisLibraryVersionUpdate >  {
    public:
      typedef TisLibraryVersionList_var _var_type;
      inline TisLibraryVersionList() {}
      inline TisLibraryVersionList(const TisLibraryVersionList& _s)
        : _CORBA_Unbounded_Sequence< TisLibraryVersionUpdate > (_s) {}

      inline TisLibraryVersionList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TisLibraryVersionUpdate > (_max) {}
      inline TisLibraryVersionList(_CORBA_ULong _max, _CORBA_ULong _len, TisLibraryVersionUpdate* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TisLibraryVersionUpdate > (_max, _len, _val, _rel) {}

    

      inline TisLibraryVersionList& operator = (const TisLibraryVersionList& _s) {
        _CORBA_Unbounded_Sequence< TisLibraryVersionUpdate > ::operator=(_s);
        return *this;
      }
    };

    class TisLibraryVersionList_out;

    class TisLibraryVersionList_var {
    public:
      inline TisLibraryVersionList_var() : _pd_seq(0) {}
      inline TisLibraryVersionList_var(TisLibraryVersionList* _s) : _pd_seq(_s) {}
      inline TisLibraryVersionList_var(const TisLibraryVersionList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TisLibraryVersionList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TisLibraryVersionList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TisLibraryVersionList_var& operator = (TisLibraryVersionList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TisLibraryVersionList_var& operator = (const TisLibraryVersionList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TisLibraryVersionList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TisLibraryVersionUpdate& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TisLibraryVersionList* operator -> () { return _pd_seq; }
      inline const TisLibraryVersionList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TisLibraryVersionList& () const { return *_pd_seq; }
#else
      inline operator const TisLibraryVersionList& () const { return *_pd_seq; }
      inline operator TisLibraryVersionList& () { return *_pd_seq; }
#endif
        
      inline const TisLibraryVersionList& in() const { return *_pd_seq; }
      inline TisLibraryVersionList&       inout()    { return *_pd_seq; }
      inline TisLibraryVersionList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TisLibraryVersionList* _retn() { TisLibraryVersionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TisLibraryVersionList_out;
      
    private:
      TisLibraryVersionList* _pd_seq;
    };

    class TisLibraryVersionList_out {
    public:
      inline TisLibraryVersionList_out(TisLibraryVersionList*& _s) : _data(_s) { _data = 0; }
      inline TisLibraryVersionList_out(TisLibraryVersionList_var& _s)
        : _data(_s._pd_seq) { _s = (TisLibraryVersionList*) 0; }
      inline TisLibraryVersionList_out(const TisLibraryVersionList_out& _s) : _data(_s._data) {}
      inline TisLibraryVersionList_out& operator = (const TisLibraryVersionList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TisLibraryVersionList_out& operator = (TisLibraryVersionList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TisLibraryVersionList*&()  { return _data; }
      inline TisLibraryVersionList*& ptr()       { return _data; }
      inline TisLibraryVersionList* operator->() { return _data; }

      inline TisLibraryVersionUpdate& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TisLibraryVersionList*& _data;

    private:
      TisLibraryVersionList_out();
      TisLibraryVersionList_out& operator=(const TisLibraryVersionList_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LibraryDataType;

    class LibraryDataType_var;

    class LibraryDataType : public _CORBA_Unbounded_Sequence_Octet {
    public:
      typedef LibraryDataType_var _var_type;
      inline LibraryDataType() {}
      inline LibraryDataType(const LibraryDataType& _s)
        : _CORBA_Unbounded_Sequence_Octet(_s) {}

      inline LibraryDataType(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Octet(_max) {}
      inline LibraryDataType(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

    

      inline LibraryDataType& operator = (const LibraryDataType& _s) {
        _CORBA_Unbounded_Sequence_Octet::operator=(_s);
        return *this;
      }
    };

    class LibraryDataType_out;

    class LibraryDataType_var {
    public:
      inline LibraryDataType_var() : _pd_seq(0) {}
      inline LibraryDataType_var(LibraryDataType* _s) : _pd_seq(_s) {}
      inline LibraryDataType_var(const LibraryDataType_var& _s) {
        if( _s._pd_seq )  _pd_seq = new LibraryDataType(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~LibraryDataType_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline LibraryDataType_var& operator = (LibraryDataType* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline LibraryDataType_var& operator = (const LibraryDataType_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new LibraryDataType;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline LibraryDataType* operator -> () { return _pd_seq; }
      inline const LibraryDataType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator LibraryDataType& () const { return *_pd_seq; }
#else
      inline operator const LibraryDataType& () const { return *_pd_seq; }
      inline operator LibraryDataType& () { return *_pd_seq; }
#endif
        
      inline const LibraryDataType& in() const { return *_pd_seq; }
      inline LibraryDataType&       inout()    { return *_pd_seq; }
      inline LibraryDataType*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline LibraryDataType* _retn() { LibraryDataType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class LibraryDataType_out;
      
    private:
      LibraryDataType* _pd_seq;
    };

    class LibraryDataType_out {
    public:
      inline LibraryDataType_out(LibraryDataType*& _s) : _data(_s) { _data = 0; }
      inline LibraryDataType_out(LibraryDataType_var& _s)
        : _data(_s._pd_seq) { _s = (LibraryDataType*) 0; }
      inline LibraryDataType_out(const LibraryDataType_out& _s) : _data(_s._data) {}
      inline LibraryDataType_out& operator = (const LibraryDataType_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline LibraryDataType_out& operator = (LibraryDataType* _s) {
        _data = _s;
        return *this;
      }
      inline operator LibraryDataType*&()  { return _data; }
      inline LibraryDataType*& ptr()       { return _data; }
      inline LibraryDataType* operator->() { return _data; }

      inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      LibraryDataType*& _data;

    private:
      LibraryDataType_out();
      LibraryDataType_out& operator=(const LibraryDataType_var&);
    };

    enum ETisUpdateType { LibraryDownloadStart, LibraryDownloadComplete, LibraryUpgradeResult, ScheduleDownloadStart, ScheduleDownloadComplete, ScheduleUpgradeResult /*, __max_ETisUpdateType=0xffffffff */ };
    typedef ETisUpdateType& ETisUpdateType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETisUpdateType;

    enum ETtisCommandResult { TtisSuccess, TtisInUse, TtisReset, TtisFailed, TtisDifferentVersion, BadCommandBadChecksum, BadCommandUnknownCommand, BadCommandBadParameter, BadCommandUnexpectedCommand, InvalidTrainError, TransmissionFailureError, TransactionTimeoutError, TransactionCancelledError, MpuChangeoverError /*, __max_ETtisCommandResult=0xffffffff */ };
    typedef ETtisCommandResult& ETtisCommandResult_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisCommandResult;

    enum EDownloadResult { Success, TransferFailed, TimsFailed, TimedOut, MpuChangeover /*, __max_EDownloadResult=0xffffffff */ };
    typedef EDownloadResult& EDownloadResult_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EDownloadResult;

    struct TisLibraryUpdate {
      typedef _CORBA_ConstrType_Fix_Var<TisLibraryUpdate> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ETisUpdateType updateType;

      ETtisCommandResult commandStatus;

      EDownloadResult downloadResult;

      ::CORBA::UShort version;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TisLibraryUpdate::_var_type TisLibraryUpdate_var;

    typedef TisLibraryUpdate& TisLibraryUpdate_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisLibraryUpdate;

    enum ETtisOriginalCommand { TtisFreeTextCommand, TtisPredefinedCommand, TtisResetCommand /*, __max_ETtisOriginalCommand=0xffffffff */ };
    typedef ETtisOriginalCommand& ETtisOriginalCommand_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisOriginalCommand;

    enum ETtisFontSize { TtisFontSmall, TtisFontLarge /*, __max_ETtisFontSize=0xffffffff */ };
    typedef ETtisFontSize& ETtisFontSize_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisFontSize;

    enum ETtisJustification { TtisJustificationLeft, TtisJustificationCentre, TtisJustificationRight /*, __max_ETtisJustification=0xffffffff */ };
    typedef ETtisJustification& ETtisJustification_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisJustification;

    enum ETtisIntensity { TtisIntensityNormal, TtisIntensityHigh /*, __max_ETtisIntensity=0xffffffff */ };
    typedef ETtisIntensity& ETtisIntensity_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisIntensity;

    enum ETtisDisplayMode { TtisDisplayModeScrollLeft, TtisDisplayModeScrollRight, TtisDisplayModeScrollUp, TtisDisplayModeScrollDown, TtisDisplayModeInstantOn, TtisDisplayModeBlinking, TtisDisplayModeWiping, TtisDisplayModeLikeSnow /*, __max_ETtisDisplayMode=0xffffffff */ };
    typedef ETtisDisplayMode& ETtisDisplayMode_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisDisplayMode;

    enum ETtisPriority { ETtisPriorityOne, ETtisPriorityTwo, ETtisPriorityThree, ETtisPriorityFour, ETtisPriorityFive, ETtisPrioritySix, ETtisPrioritySeven, ETtisPriorityEight /*, __max_ETtisPriority=0xffffffff */ };
    typedef ETtisPriority& ETtisPriority_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisPriority;

    enum ETtisResetMessageType { TtisResetAll, TtisResetEmergency, TtisResetNormal, TtisResetPriority6 /*, __max_ETtisResetMessageType=0xffffffff */ };
    typedef ETtisResetMessageType& ETtisResetMessageType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisResetMessageType;

    enum ETtisPid { TtisPidAllTrain, TtisPidCar1, TtisPidCar2, TtisPidCar3, TtisPidCar1Pid1, TtisPidCar1Pid2, TtisPidCar1Pid3, TtisPidCar1Pid4, TtisPidCar2Pid1, TtisPidCar2Pid2, TtisPidCar2Pid3, TtisPidCar2Pid4, TtisPidCar3Pid1, TtisPidCar3Pid2, TtisPidCar3Pid3, TtisPidCar3Pid4 /*, __max_ETtisPid=0xffffffff */ };
    typedef ETtisPid& ETtisPid_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ETtisPid;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtisPidList;

    // Need to declare <<= for elem type, as GCC expands templates early
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
     friend inline void operator >>= (ETtisPid, cdrStream&);
     friend inline void operator <<= (ETtisPid&, cdrStream&);
#endif

    class TtisPidList_var;

    class TtisPidList : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ETtisPid, 4, 4 >  {
    public:
      typedef TtisPidList_var _var_type;
      inline TtisPidList() {}
      inline TtisPidList(const TtisPidList& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ETtisPid, 4, 4 > (_s) {}

      inline TtisPidList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ETtisPid, 4, 4 > (_max) {}
      inline TtisPidList(_CORBA_ULong _max, _CORBA_ULong _len, ETtisPid* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ETtisPid, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline TtisPidList& operator = (const TtisPidList& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ETtisPid, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class TtisPidList_out;

    class TtisPidList_var {
    public:
      inline TtisPidList_var() : _pd_seq(0) {}
      inline TtisPidList_var(TtisPidList* _s) : _pd_seq(_s) {}
      inline TtisPidList_var(const TtisPidList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TtisPidList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TtisPidList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TtisPidList_var& operator = (TtisPidList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TtisPidList_var& operator = (const TtisPidList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TtisPidList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ETtisPid& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TtisPidList* operator -> () { return _pd_seq; }
      inline const TtisPidList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TtisPidList& () const { return *_pd_seq; }
#else
      inline operator const TtisPidList& () const { return *_pd_seq; }
      inline operator TtisPidList& () { return *_pd_seq; }
#endif
        
      inline const TtisPidList& in() const { return *_pd_seq; }
      inline TtisPidList&       inout()    { return *_pd_seq; }
      inline TtisPidList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TtisPidList* _retn() { TtisPidList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TtisPidList_out;
      
    private:
      TtisPidList* _pd_seq;
    };

    class TtisPidList_out {
    public:
      inline TtisPidList_out(TtisPidList*& _s) : _data(_s) { _data = 0; }
      inline TtisPidList_out(TtisPidList_var& _s)
        : _data(_s._pd_seq) { _s = (TtisPidList*) 0; }
      inline TtisPidList_out(const TtisPidList_out& _s) : _data(_s._data) {}
      inline TtisPidList_out& operator = (const TtisPidList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TtisPidList_out& operator = (TtisPidList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TtisPidList*&()  { return _data; }
      inline TtisPidList*& ptr()       { return _data; }
      inline TtisPidList* operator->() { return _data; }

      inline ETtisPid& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TtisPidList*& _data;

    private:
      TtisPidList_out();
      TtisPidList_out& operator=(const TtisPidList_var&);
    };

    struct TimeInterval {
      typedef _CORBA_ConstrType_Fix_Var<TimeInterval> _var_type;

      
      ::CORBA::Octet startHour;

      ::CORBA::Octet startMin;

      ::CORBA::Octet stopHour;

      ::CORBA::Octet stopMin;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TimeInterval::_var_type TimeInterval_var;

    typedef TimeInterval& TimeInterval_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TimeInterval;

    struct TtisFreeTextDisplayParameters {
      typedef _CORBA_ConstrType_Variable_Var<TtisFreeTextDisplayParameters> _var_type;

      
      TtisPidList pidList;

      ETtisFontSize fontSize;

      ETtisJustification justification;

      ETtisIntensity intensity;

      ETtisDisplayMode displayMode;

      ETtisPriority priority;

      TimeInterval displayPeriod;

      ::CORBA::Octet repeatInterval;

      ::CORBA::String_member message;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TtisFreeTextDisplayParameters::_var_type TtisFreeTextDisplayParameters_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TtisFreeTextDisplayParameters,TtisFreeTextDisplayParameters_var > TtisFreeTextDisplayParameters_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtisFreeTextDisplayParameters;

    struct TtisPredefinedDisplayParameters {
      typedef _CORBA_ConstrType_Variable_Var<TtisPredefinedDisplayParameters> _var_type;

      
      TtisPidList pidList;

      ::CORBA::UShort libraryVersion;

      ::CORBA::Octet identifierType;

      ::CORBA::Octet identifierOffset;

      ETtisPriority priority;

      TimeInterval displayPeriod;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TtisPredefinedDisplayParameters::_var_type TtisPredefinedDisplayParameters_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TtisPredefinedDisplayParameters,TtisPredefinedDisplayParameters_var > TtisPredefinedDisplayParameters_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtisPredefinedDisplayParameters;

    struct TtisResetParameters {
      typedef _CORBA_ConstrType_Variable_Var<TtisResetParameters> _var_type;

      
      TtisPidList pidList;

      ETtisResetMessageType messageType;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TtisResetParameters::_var_type TtisResetParameters_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TtisResetParameters,TtisResetParameters_var > TtisResetParameters_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TtisResetParameters;

    class DisplayParameters {
    public:

      typedef _CORBA_ConstrType_Variable_Var<DisplayParameters> _var_type;

      

      DisplayParameters(): _pd__initialised(0) {
        
      }
      
      DisplayParameters(const DisplayParameters& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case TtisFreeTextCommand: freetextParameters(_value._pd_freetextParameters); break;

          case TtisPredefinedCommand: predefinedParameters(_value._pd_predefinedParameters); break;

          case TtisResetCommand: resetParameters(_value._pd_resetParameters); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~DisplayParameters() {}

      DisplayParameters& operator=(const DisplayParameters& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case TtisFreeTextCommand: freetextParameters(_value._pd_freetextParameters); break;

          case TtisPredefinedCommand: predefinedParameters(_value._pd_predefinedParameters); break;

          case TtisResetCommand: resetParameters(_value._pd_resetParameters); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      ETtisOriginalCommand _d() const { return _pd__d;}
      void _d(ETtisOriginalCommand _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case TtisFreeTextCommand: goto fail;
          case TtisPredefinedCommand: goto fail;
          case TtisResetCommand: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      const TtisFreeTextDisplayParameters &freetextParameters () const { return _pd_freetextParameters; }
      TtisFreeTextDisplayParameters &freetextParameters () { return _pd_freetextParameters; }
      void freetextParameters (const TtisFreeTextDisplayParameters& _value) {
        _pd__initialised = 1;
        _pd__d = TtisFreeTextCommand;
        _pd__default = 0;
        _pd_freetextParameters = _value;
      }

      const TtisPredefinedDisplayParameters &predefinedParameters () const { return _pd_predefinedParameters; }
      TtisPredefinedDisplayParameters &predefinedParameters () { return _pd_predefinedParameters; }
      void predefinedParameters (const TtisPredefinedDisplayParameters& _value) {
        _pd__initialised = 1;
        _pd__d = TtisPredefinedCommand;
        _pd__default = 0;
        _pd_predefinedParameters = _value;
      }

      const TtisResetParameters &resetParameters () const { return _pd_resetParameters; }
      TtisResetParameters &resetParameters () { return _pd_resetParameters; }
      void resetParameters (const TtisResetParameters& _value) {
        _pd__initialised = 1;
        _pd__d = TtisResetCommand;
        _pd__default = 0;
        _pd_resetParameters = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      ETtisOriginalCommand _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      
      TtisFreeTextDisplayParameters _pd_freetextParameters;

      TtisPredefinedDisplayParameters _pd_predefinedParameters;

      TtisResetParameters _pd_resetParameters;

    
    };

    typedef DisplayParameters::_var_type DisplayParameters_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DisplayParameters,DisplayParameters_var > DisplayParameters_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisplayParameters;

    struct TisReturnStatus {
      typedef _CORBA_ConstrType_Variable_Var<TisReturnStatus> _var_type;

      
      ITrainCommonCorba::TrainId trainId;

      ::CORBA::String_member sessionId;

      ::CORBA::Long timestamp;

      ETtisCommandResult result;

      DisplayParameters originalParameters;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TisReturnStatus::_var_type TisReturnStatus_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TisReturnStatus,TisReturnStatus_var > TisReturnStatus_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TisReturnStatus;

  
  };

  class _objref_ITrainTisCorba :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::UShort getFlexibleTimeOutValue();
    ITrainTisCorba::TisLibraryVersionList* getLibraryVersions();
    ITrainTisCorba::TisLibraryVersionUpdate getLibraryVersionsForTrain(::TA_Base_Bus::ITrainCommonCorba::TrainId trainId);
    void displayFreeTextMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId);
    void displayStoredMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId);
    void resetMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisResetParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId);
    void libraryDownload(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::LibraryDataType& libraryData, ::CORBA::UShort libraryVersion, const char* sessionId);
    void libraryUpgrade(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const char* sessionId);
    void scheduleDownload(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::LibraryDataType& scheduleData, ::CORBA::UShort scheduleVersion, const char* sessionId);
    void scheduleUpgrade(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const char* sessionId);

    inline _objref_ITrainTisCorba()  { _PR_setobj(0); }  // nil
    _objref_ITrainTisCorba(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ITrainTisCorba();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ITrainTisCorba(const _objref_ITrainTisCorba&);
    _objref_ITrainTisCorba& operator = (const _objref_ITrainTisCorba&);
    // not implemented

    friend class ITrainTisCorba;
  };

  class _pof_ITrainTisCorba : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ITrainTisCorba() : _OMNI_NS(proxyObjectFactory)(ITrainTisCorba::_PD_repoId) {}
    virtual ~_pof_ITrainTisCorba();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ITrainTisCorba :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ITrainTisCorba();

    virtual ::CORBA::UShort getFlexibleTimeOutValue() = 0;
    virtual ITrainTisCorba::TisLibraryVersionList* getLibraryVersions() = 0;
    virtual ITrainTisCorba::TisLibraryVersionUpdate getLibraryVersionsForTrain(::TA_Base_Bus::ITrainCommonCorba::TrainId trainId) = 0;
    virtual void displayFreeTextMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId) = 0;
    virtual void displayStoredMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId) = 0;
    virtual void resetMessage(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::TtisResetParameters& displayParameters, ::CORBA::Long timestamp, const char* sessionId) = 0;
    virtual void libraryDownload(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::LibraryDataType& libraryData, ::CORBA::UShort libraryVersion, const char* sessionId) = 0;
    virtual void libraryUpgrade(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const char* sessionId) = 0;
    virtual void scheduleDownload(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const ::TA_Base_Bus::ITrainTisCorba::LibraryDataType& scheduleData, ::CORBA::UShort scheduleVersion, const char* sessionId) = 0;
    virtual void scheduleUpgrade(const ::TA_Base_Bus::ITrainCommonCorba::TrainList& trains, const char* sessionId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ITrainTisCorba;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  class ITrainTisCorba :
    public virtual TA_Base_Bus::_impl_ITrainTisCorba,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ITrainTisCorba();

    inline ::TA_Base_Bus::ITrainTisCorba_ptr _this() {
      return (::TA_Base_Bus::ITrainTisCorba_ptr) _do_this(::TA_Base_Bus::ITrainTisCorba::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryVersionUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryVersionUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryVersionUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryVersionUpdate*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryVersionList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryVersionList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryVersionList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryVersionList*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::LibraryDataType& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::LibraryDataType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::LibraryDataType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::LibraryDataType*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETisUpdateType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETisUpdateType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::ScheduleUpgradeResult) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETisUpdateType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETisUpdateType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETisUpdateType& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisCommandResult _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisCommandResult& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::MpuChangeoverError) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisCommandResult) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisCommandResult _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisCommandResult& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::EDownloadResult _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::EDownloadResult& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::MpuChangeover) {
    _e = (TA_Base_Bus::ITrainTisCorba::EDownloadResult) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::EDownloadResult _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::EDownloadResult& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisLibraryUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisLibraryUpdate*& _sp);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisOriginalCommand _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisOriginalCommand& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisResetCommand) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisOriginalCommand) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisOriginalCommand _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisOriginalCommand& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisFontSize _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisFontSize& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisFontLarge) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisFontSize) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisFontSize _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisFontSize& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisJustification _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisJustification& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisJustificationRight) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisJustification) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisJustification _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisJustification& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisIntensity _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisIntensity& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisIntensityHigh) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisIntensity) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisIntensity _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisIntensity& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisDisplayMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisDisplayMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisDisplayModeLikeSnow) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisDisplayMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisDisplayMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisDisplayMode& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisPriority _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisPriority& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::ETtisPriorityEight) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisPriority) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisPriority _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisPriority& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisResetMessageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisResetMessageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisResetPriority6) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisResetMessageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisResetMessageType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisResetMessageType& _s);

inline void operator >>=(TA_Base_Bus::ITrainTisCorba::ETtisPid _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::ITrainTisCorba::ETtisPid& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::ITrainTisCorba::TtisPidCar3Pid4) {
    _e = (TA_Base_Bus::ITrainTisCorba::ETtisPid) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisPid _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::ETtisPid& _s);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisPidList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisPidList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisPidList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisPidList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TimeInterval& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TimeInterval* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TimeInterval*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TimeInterval*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisFreeTextDisplayParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisPredefinedDisplayParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisResetParameters& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisResetParameters* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TtisResetParameters*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TtisResetParameters*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::DisplayParameters& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::DisplayParameters* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::DisplayParameters*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::DisplayParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisReturnStatus& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisReturnStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba::TisReturnStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::ITrainTisCorba::TisReturnStatus*& _sp);

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba_ptr _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::ITrainTisCorba_ptr& _s);



inline void
TA_Base_Bus::ITrainTisCorba::_marshalObjRef(::TA_Base_Bus::ITrainTisCorba_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_ITrainTisCorba
#endif

#endif  // __ITrainTisCorba_hh__

