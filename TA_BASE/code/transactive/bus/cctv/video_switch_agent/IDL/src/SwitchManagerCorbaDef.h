// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __SwitchManagerCorbaDef_hh__
#define __SwitchManagerCorbaDef_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif



#ifndef __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <CommonExceptionsCorbaDef.h>
#endif
#ifndef __ExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __ExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <ExceptionsCorbaDef.h>
#endif
#ifndef __VideoSwitchResourceCorbaDef_hh_EXTERNAL_GUARD__
#define __VideoSwitchResourceCorbaDef_hh_EXTERNAL_GUARD__
#include <VideoSwitchResourceCorbaDef.h>
#endif
#ifndef __VideoOutputCorbaDef_hh_EXTERNAL_GUARD__
#define __VideoOutputCorbaDef_hh_EXTERNAL_GUARD__
#include <VideoOutputCorbaDef.h>
#endif
#ifndef __VideoOutputGroupCorbaDef_hh_EXTERNAL_GUARD__
#define __VideoOutputGroupCorbaDef_hh_EXTERNAL_GUARD__
#include <VideoOutputGroupCorbaDef.h>
#endif
#ifndef __VideoInputCorbaDef_hh_EXTERNAL_GUARD__
#define __VideoInputCorbaDef_hh_EXTERNAL_GUARD__
#include <VideoInputCorbaDef.h>
#endif
#ifndef __VideoMonitorCorbaDef_hh_EXTERNAL_GUARD__
#define __VideoMonitorCorbaDef_hh_EXTERNAL_GUARD__
#include <VideoMonitorCorbaDef.h>
#endif
#ifndef __RecordingUnitCorbaDef_hh_EXTERNAL_GUARD__
#define __RecordingUnitCorbaDef_hh_EXTERNAL_GUARD__
#include <RecordingUnitCorbaDef.h>
#endif
#ifndef __MovementControlCorbaDef_hh_EXTERNAL_GUARD__
#define __MovementControlCorbaDef_hh_EXTERNAL_GUARD__
#include <MovementControlCorbaDef.h>
#endif
#ifndef __FocusIrisControlCorbaDef_hh_EXTERNAL_GUARD__
#define __FocusIrisControlCorbaDef_hh_EXTERNAL_GUARD__
#include <FocusIrisControlCorbaDef.h>
#endif
#ifndef __WashWipeControlCorbaDef_hh_EXTERNAL_GUARD__
#define __WashWipeControlCorbaDef_hh_EXTERNAL_GUARD__
#include <WashWipeControlCorbaDef.h>
#endif
#ifndef __CameraCorbaDef_hh_EXTERNAL_GUARD__
#define __CameraCorbaDef_hh_EXTERNAL_GUARD__
#include <CameraCorbaDef.h>
#endif
#ifndef __SequenceCorbaDef_hh_EXTERNAL_GUARD__
#define __SequenceCorbaDef_hh_EXTERNAL_GUARD__
#include <SequenceCorbaDef.h>
#endif
#ifndef __GenericMessageCorbaDef_hh_EXTERNAL_GUARD__
#define __GenericMessageCorbaDef_hh_EXTERNAL_GUARD__
#include <GenericMessageCorbaDef.h>
#endif
#ifndef __AlarmUpdateCorbaDef_hh_EXTERNAL_GUARD__
#define __AlarmUpdateCorbaDef_hh_EXTERNAL_GUARD__
#include <AlarmUpdateCorbaDef.h>
#endif
#ifndef __AlarmMessageCorbaDef_hh_EXTERNAL_GUARD__
#define __AlarmMessageCorbaDef_hh_EXTERNAL_GUARD__
#include <AlarmMessageCorbaDef.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

#ifndef __TA__Base__Bus_mSwitchManagerCorbaDef__
#define __TA__Base__Bus_mSwitchManagerCorbaDef__

  class SwitchManagerCorbaDef;
  class _objref_SwitchManagerCorbaDef;
  class _impl_SwitchManagerCorbaDef;
  
  typedef _objref_SwitchManagerCorbaDef* SwitchManagerCorbaDef_ptr;
  typedef SwitchManagerCorbaDef_ptr SwitchManagerCorbaDefRef;

  class SwitchManagerCorbaDef_Helper {
  public:
    typedef SwitchManagerCorbaDef_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SwitchManagerCorbaDef, SwitchManagerCorbaDef_Helper> SwitchManagerCorbaDef_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SwitchManagerCorbaDef,SwitchManagerCorbaDef_Helper > SwitchManagerCorbaDef_out;

#endif

  // interface SwitchManagerCorbaDef
  class SwitchManagerCorbaDef {
  public:
    // Declarations for this interface type.
    typedef SwitchManagerCorbaDef_ptr _ptr_type;
    typedef SwitchManagerCorbaDef_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VideoOutputGroupSequence;

    class VideoOutputGroupSequence_var;

    class VideoOutputGroupSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputGroupCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper> , VideoOutputGroupCorbaDef_Helper >  {
    public:
      typedef VideoOutputGroupSequence_var _var_type;
      inline VideoOutputGroupSequence() {}
      inline VideoOutputGroupSequence(const VideoOutputGroupSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputGroupCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper> , VideoOutputGroupCorbaDef_Helper > (_s) {}

      inline VideoOutputGroupSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputGroupCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper> , VideoOutputGroupCorbaDef_Helper > (_max) {}
      inline VideoOutputGroupSequence(_CORBA_ULong _max, _CORBA_ULong _len, VideoOutputGroupCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputGroupCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper> , VideoOutputGroupCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline VideoOutputGroupSequence& operator = (const VideoOutputGroupSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputGroupCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper> , VideoOutputGroupCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class VideoOutputGroupSequence_out;

    class VideoOutputGroupSequence_var {
    public:
      inline VideoOutputGroupSequence_var() : _pd_seq(0) {}
      inline VideoOutputGroupSequence_var(VideoOutputGroupSequence* _s) : _pd_seq(_s) {}
      inline VideoOutputGroupSequence_var(const VideoOutputGroupSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new VideoOutputGroupSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~VideoOutputGroupSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline VideoOutputGroupSequence_var& operator = (VideoOutputGroupSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline VideoOutputGroupSequence_var& operator = (const VideoOutputGroupSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new VideoOutputGroupSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline VideoOutputGroupSequence* operator -> () { return _pd_seq; }
      inline const VideoOutputGroupSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator VideoOutputGroupSequence& () const { return *_pd_seq; }
#else
      inline operator const VideoOutputGroupSequence& () const { return *_pd_seq; }
      inline operator VideoOutputGroupSequence& () { return *_pd_seq; }
#endif
        
      inline const VideoOutputGroupSequence& in() const { return *_pd_seq; }
      inline VideoOutputGroupSequence&       inout()    { return *_pd_seq; }
      inline VideoOutputGroupSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline VideoOutputGroupSequence* _retn() { VideoOutputGroupSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class VideoOutputGroupSequence_out;
      
    private:
      VideoOutputGroupSequence* _pd_seq;
    };

    class VideoOutputGroupSequence_out {
    public:
      inline VideoOutputGroupSequence_out(VideoOutputGroupSequence*& _s) : _data(_s) { _data = 0; }
      inline VideoOutputGroupSequence_out(VideoOutputGroupSequence_var& _s)
        : _data(_s._pd_seq) { _s = (VideoOutputGroupSequence*) 0; }
      inline VideoOutputGroupSequence_out(const VideoOutputGroupSequence_out& _s) : _data(_s._data) {}
      inline VideoOutputGroupSequence_out& operator = (const VideoOutputGroupSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline VideoOutputGroupSequence_out& operator = (VideoOutputGroupSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator VideoOutputGroupSequence*&()  { return _data; }
      inline VideoOutputGroupSequence*& ptr()       { return _data; }
      inline VideoOutputGroupSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_VideoOutputGroupCorbaDef, VideoOutputGroupCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      VideoOutputGroupSequence*& _data;

    private:
      VideoOutputGroupSequence_out();
      VideoOutputGroupSequence_out& operator=(const VideoOutputGroupSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VideoMonitorSequence;

    class VideoMonitorSequence_var;

    class VideoMonitorSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoMonitorCorbaDef, _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper> , VideoMonitorCorbaDef_Helper >  {
    public:
      typedef VideoMonitorSequence_var _var_type;
      inline VideoMonitorSequence() {}
      inline VideoMonitorSequence(const VideoMonitorSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoMonitorCorbaDef, _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper> , VideoMonitorCorbaDef_Helper > (_s) {}

      inline VideoMonitorSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoMonitorCorbaDef, _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper> , VideoMonitorCorbaDef_Helper > (_max) {}
      inline VideoMonitorSequence(_CORBA_ULong _max, _CORBA_ULong _len, VideoMonitorCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoMonitorCorbaDef, _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper> , VideoMonitorCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline VideoMonitorSequence& operator = (const VideoMonitorSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoMonitorCorbaDef, _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper> , VideoMonitorCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class VideoMonitorSequence_out;

    class VideoMonitorSequence_var {
    public:
      inline VideoMonitorSequence_var() : _pd_seq(0) {}
      inline VideoMonitorSequence_var(VideoMonitorSequence* _s) : _pd_seq(_s) {}
      inline VideoMonitorSequence_var(const VideoMonitorSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new VideoMonitorSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~VideoMonitorSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline VideoMonitorSequence_var& operator = (VideoMonitorSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline VideoMonitorSequence_var& operator = (const VideoMonitorSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new VideoMonitorSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline VideoMonitorSequence* operator -> () { return _pd_seq; }
      inline const VideoMonitorSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator VideoMonitorSequence& () const { return *_pd_seq; }
#else
      inline operator const VideoMonitorSequence& () const { return *_pd_seq; }
      inline operator VideoMonitorSequence& () { return *_pd_seq; }
#endif
        
      inline const VideoMonitorSequence& in() const { return *_pd_seq; }
      inline VideoMonitorSequence&       inout()    { return *_pd_seq; }
      inline VideoMonitorSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline VideoMonitorSequence* _retn() { VideoMonitorSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class VideoMonitorSequence_out;
      
    private:
      VideoMonitorSequence* _pd_seq;
    };

    class VideoMonitorSequence_out {
    public:
      inline VideoMonitorSequence_out(VideoMonitorSequence*& _s) : _data(_s) { _data = 0; }
      inline VideoMonitorSequence_out(VideoMonitorSequence_var& _s)
        : _data(_s._pd_seq) { _s = (VideoMonitorSequence*) 0; }
      inline VideoMonitorSequence_out(const VideoMonitorSequence_out& _s) : _data(_s._data) {}
      inline VideoMonitorSequence_out& operator = (const VideoMonitorSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline VideoMonitorSequence_out& operator = (VideoMonitorSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator VideoMonitorSequence*&()  { return _data; }
      inline VideoMonitorSequence*& ptr()       { return _data; }
      inline VideoMonitorSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_VideoMonitorCorbaDef, VideoMonitorCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      VideoMonitorSequence*& _data;

    private:
      VideoMonitorSequence_out();
      VideoMonitorSequence_out& operator=(const VideoMonitorSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RecordingUnitSequence;

    class RecordingUnitSequence_var;

    class RecordingUnitSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_RecordingUnitCorbaDef, _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper> , RecordingUnitCorbaDef_Helper >  {
    public:
      typedef RecordingUnitSequence_var _var_type;
      inline RecordingUnitSequence() {}
      inline RecordingUnitSequence(const RecordingUnitSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_RecordingUnitCorbaDef, _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper> , RecordingUnitCorbaDef_Helper > (_s) {}

      inline RecordingUnitSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_RecordingUnitCorbaDef, _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper> , RecordingUnitCorbaDef_Helper > (_max) {}
      inline RecordingUnitSequence(_CORBA_ULong _max, _CORBA_ULong _len, RecordingUnitCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_RecordingUnitCorbaDef, _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper> , RecordingUnitCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline RecordingUnitSequence& operator = (const RecordingUnitSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_RecordingUnitCorbaDef, _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper> , RecordingUnitCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class RecordingUnitSequence_out;

    class RecordingUnitSequence_var {
    public:
      inline RecordingUnitSequence_var() : _pd_seq(0) {}
      inline RecordingUnitSequence_var(RecordingUnitSequence* _s) : _pd_seq(_s) {}
      inline RecordingUnitSequence_var(const RecordingUnitSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RecordingUnitSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RecordingUnitSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RecordingUnitSequence_var& operator = (RecordingUnitSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RecordingUnitSequence_var& operator = (const RecordingUnitSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RecordingUnitSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RecordingUnitSequence* operator -> () { return _pd_seq; }
      inline const RecordingUnitSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RecordingUnitSequence& () const { return *_pd_seq; }
#else
      inline operator const RecordingUnitSequence& () const { return *_pd_seq; }
      inline operator RecordingUnitSequence& () { return *_pd_seq; }
#endif
        
      inline const RecordingUnitSequence& in() const { return *_pd_seq; }
      inline RecordingUnitSequence&       inout()    { return *_pd_seq; }
      inline RecordingUnitSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RecordingUnitSequence* _retn() { RecordingUnitSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RecordingUnitSequence_out;
      
    private:
      RecordingUnitSequence* _pd_seq;
    };

    class RecordingUnitSequence_out {
    public:
      inline RecordingUnitSequence_out(RecordingUnitSequence*& _s) : _data(_s) { _data = 0; }
      inline RecordingUnitSequence_out(RecordingUnitSequence_var& _s)
        : _data(_s._pd_seq) { _s = (RecordingUnitSequence*) 0; }
      inline RecordingUnitSequence_out(const RecordingUnitSequence_out& _s) : _data(_s._data) {}
      inline RecordingUnitSequence_out& operator = (const RecordingUnitSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RecordingUnitSequence_out& operator = (RecordingUnitSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator RecordingUnitSequence*&()  { return _data; }
      inline RecordingUnitSequence*& ptr()       { return _data; }
      inline RecordingUnitSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_RecordingUnitCorbaDef, RecordingUnitCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RecordingUnitSequence*& _data;

    private:
      RecordingUnitSequence_out();
      RecordingUnitSequence_out& operator=(const RecordingUnitSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CameraSequence;

    class CameraSequence_var;

    class CameraSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_CameraCorbaDef, _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper> , CameraCorbaDef_Helper >  {
    public:
      typedef CameraSequence_var _var_type;
      inline CameraSequence() {}
      inline CameraSequence(const CameraSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_CameraCorbaDef, _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper> , CameraCorbaDef_Helper > (_s) {}

      inline CameraSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_CameraCorbaDef, _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper> , CameraCorbaDef_Helper > (_max) {}
      inline CameraSequence(_CORBA_ULong _max, _CORBA_ULong _len, CameraCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_CameraCorbaDef, _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper> , CameraCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline CameraSequence& operator = (const CameraSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_CameraCorbaDef, _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper> , CameraCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class CameraSequence_out;

    class CameraSequence_var {
    public:
      inline CameraSequence_var() : _pd_seq(0) {}
      inline CameraSequence_var(CameraSequence* _s) : _pd_seq(_s) {}
      inline CameraSequence_var(const CameraSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CameraSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CameraSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CameraSequence_var& operator = (CameraSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CameraSequence_var& operator = (const CameraSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CameraSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CameraSequence* operator -> () { return _pd_seq; }
      inline const CameraSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CameraSequence& () const { return *_pd_seq; }
#else
      inline operator const CameraSequence& () const { return *_pd_seq; }
      inline operator CameraSequence& () { return *_pd_seq; }
#endif
        
      inline const CameraSequence& in() const { return *_pd_seq; }
      inline CameraSequence&       inout()    { return *_pd_seq; }
      inline CameraSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CameraSequence* _retn() { CameraSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CameraSequence_out;
      
    private:
      CameraSequence* _pd_seq;
    };

    class CameraSequence_out {
    public:
      inline CameraSequence_out(CameraSequence*& _s) : _data(_s) { _data = 0; }
      inline CameraSequence_out(CameraSequence_var& _s)
        : _data(_s._pd_seq) { _s = (CameraSequence*) 0; }
      inline CameraSequence_out(const CameraSequence_out& _s) : _data(_s._data) {}
      inline CameraSequence_out& operator = (const CameraSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CameraSequence_out& operator = (CameraSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator CameraSequence*&()  { return _data; }
      inline CameraSequence*& ptr()       { return _data; }
      inline CameraSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_CameraCorbaDef, CameraCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CameraSequence*& _data;

    private:
      CameraSequence_out();
      CameraSequence_out& operator=(const CameraSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceSequence;

    class SequenceSequence_var;

    class SequenceSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_SequenceCorbaDef, _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper> , SequenceCorbaDef_Helper >  {
    public:
      typedef SequenceSequence_var _var_type;
      inline SequenceSequence() {}
      inline SequenceSequence(const SequenceSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_SequenceCorbaDef, _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper> , SequenceCorbaDef_Helper > (_s) {}

      inline SequenceSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_SequenceCorbaDef, _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper> , SequenceCorbaDef_Helper > (_max) {}
      inline SequenceSequence(_CORBA_ULong _max, _CORBA_ULong _len, SequenceCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_SequenceCorbaDef, _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper> , SequenceCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline SequenceSequence& operator = (const SequenceSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_SequenceCorbaDef, _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper> , SequenceCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class SequenceSequence_out;

    class SequenceSequence_var {
    public:
      inline SequenceSequence_var() : _pd_seq(0) {}
      inline SequenceSequence_var(SequenceSequence* _s) : _pd_seq(_s) {}
      inline SequenceSequence_var(const SequenceSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SequenceSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SequenceSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SequenceSequence_var& operator = (SequenceSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SequenceSequence_var& operator = (const SequenceSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SequenceSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SequenceSequence* operator -> () { return _pd_seq; }
      inline const SequenceSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SequenceSequence& () const { return *_pd_seq; }
#else
      inline operator const SequenceSequence& () const { return *_pd_seq; }
      inline operator SequenceSequence& () { return *_pd_seq; }
#endif
        
      inline const SequenceSequence& in() const { return *_pd_seq; }
      inline SequenceSequence&       inout()    { return *_pd_seq; }
      inline SequenceSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SequenceSequence* _retn() { SequenceSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SequenceSequence_out;
      
    private:
      SequenceSequence* _pd_seq;
    };

    class SequenceSequence_out {
    public:
      inline SequenceSequence_out(SequenceSequence*& _s) : _data(_s) { _data = 0; }
      inline SequenceSequence_out(SequenceSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SequenceSequence*) 0; }
      inline SequenceSequence_out(const SequenceSequence_out& _s) : _data(_s._data) {}
      inline SequenceSequence_out& operator = (const SequenceSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SequenceSequence_out& operator = (SequenceSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SequenceSequence*&()  { return _data; }
      inline SequenceSequence*& ptr()       { return _data; }
      inline SequenceSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_SequenceCorbaDef, SequenceCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SequenceSequence*& _data;

    private:
      SequenceSequence_out();
      SequenceSequence_out& operator=(const SequenceSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VideoOutputSequence;

    class VideoOutputSequence_var;

    class VideoOutputSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper> , VideoOutputCorbaDef_Helper >  {
    public:
      typedef VideoOutputSequence_var _var_type;
      inline VideoOutputSequence() {}
      inline VideoOutputSequence(const VideoOutputSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper> , VideoOutputCorbaDef_Helper > (_s) {}

      inline VideoOutputSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper> , VideoOutputCorbaDef_Helper > (_max) {}
      inline VideoOutputSequence(_CORBA_ULong _max, _CORBA_ULong _len, VideoOutputCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper> , VideoOutputCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline VideoOutputSequence& operator = (const VideoOutputSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoOutputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper> , VideoOutputCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class VideoOutputSequence_out;

    class VideoOutputSequence_var {
    public:
      inline VideoOutputSequence_var() : _pd_seq(0) {}
      inline VideoOutputSequence_var(VideoOutputSequence* _s) : _pd_seq(_s) {}
      inline VideoOutputSequence_var(const VideoOutputSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new VideoOutputSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~VideoOutputSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline VideoOutputSequence_var& operator = (VideoOutputSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline VideoOutputSequence_var& operator = (const VideoOutputSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new VideoOutputSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline VideoOutputSequence* operator -> () { return _pd_seq; }
      inline const VideoOutputSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator VideoOutputSequence& () const { return *_pd_seq; }
#else
      inline operator const VideoOutputSequence& () const { return *_pd_seq; }
      inline operator VideoOutputSequence& () { return *_pd_seq; }
#endif
        
      inline const VideoOutputSequence& in() const { return *_pd_seq; }
      inline VideoOutputSequence&       inout()    { return *_pd_seq; }
      inline VideoOutputSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline VideoOutputSequence* _retn() { VideoOutputSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class VideoOutputSequence_out;
      
    private:
      VideoOutputSequence* _pd_seq;
    };

    class VideoOutputSequence_out {
    public:
      inline VideoOutputSequence_out(VideoOutputSequence*& _s) : _data(_s) { _data = 0; }
      inline VideoOutputSequence_out(VideoOutputSequence_var& _s)
        : _data(_s._pd_seq) { _s = (VideoOutputSequence*) 0; }
      inline VideoOutputSequence_out(const VideoOutputSequence_out& _s) : _data(_s._data) {}
      inline VideoOutputSequence_out& operator = (const VideoOutputSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline VideoOutputSequence_out& operator = (VideoOutputSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator VideoOutputSequence*&()  { return _data; }
      inline VideoOutputSequence*& ptr()       { return _data; }
      inline VideoOutputSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_VideoOutputCorbaDef, VideoOutputCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      VideoOutputSequence*& _data;

    private:
      VideoOutputSequence_out();
      VideoOutputSequence_out& operator=(const VideoOutputSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VideoInputSequence;

    class VideoInputSequence_var;

    class VideoInputSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoInputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper> , VideoInputCorbaDef_Helper >  {
    public:
      typedef VideoInputSequence_var _var_type;
      inline VideoInputSequence() {}
      inline VideoInputSequence(const VideoInputSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoInputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper> , VideoInputCorbaDef_Helper > (_s) {}

      inline VideoInputSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoInputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper> , VideoInputCorbaDef_Helper > (_max) {}
      inline VideoInputSequence(_CORBA_ULong _max, _CORBA_ULong _len, VideoInputCorbaDef_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoInputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper> , VideoInputCorbaDef_Helper > (_max, _len, _val, _rel) {}

    

      inline VideoInputSequence& operator = (const VideoInputSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_VideoInputCorbaDef, _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper> , VideoInputCorbaDef_Helper > ::operator=(_s);
        return *this;
      }
    };

    class VideoInputSequence_out;

    class VideoInputSequence_var {
    public:
      inline VideoInputSequence_var() : _pd_seq(0) {}
      inline VideoInputSequence_var(VideoInputSequence* _s) : _pd_seq(_s) {}
      inline VideoInputSequence_var(const VideoInputSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new VideoInputSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~VideoInputSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline VideoInputSequence_var& operator = (VideoInputSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline VideoInputSequence_var& operator = (const VideoInputSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new VideoInputSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline VideoInputSequence* operator -> () { return _pd_seq; }
      inline const VideoInputSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator VideoInputSequence& () const { return *_pd_seq; }
#else
      inline operator const VideoInputSequence& () const { return *_pd_seq; }
      inline operator VideoInputSequence& () { return *_pd_seq; }
#endif
        
      inline const VideoInputSequence& in() const { return *_pd_seq; }
      inline VideoInputSequence&       inout()    { return *_pd_seq; }
      inline VideoInputSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline VideoInputSequence* _retn() { VideoInputSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class VideoInputSequence_out;
      
    private:
      VideoInputSequence* _pd_seq;
    };

    class VideoInputSequence_out {
    public:
      inline VideoInputSequence_out(VideoInputSequence*& _s) : _data(_s) { _data = 0; }
      inline VideoInputSequence_out(VideoInputSequence_var& _s)
        : _data(_s._pd_seq) { _s = (VideoInputSequence*) 0; }
      inline VideoInputSequence_out(const VideoInputSequence_out& _s) : _data(_s._data) {}
      inline VideoInputSequence_out& operator = (const VideoInputSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline VideoInputSequence_out& operator = (VideoInputSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator VideoInputSequence*&()  { return _data; }
      inline VideoInputSequence*& ptr()       { return _data; }
      inline VideoInputSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_VideoInputCorbaDef, VideoInputCorbaDef_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      VideoInputSequence*& _data;

    private:
      VideoInputSequence_out();
      VideoInputSequence_out& operator=(const VideoInputSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TrainCameraSequence;

    class TrainCameraSequence_var;

    class TrainCameraSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
    public:
      typedef TrainCameraSequence_var _var_type;
      inline TrainCameraSequence() {}
      inline TrainCameraSequence(const TrainCameraSequence& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

      inline TrainCameraSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
      inline TrainCameraSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline TrainCameraSequence& operator = (const TrainCameraSequence& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class TrainCameraSequence_out;

    class TrainCameraSequence_var {
    public:
      inline TrainCameraSequence_var() : _pd_seq(0) {}
      inline TrainCameraSequence_var(TrainCameraSequence* _s) : _pd_seq(_s) {}
      inline TrainCameraSequence_var(const TrainCameraSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TrainCameraSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TrainCameraSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TrainCameraSequence_var& operator = (TrainCameraSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TrainCameraSequence_var& operator = (const TrainCameraSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TrainCameraSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TrainCameraSequence* operator -> () { return _pd_seq; }
      inline const TrainCameraSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TrainCameraSequence& () const { return *_pd_seq; }
#else
      inline operator const TrainCameraSequence& () const { return *_pd_seq; }
      inline operator TrainCameraSequence& () { return *_pd_seq; }
#endif
        
      inline const TrainCameraSequence& in() const { return *_pd_seq; }
      inline TrainCameraSequence&       inout()    { return *_pd_seq; }
      inline TrainCameraSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TrainCameraSequence* _retn() { TrainCameraSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TrainCameraSequence_out;
      
    private:
      TrainCameraSequence* _pd_seq;
    };

    class TrainCameraSequence_out {
    public:
      inline TrainCameraSequence_out(TrainCameraSequence*& _s) : _data(_s) { _data = 0; }
      inline TrainCameraSequence_out(TrainCameraSequence_var& _s)
        : _data(_s._pd_seq) { _s = (TrainCameraSequence*) 0; }
      inline TrainCameraSequence_out(const TrainCameraSequence_out& _s) : _data(_s._data) {}
      inline TrainCameraSequence_out& operator = (const TrainCameraSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TrainCameraSequence_out& operator = (TrainCameraSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator TrainCameraSequence*&()  { return _data; }
      inline TrainCameraSequence*& ptr()       { return _data; }
      inline TrainCameraSequence* operator->() { return _data; }

      inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TrainCameraSequence*& _data;

    private:
      TrainCameraSequence_out();
      TrainCameraSequence_out& operator=(const TrainCameraSequence_var&);
    };

    struct TriggerAlarm {
      typedef _CORBA_ConstrType_Fix_Var<TriggerAlarm> _var_type;

      
      ::CORBA::ULong stationId;

      ::CORBA::ULong eventId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TriggerAlarm::_var_type TriggerAlarm_var;

    typedef TriggerAlarm& TriggerAlarm_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TriggerAlarm;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TriggerAlarmSequence;

    class TriggerAlarmSequence_var;

    class TriggerAlarmSequence : public _CORBA_Unbounded_Sequence< TriggerAlarm >  {
    public:
      typedef TriggerAlarmSequence_var _var_type;
      inline TriggerAlarmSequence() {}
      inline TriggerAlarmSequence(const TriggerAlarmSequence& _s)
        : _CORBA_Unbounded_Sequence< TriggerAlarm > (_s) {}

      inline TriggerAlarmSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TriggerAlarm > (_max) {}
      inline TriggerAlarmSequence(_CORBA_ULong _max, _CORBA_ULong _len, TriggerAlarm* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TriggerAlarm > (_max, _len, _val, _rel) {}

    

      inline TriggerAlarmSequence& operator = (const TriggerAlarmSequence& _s) {
        _CORBA_Unbounded_Sequence< TriggerAlarm > ::operator=(_s);
        return *this;
      }
    };

    class TriggerAlarmSequence_out;

    class TriggerAlarmSequence_var {
    public:
      inline TriggerAlarmSequence_var() : _pd_seq(0) {}
      inline TriggerAlarmSequence_var(TriggerAlarmSequence* _s) : _pd_seq(_s) {}
      inline TriggerAlarmSequence_var(const TriggerAlarmSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TriggerAlarmSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TriggerAlarmSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TriggerAlarmSequence_var& operator = (TriggerAlarmSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TriggerAlarmSequence_var& operator = (const TriggerAlarmSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TriggerAlarmSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TriggerAlarm& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TriggerAlarmSequence* operator -> () { return _pd_seq; }
      inline const TriggerAlarmSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TriggerAlarmSequence& () const { return *_pd_seq; }
#else
      inline operator const TriggerAlarmSequence& () const { return *_pd_seq; }
      inline operator TriggerAlarmSequence& () { return *_pd_seq; }
#endif
        
      inline const TriggerAlarmSequence& in() const { return *_pd_seq; }
      inline TriggerAlarmSequence&       inout()    { return *_pd_seq; }
      inline TriggerAlarmSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TriggerAlarmSequence* _retn() { TriggerAlarmSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TriggerAlarmSequence_out;
      
    private:
      TriggerAlarmSequence* _pd_seq;
    };

    class TriggerAlarmSequence_out {
    public:
      inline TriggerAlarmSequence_out(TriggerAlarmSequence*& _s) : _data(_s) { _data = 0; }
      inline TriggerAlarmSequence_out(TriggerAlarmSequence_var& _s)
        : _data(_s._pd_seq) { _s = (TriggerAlarmSequence*) 0; }
      inline TriggerAlarmSequence_out(const TriggerAlarmSequence_out& _s) : _data(_s._data) {}
      inline TriggerAlarmSequence_out& operator = (const TriggerAlarmSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TriggerAlarmSequence_out& operator = (TriggerAlarmSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator TriggerAlarmSequence*&()  { return _data; }
      inline TriggerAlarmSequence*& ptr()       { return _data; }
      inline TriggerAlarmSequence* operator->() { return _data; }

      inline TriggerAlarm& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TriggerAlarmSequence*& _data;

    private:
      TriggerAlarmSequence_out();
      TriggerAlarmSequence_out& operator=(const TriggerAlarmSequence_var&);
    };

    struct AlarmState {
      typedef _CORBA_ConstrType_Variable_Var<AlarmState> _var_type;

      
      ::CORBA::ULong stationId;

      ::CORBA::ULong eventId;

      ::CORBA::String_member alarmType;

      ::CORBA::ULong entityKey;

      ::CORBA::String_member alarmID;

      ::CORBA::ULong alarmLocationKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AlarmState::_var_type AlarmState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AlarmState,AlarmState_var > AlarmState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlarmState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlarmStack;

    class AlarmStack_var;

    class AlarmStack : public _CORBA_Unbounded_Sequence< AlarmState >  {
    public:
      typedef AlarmStack_var _var_type;
      inline AlarmStack() {}
      inline AlarmStack(const AlarmStack& _s)
        : _CORBA_Unbounded_Sequence< AlarmState > (_s) {}

      inline AlarmStack(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AlarmState > (_max) {}
      inline AlarmStack(_CORBA_ULong _max, _CORBA_ULong _len, AlarmState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AlarmState > (_max, _len, _val, _rel) {}

    

      inline AlarmStack& operator = (const AlarmStack& _s) {
        _CORBA_Unbounded_Sequence< AlarmState > ::operator=(_s);
        return *this;
      }
    };

    class AlarmStack_out;

    class AlarmStack_var {
    public:
      inline AlarmStack_var() : _pd_seq(0) {}
      inline AlarmStack_var(AlarmStack* _s) : _pd_seq(_s) {}
      inline AlarmStack_var(const AlarmStack_var& _s) {
        if( _s._pd_seq )  _pd_seq = new AlarmStack(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~AlarmStack_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline AlarmStack_var& operator = (AlarmStack* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AlarmStack_var& operator = (const AlarmStack_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new AlarmStack;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline AlarmState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AlarmStack* operator -> () { return _pd_seq; }
      inline const AlarmStack* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AlarmStack& () const { return *_pd_seq; }
#else
      inline operator const AlarmStack& () const { return *_pd_seq; }
      inline operator AlarmStack& () { return *_pd_seq; }
#endif
        
      inline const AlarmStack& in() const { return *_pd_seq; }
      inline AlarmStack&       inout()    { return *_pd_seq; }
      inline AlarmStack*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AlarmStack* _retn() { AlarmStack* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AlarmStack_out;
      
    private:
      AlarmStack* _pd_seq;
    };

    class AlarmStack_out {
    public:
      inline AlarmStack_out(AlarmStack*& _s) : _data(_s) { _data = 0; }
      inline AlarmStack_out(AlarmStack_var& _s)
        : _data(_s._pd_seq) { _s = (AlarmStack*) 0; }
      inline AlarmStack_out(const AlarmStack_out& _s) : _data(_s._data) {}
      inline AlarmStack_out& operator = (const AlarmStack_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AlarmStack_out& operator = (AlarmStack* _s) {
        _data = _s;
        return *this;
      }
      inline operator AlarmStack*&()  { return _data; }
      inline AlarmStack*& ptr()       { return _data; }
      inline AlarmStack* operator->() { return _data; }

      inline AlarmState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AlarmStack*& _data;

    private:
      AlarmStack_out();
      AlarmStack_out& operator=(const AlarmStack_var&);
    };

    struct CameraInfo {
      typedef _CORBA_ConstrType_Variable_Var<CameraInfo> _var_type;

      
      ::CORBA::ULong key;

      ::CORBA::String_member name;

      ::CORBA::String_member description;

      ::CORBA::String_member groupName;

      ::CORBA::String_member address;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef CameraInfo::_var_type CameraInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< CameraInfo,CameraInfo_var > CameraInfo_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CameraInfo;

    struct SequenceInfo {
      typedef _CORBA_ConstrType_Variable_Var<SequenceInfo> _var_type;

      
      ::CORBA::ULong key;

      ::CORBA::String_member name;

      ::CORBA::String_member description;

      ::CORBA::String_member groupName;

      ::CORBA::Boolean isReadOnly;

      ::CORBA::String_member sequenceDescription;

      SequenceCorbaDef::SequenceConfig sequenceConfig;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SequenceInfo::_var_type SequenceInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SequenceInfo,SequenceInfo_var > SequenceInfo_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceInfo;

    struct MonitorInfo {
      typedef _CORBA_ConstrType_Variable_Var<MonitorInfo> _var_type;

      
      ::CORBA::ULong key;

      ::CORBA::String_member name;

      ::CORBA::String_member description;

      ::CORBA::String_member address;

      ::CORBA::ULong displayOrder;

      ::CORBA::ULong consoleKey;

      ::CORBA::Boolean isOverall;

      VideoOutputCorbaDef::VideoOutputState outputState;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef MonitorInfo::_var_type MonitorInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< MonitorInfo,MonitorInfo_var > MonitorInfo_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MonitorInfo;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CameraInfoSequence;

    class CameraInfoSequence_var;

    class CameraInfoSequence : public _CORBA_Unbounded_Sequence< CameraInfo >  {
    public:
      typedef CameraInfoSequence_var _var_type;
      inline CameraInfoSequence() {}
      inline CameraInfoSequence(const CameraInfoSequence& _s)
        : _CORBA_Unbounded_Sequence< CameraInfo > (_s) {}

      inline CameraInfoSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< CameraInfo > (_max) {}
      inline CameraInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, CameraInfo* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< CameraInfo > (_max, _len, _val, _rel) {}

    

      inline CameraInfoSequence& operator = (const CameraInfoSequence& _s) {
        _CORBA_Unbounded_Sequence< CameraInfo > ::operator=(_s);
        return *this;
      }
    };

    class CameraInfoSequence_out;

    class CameraInfoSequence_var {
    public:
      inline CameraInfoSequence_var() : _pd_seq(0) {}
      inline CameraInfoSequence_var(CameraInfoSequence* _s) : _pd_seq(_s) {}
      inline CameraInfoSequence_var(const CameraInfoSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CameraInfoSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CameraInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CameraInfoSequence_var& operator = (CameraInfoSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CameraInfoSequence_var& operator = (const CameraInfoSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CameraInfoSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline CameraInfo& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CameraInfoSequence* operator -> () { return _pd_seq; }
      inline const CameraInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CameraInfoSequence& () const { return *_pd_seq; }
#else
      inline operator const CameraInfoSequence& () const { return *_pd_seq; }
      inline operator CameraInfoSequence& () { return *_pd_seq; }
#endif
        
      inline const CameraInfoSequence& in() const { return *_pd_seq; }
      inline CameraInfoSequence&       inout()    { return *_pd_seq; }
      inline CameraInfoSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CameraInfoSequence* _retn() { CameraInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CameraInfoSequence_out;
      
    private:
      CameraInfoSequence* _pd_seq;
    };

    class CameraInfoSequence_out {
    public:
      inline CameraInfoSequence_out(CameraInfoSequence*& _s) : _data(_s) { _data = 0; }
      inline CameraInfoSequence_out(CameraInfoSequence_var& _s)
        : _data(_s._pd_seq) { _s = (CameraInfoSequence*) 0; }
      inline CameraInfoSequence_out(const CameraInfoSequence_out& _s) : _data(_s._data) {}
      inline CameraInfoSequence_out& operator = (const CameraInfoSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CameraInfoSequence_out& operator = (CameraInfoSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator CameraInfoSequence*&()  { return _data; }
      inline CameraInfoSequence*& ptr()       { return _data; }
      inline CameraInfoSequence* operator->() { return _data; }

      inline CameraInfo& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CameraInfoSequence*& _data;

    private:
      CameraInfoSequence_out();
      CameraInfoSequence_out& operator=(const CameraInfoSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceInfoSequence;

    class SequenceInfoSequence_var;

    class SequenceInfoSequence : public _CORBA_Unbounded_Sequence< SequenceInfo >  {
    public:
      typedef SequenceInfoSequence_var _var_type;
      inline SequenceInfoSequence() {}
      inline SequenceInfoSequence(const SequenceInfoSequence& _s)
        : _CORBA_Unbounded_Sequence< SequenceInfo > (_s) {}

      inline SequenceInfoSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SequenceInfo > (_max) {}
      inline SequenceInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, SequenceInfo* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SequenceInfo > (_max, _len, _val, _rel) {}

    

      inline SequenceInfoSequence& operator = (const SequenceInfoSequence& _s) {
        _CORBA_Unbounded_Sequence< SequenceInfo > ::operator=(_s);
        return *this;
      }
    };

    class SequenceInfoSequence_out;

    class SequenceInfoSequence_var {
    public:
      inline SequenceInfoSequence_var() : _pd_seq(0) {}
      inline SequenceInfoSequence_var(SequenceInfoSequence* _s) : _pd_seq(_s) {}
      inline SequenceInfoSequence_var(const SequenceInfoSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SequenceInfoSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SequenceInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SequenceInfoSequence_var& operator = (SequenceInfoSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SequenceInfoSequence_var& operator = (const SequenceInfoSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SequenceInfoSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SequenceInfo& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SequenceInfoSequence* operator -> () { return _pd_seq; }
      inline const SequenceInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SequenceInfoSequence& () const { return *_pd_seq; }
#else
      inline operator const SequenceInfoSequence& () const { return *_pd_seq; }
      inline operator SequenceInfoSequence& () { return *_pd_seq; }
#endif
        
      inline const SequenceInfoSequence& in() const { return *_pd_seq; }
      inline SequenceInfoSequence&       inout()    { return *_pd_seq; }
      inline SequenceInfoSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SequenceInfoSequence* _retn() { SequenceInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SequenceInfoSequence_out;
      
    private:
      SequenceInfoSequence* _pd_seq;
    };

    class SequenceInfoSequence_out {
    public:
      inline SequenceInfoSequence_out(SequenceInfoSequence*& _s) : _data(_s) { _data = 0; }
      inline SequenceInfoSequence_out(SequenceInfoSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SequenceInfoSequence*) 0; }
      inline SequenceInfoSequence_out(const SequenceInfoSequence_out& _s) : _data(_s._data) {}
      inline SequenceInfoSequence_out& operator = (const SequenceInfoSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SequenceInfoSequence_out& operator = (SequenceInfoSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SequenceInfoSequence*&()  { return _data; }
      inline SequenceInfoSequence*& ptr()       { return _data; }
      inline SequenceInfoSequence* operator->() { return _data; }

      inline SequenceInfo& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SequenceInfoSequence*& _data;

    private:
      SequenceInfoSequence_out();
      SequenceInfoSequence_out& operator=(const SequenceInfoSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MonitorInfoSequence;

    class MonitorInfoSequence_var;

    class MonitorInfoSequence : public _CORBA_Unbounded_Sequence< MonitorInfo >  {
    public:
      typedef MonitorInfoSequence_var _var_type;
      inline MonitorInfoSequence() {}
      inline MonitorInfoSequence(const MonitorInfoSequence& _s)
        : _CORBA_Unbounded_Sequence< MonitorInfo > (_s) {}

      inline MonitorInfoSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< MonitorInfo > (_max) {}
      inline MonitorInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, MonitorInfo* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< MonitorInfo > (_max, _len, _val, _rel) {}

    

      inline MonitorInfoSequence& operator = (const MonitorInfoSequence& _s) {
        _CORBA_Unbounded_Sequence< MonitorInfo > ::operator=(_s);
        return *this;
      }
    };

    class MonitorInfoSequence_out;

    class MonitorInfoSequence_var {
    public:
      inline MonitorInfoSequence_var() : _pd_seq(0) {}
      inline MonitorInfoSequence_var(MonitorInfoSequence* _s) : _pd_seq(_s) {}
      inline MonitorInfoSequence_var(const MonitorInfoSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new MonitorInfoSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~MonitorInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline MonitorInfoSequence_var& operator = (MonitorInfoSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline MonitorInfoSequence_var& operator = (const MonitorInfoSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new MonitorInfoSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline MonitorInfo& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline MonitorInfoSequence* operator -> () { return _pd_seq; }
      inline const MonitorInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator MonitorInfoSequence& () const { return *_pd_seq; }
#else
      inline operator const MonitorInfoSequence& () const { return *_pd_seq; }
      inline operator MonitorInfoSequence& () { return *_pd_seq; }
#endif
        
      inline const MonitorInfoSequence& in() const { return *_pd_seq; }
      inline MonitorInfoSequence&       inout()    { return *_pd_seq; }
      inline MonitorInfoSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline MonitorInfoSequence* _retn() { MonitorInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class MonitorInfoSequence_out;
      
    private:
      MonitorInfoSequence* _pd_seq;
    };

    class MonitorInfoSequence_out {
    public:
      inline MonitorInfoSequence_out(MonitorInfoSequence*& _s) : _data(_s) { _data = 0; }
      inline MonitorInfoSequence_out(MonitorInfoSequence_var& _s)
        : _data(_s._pd_seq) { _s = (MonitorInfoSequence*) 0; }
      inline MonitorInfoSequence_out(const MonitorInfoSequence_out& _s) : _data(_s._data) {}
      inline MonitorInfoSequence_out& operator = (const MonitorInfoSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline MonitorInfoSequence_out& operator = (MonitorInfoSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator MonitorInfoSequence*&()  { return _data; }
      inline MonitorInfoSequence*& ptr()       { return _data; }
      inline MonitorInfoSequence* operator->() { return _data; }

      inline MonitorInfo& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      MonitorInfoSequence*& _data;

    private:
      MonitorInfoSequence_out();
      MonitorInfoSequence_out& operator=(const MonitorInfoSequence_var&);
    };

    struct VideoObjectsInfo {
      typedef _CORBA_ConstrType_Variable_Var<VideoObjectsInfo> _var_type;

      
      CameraInfoSequence camerasInfo;

      SequenceInfoSequence sequencesInfo;

      MonitorInfoSequence monitorsInfo;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef VideoObjectsInfo::_var_type VideoObjectsInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< VideoObjectsInfo,VideoObjectsInfo_var > VideoObjectsInfo_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VideoObjectsInfo;

  
  };

  class _objref_SwitchManagerCorbaDef :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    SwitchManagerCorbaDef::VideoObjectsInfo* getVideoObjectsInfo();
    SwitchManagerCorbaDef::VideoMonitorSequence* getVideoMonitors();
    VideoMonitorCorbaDef_ptr getVideoMonitor(::CORBA::ULong entityKey);
    SwitchManagerCorbaDef::VideoMonitorSequence* getAllConsoleMonitors();
    SwitchManagerCorbaDef::VideoMonitorSequence* getConsoleMonitors(::CORBA::ULong consoleKey);
    SwitchManagerCorbaDef::CameraSequence* getCameras();
    CameraCorbaDef_ptr getCamera(::CORBA::ULong entityKey);
    SwitchManagerCorbaDef::SequenceSequence* getSequences();
    SequenceCorbaDef_ptr getSequence(::CORBA::ULong entityKey);
    SwitchManagerCorbaDef::VideoOutputSequence* getVideoOutputs();
    VideoOutputCorbaDef_ptr getVideoOutput(::CORBA::ULong entityKey);
    SwitchManagerCorbaDef::VideoInputSequence* getVideoInputs();
    VideoInputCorbaDef_ptr getVideoInput(::CORBA::ULong entityKey);
    void processAlarmStack(const ::TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence& alarms, ::CORBA::Boolean bOpen);
    void acknowledgeAlarm(const ::TA_Base_Core::AlarmDetailCorbaDef& pAlarmDetail, ::CORBA::ULong consoleId);
    void acknowledgeTrainCameraAlarm(::CORBA::ULong locationId, ::CORBA::ULong trainId, const ::TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence& cameraIds, ::CORBA::ULong consoleId);
    void setStageSwitchMode(::CORBA::ULong originatingStage, ::CORBA::ULong destinationStage, ::CORBA::Boolean allowSwitch);
    void closeAlarm(const ::TA_Base_Core::AlarmDetailCorbaDef& pAlarmDetail);
    void clearAllMonitorsWithInput(::CORBA::ULong inputEntityKey, const char* sessionId);

    inline _objref_SwitchManagerCorbaDef()  { _PR_setobj(0); }  // nil
    _objref_SwitchManagerCorbaDef(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SwitchManagerCorbaDef();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SwitchManagerCorbaDef(const _objref_SwitchManagerCorbaDef&);
    _objref_SwitchManagerCorbaDef& operator = (const _objref_SwitchManagerCorbaDef&);
    // not implemented

    friend class SwitchManagerCorbaDef;
  };

  class _pof_SwitchManagerCorbaDef : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SwitchManagerCorbaDef() : _OMNI_NS(proxyObjectFactory)(SwitchManagerCorbaDef::_PD_repoId) {}
    virtual ~_pof_SwitchManagerCorbaDef();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SwitchManagerCorbaDef :
    public virtual omniServant
  {
  public:
    virtual ~_impl_SwitchManagerCorbaDef();

    virtual SwitchManagerCorbaDef::VideoObjectsInfo* getVideoObjectsInfo() = 0;
    virtual SwitchManagerCorbaDef::VideoMonitorSequence* getVideoMonitors() = 0;
    virtual VideoMonitorCorbaDef_ptr getVideoMonitor(::CORBA::ULong entityKey) = 0;
    virtual SwitchManagerCorbaDef::VideoMonitorSequence* getAllConsoleMonitors() = 0;
    virtual SwitchManagerCorbaDef::VideoMonitorSequence* getConsoleMonitors(::CORBA::ULong consoleKey) = 0;
    virtual SwitchManagerCorbaDef::CameraSequence* getCameras() = 0;
    virtual CameraCorbaDef_ptr getCamera(::CORBA::ULong entityKey) = 0;
    virtual SwitchManagerCorbaDef::SequenceSequence* getSequences() = 0;
    virtual SequenceCorbaDef_ptr getSequence(::CORBA::ULong entityKey) = 0;
    virtual SwitchManagerCorbaDef::VideoOutputSequence* getVideoOutputs() = 0;
    virtual VideoOutputCorbaDef_ptr getVideoOutput(::CORBA::ULong entityKey) = 0;
    virtual SwitchManagerCorbaDef::VideoInputSequence* getVideoInputs() = 0;
    virtual VideoInputCorbaDef_ptr getVideoInput(::CORBA::ULong entityKey) = 0;
    virtual void processAlarmStack(const ::TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence& alarms, ::CORBA::Boolean bOpen) = 0;
    virtual void acknowledgeAlarm(const ::TA_Base_Core::AlarmDetailCorbaDef& pAlarmDetail, ::CORBA::ULong consoleId) = 0;
    virtual void acknowledgeTrainCameraAlarm(::CORBA::ULong locationId, ::CORBA::ULong trainId, const ::TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence& cameraIds, ::CORBA::ULong consoleId) = 0;
    virtual void setStageSwitchMode(::CORBA::ULong originatingStage, ::CORBA::ULong destinationStage, ::CORBA::Boolean allowSwitch) = 0;
    virtual void closeAlarm(const ::TA_Base_Core::AlarmDetailCorbaDef& pAlarmDetail) = 0;
    virtual void clearAllMonitorsWithInput(::CORBA::ULong inputEntityKey, const char* sessionId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SwitchManagerCorbaDef;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  class SwitchManagerCorbaDef :
    public virtual TA_Base_Bus::_impl_SwitchManagerCorbaDef,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~SwitchManagerCorbaDef();

    inline ::TA_Base_Bus::SwitchManagerCorbaDef_ptr _this() {
      return (::TA_Base_Bus::SwitchManagerCorbaDef_ptr) _do_this(::TA_Base_Bus::SwitchManagerCorbaDef::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputGroupSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputGroupSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputGroupSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputGroupSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoMonitorSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoMonitorSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoMonitorSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoMonitorSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::RecordingUnitSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::RecordingUnitSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::RecordingUnitSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::RecordingUnitSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoOutputSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoInputSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoInputSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoInputSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoInputSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TrainCameraSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarm& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarm* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarm*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarm*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::TriggerAlarmSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::AlarmState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::AlarmState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::AlarmState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::AlarmState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::AlarmStack& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::AlarmStack* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::AlarmStack*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::AlarmStack*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraInfo& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraInfo*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfo& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfo*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfo& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::CameraInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::CameraInfoSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::SequenceInfoSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::MonitorInfoSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoObjectsInfo& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoObjectsInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef::VideoObjectsInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::SwitchManagerCorbaDef::VideoObjectsInfo*& _sp);

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef_ptr _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::SwitchManagerCorbaDef_ptr& _s);



inline void
TA_Base_Bus::SwitchManagerCorbaDef::_marshalObjRef(::TA_Base_Bus::SwitchManagerCorbaDef_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_SwitchManagerCorbaDef
#endif

#endif  // __SwitchManagerCorbaDef_hh__

