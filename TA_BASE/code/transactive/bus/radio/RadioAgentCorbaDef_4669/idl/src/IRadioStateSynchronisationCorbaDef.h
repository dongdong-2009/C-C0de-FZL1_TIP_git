// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __IRadioStateSynchronisationCorbaDef_hh__
#define __IRadioStateSynchronisationCorbaDef_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif



#ifndef __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <CommonExceptionsCorbaDef.h>
#endif
#ifndef __IRadioCorbaDef_hh_EXTERNAL_GUARD__
#define __IRadioCorbaDef_hh_EXTERNAL_GUARD__
#include <IRadioCorbaDef.h>
#endif
#ifndef __IRadioSessionCorbaDef_hh_EXTERNAL_GUARD__
#define __IRadioSessionCorbaDef_hh_EXTERNAL_GUARD__
#include <IRadioSessionCorbaDef.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

#ifndef __TA__Base__Bus_mIRadioStateSynchronisationCorbaDef__
#define __TA__Base__Bus_mIRadioStateSynchronisationCorbaDef__

  class IRadioStateSynchronisationCorbaDef;
  class _objref_IRadioStateSynchronisationCorbaDef;
  class _impl_IRadioStateSynchronisationCorbaDef;
  
  typedef _objref_IRadioStateSynchronisationCorbaDef* IRadioStateSynchronisationCorbaDef_ptr;
  typedef IRadioStateSynchronisationCorbaDef_ptr IRadioStateSynchronisationCorbaDefRef;

  class IRadioStateSynchronisationCorbaDef_Helper {
  public:
    typedef IRadioStateSynchronisationCorbaDef_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_IRadioStateSynchronisationCorbaDef, IRadioStateSynchronisationCorbaDef_Helper> IRadioStateSynchronisationCorbaDef_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_IRadioStateSynchronisationCorbaDef,IRadioStateSynchronisationCorbaDef_Helper > IRadioStateSynchronisationCorbaDef_out;

#endif

  // interface IRadioStateSynchronisationCorbaDef
  class IRadioStateSynchronisationCorbaDef {
  public:
    // Declarations for this interface type.
    typedef IRadioStateSynchronisationCorbaDef_ptr _ptr_type;
    typedef IRadioStateSynchronisationCorbaDef_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct AuthorisationRequestType {
      typedef _CORBA_ConstrType_Variable_Var<AuthorisationRequestType> _var_type;

      
      IRadioCorbaDef::CallID callID;

      IRadioCorbaDef::SessionReference sessionRef;

      ::CORBA::ULong consoleKey;

      IRadioSessionCorbaDef::ERadioUserType sourceType;

      IRadioSessionCorbaDef::ERadioUserType destinationType;

      ::CORBA::String_member callerName;

      ::CORBA::String_member calledName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AuthorisationRequestType::_var_type AuthorisationRequestType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AuthorisationRequestType,AuthorisationRequestType_var > AuthorisationRequestType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AuthorisationRequestType;

    struct AudioEntry {
      typedef _CORBA_ConstrType_Fix_Var<AudioEntry> _var_type;

      
      IRadioCorbaDef::CallReference callRef;

      ::CORBA::Boolean inUse;

      ::CORBA::Long volume;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AudioEntry::_var_type AudioEntry_var;

    typedef AudioEntry& AudioEntry_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AudioEntry;

    enum ESessionState { SessionUnassigned, SessionAssigned, SessionInitialised, SessionLoggedIn /*, __max_ESessionState=0xffffffff */ };
    typedef ESessionState& ESessionState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ESessionState;

    struct RadioSessionType {
      typedef _CORBA_ConstrType_Variable_Var<RadioSessionType> _var_type;

      
      ::CORBA::ULong audioLink;

      IRadioCorbaDef::SessionReference sessionRef;

      ::CORBA::ULong consoleKey;

      ::CORBA::String_member sessionEntityName;

      ::CORBA::String_member loginName;

      ::CORBA::String_member loginPassword;

      ::CORBA::String_member subscriberTextRef;

      ::CORBA::String_member sessionDGNAITSI;

      ::CORBA::Boolean sessionDGNAInUse;

      ESessionState sessionStatus;

      ::CORBA::String_member sessionITSI;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioSessionType::_var_type RadioSessionType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioSessionType,RadioSessionType_var > RadioSessionType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioSessionType;

    struct RadioSessionServantType {
      typedef _CORBA_ConstrType_Variable_Var<RadioSessionServantType> _var_type;

      
      ::CORBA::ULong entityKey;

      RadioSessionType radioSession;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioSessionServantType::_var_type RadioSessionServantType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioSessionServantType,RadioSessionServantType_var > RadioSessionServantType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioSessionServantType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioSessionServantTypeList;

    class RadioSessionServantTypeList_var;

    class RadioSessionServantTypeList : public _CORBA_Unbounded_Sequence< RadioSessionServantType >  {
    public:
      typedef RadioSessionServantTypeList_var _var_type;
      inline RadioSessionServantTypeList() {}
      inline RadioSessionServantTypeList(const RadioSessionServantTypeList& _s)
        : _CORBA_Unbounded_Sequence< RadioSessionServantType > (_s) {}

      inline RadioSessionServantTypeList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< RadioSessionServantType > (_max) {}
      inline RadioSessionServantTypeList(_CORBA_ULong _max, _CORBA_ULong _len, RadioSessionServantType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< RadioSessionServantType > (_max, _len, _val, _rel) {}

    

      inline RadioSessionServantTypeList& operator = (const RadioSessionServantTypeList& _s) {
        _CORBA_Unbounded_Sequence< RadioSessionServantType > ::operator=(_s);
        return *this;
      }
    };

    class RadioSessionServantTypeList_out;

    class RadioSessionServantTypeList_var {
    public:
      inline RadioSessionServantTypeList_var() : _pd_seq(0) {}
      inline RadioSessionServantTypeList_var(RadioSessionServantTypeList* _s) : _pd_seq(_s) {}
      inline RadioSessionServantTypeList_var(const RadioSessionServantTypeList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RadioSessionServantTypeList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RadioSessionServantTypeList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RadioSessionServantTypeList_var& operator = (RadioSessionServantTypeList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RadioSessionServantTypeList_var& operator = (const RadioSessionServantTypeList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RadioSessionServantTypeList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline RadioSessionServantType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RadioSessionServantTypeList* operator -> () { return _pd_seq; }
      inline const RadioSessionServantTypeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RadioSessionServantTypeList& () const { return *_pd_seq; }
#else
      inline operator const RadioSessionServantTypeList& () const { return *_pd_seq; }
      inline operator RadioSessionServantTypeList& () { return *_pd_seq; }
#endif
        
      inline const RadioSessionServantTypeList& in() const { return *_pd_seq; }
      inline RadioSessionServantTypeList&       inout()    { return *_pd_seq; }
      inline RadioSessionServantTypeList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RadioSessionServantTypeList* _retn() { RadioSessionServantTypeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RadioSessionServantTypeList_out;
      
    private:
      RadioSessionServantTypeList* _pd_seq;
    };

    class RadioSessionServantTypeList_out {
    public:
      inline RadioSessionServantTypeList_out(RadioSessionServantTypeList*& _s) : _data(_s) { _data = 0; }
      inline RadioSessionServantTypeList_out(RadioSessionServantTypeList_var& _s)
        : _data(_s._pd_seq) { _s = (RadioSessionServantTypeList*) 0; }
      inline RadioSessionServantTypeList_out(const RadioSessionServantTypeList_out& _s) : _data(_s._data) {}
      inline RadioSessionServantTypeList_out& operator = (const RadioSessionServantTypeList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RadioSessionServantTypeList_out& operator = (RadioSessionServantTypeList* _s) {
        _data = _s;
        return *this;
      }
      inline operator RadioSessionServantTypeList*&()  { return _data; }
      inline RadioSessionServantTypeList*& ptr()       { return _data; }
      inline RadioSessionServantTypeList* operator->() { return _data; }

      inline RadioSessionServantType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RadioSessionServantTypeList*& _data;

    private:
      RadioSessionServantTypeList_out();
      RadioSessionServantTypeList_out& operator=(const RadioSessionServantTypeList_var&);
    };

    struct RadioUpdateCallInRadioCallStack {
      typedef _CORBA_ConstrType_Variable_Var<RadioUpdateCallInRadioCallStack> _var_type;

      
      IRadioCorbaDef::CallDetailsType callDetails;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateCallInRadioCallStack::_var_type RadioUpdateCallInRadioCallStack_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioUpdateCallInRadioCallStack,RadioUpdateCallInRadioCallStack_var > RadioUpdateCallInRadioCallStack_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateCallInRadioCallStack;

    struct RadioRemoveCallFromRadioCallStack {
      typedef _CORBA_ConstrType_Fix_Var<RadioRemoveCallFromRadioCallStack> _var_type;

      
      IRadioCorbaDef::CallID callID;

      ::CORBA::ULong consoleKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioRemoveCallFromRadioCallStack::_var_type RadioRemoveCallFromRadioCallStack_var;

    typedef RadioRemoveCallFromRadioCallStack& RadioRemoveCallFromRadioCallStack_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioRemoveCallFromRadioCallStack;

    struct RadioUpdateRadioSession {
      typedef _CORBA_ConstrType_Variable_Var<RadioUpdateRadioSession> _var_type;

      
      ::CORBA::ULong servantEntityKey;

      RadioSessionType radioSession;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateRadioSession::_var_type RadioUpdateRadioSession_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioUpdateRadioSession,RadioUpdateRadioSession_var > RadioUpdateRadioSession_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateRadioSession;

    struct RadioUpdateMonitoredCallProgression {
      typedef _CORBA_ConstrType_Fix_Var<RadioUpdateMonitoredCallProgression> _var_type;

      
      IRadioCorbaDef::MonitorReference monitorReference;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateMonitoredCallProgression::_var_type RadioUpdateMonitoredCallProgression_var;

    typedef RadioUpdateMonitoredCallProgression& RadioUpdateMonitoredCallProgression_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateMonitoredCallProgression;

    struct RadioRemoveMonitoredSubscriberDetails {
      typedef _CORBA_ConstrType_Fix_Var<RadioRemoveMonitoredSubscriberDetails> _var_type;

      
      IRadioCorbaDef::MonitorReference monitorReference;

      ::CORBA::Long serverIndex;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioRemoveMonitoredSubscriberDetails::_var_type RadioRemoveMonitoredSubscriberDetails_var;

    typedef RadioRemoveMonitoredSubscriberDetails& RadioRemoveMonitoredSubscriberDetails_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioRemoveMonitoredSubscriberDetails;

    struct RadioRemoveSessionFromAudioMap {
      typedef _CORBA_ConstrType_Fix_Var<RadioRemoveSessionFromAudioMap> _var_type;

      
      IRadioCorbaDef::SessionReference sessionReference;

      ::CORBA::Long serverIndex;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioRemoveSessionFromAudioMap::_var_type RadioRemoveSessionFromAudioMap_var;

    typedef RadioRemoveSessionFromAudioMap& RadioRemoveSessionFromAudioMap_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioRemoveSessionFromAudioMap;

    struct RadioUpdateAudioEntryInSessionAudioMap {
      typedef _CORBA_ConstrType_Fix_Var<RadioUpdateAudioEntryInSessionAudioMap> _var_type;

      
      IRadioCorbaDef::SessionReference sessionReference;

      IRadioCorbaDef::AudioReference audioReference;

      AudioEntry audio;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateAudioEntryInSessionAudioMap::_var_type RadioUpdateAudioEntryInSessionAudioMap_var;

    typedef RadioUpdateAudioEntryInSessionAudioMap& RadioUpdateAudioEntryInSessionAudioMap_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateAudioEntryInSessionAudioMap;

    struct RadioUpdateRadioResourceManagerVars {
      typedef _CORBA_ConstrType_Fix_Var<RadioUpdateRadioResourceManagerVars> _var_type;

      
      IRadioCorbaDef::SessionReference sessionReference;

      IRadioCorbaDef::CallReference callReference;

      ::CORBA::Long currrentVolume;

      ::CORBA::Long serverIndex;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateRadioResourceManagerVars::_var_type RadioUpdateRadioResourceManagerVars_var;

    typedef RadioUpdateRadioResourceManagerVars& RadioUpdateRadioResourceManagerVars_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateRadioResourceManagerVars;

    struct RadioUpdateAuthorisationRequest {
      typedef _CORBA_ConstrType_Variable_Var<RadioUpdateAuthorisationRequest> _var_type;

      
      AuthorisationRequestType autorisationRequest;

      ::CORBA::Long serverIndex;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioUpdateAuthorisationRequest::_var_type RadioUpdateAuthorisationRequest_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioUpdateAuthorisationRequest,RadioUpdateAuthorisationRequest_var > RadioUpdateAuthorisationRequest_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioUpdateAuthorisationRequest;

    struct RadioRemoveAuthorisationRequest {
      typedef _CORBA_ConstrType_Fix_Var<RadioRemoveAuthorisationRequest> _var_type;

      
      IRadioCorbaDef::CallID callID;

      ::CORBA::Long serverIndex;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioRemoveAuthorisationRequest::_var_type RadioRemoveAuthorisationRequest_var;

    typedef RadioRemoveAuthorisationRequest& RadioRemoveAuthorisationRequest_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioRemoveAuthorisationRequest;

    struct RadioConnectionSwitchRequest {
      typedef _CORBA_ConstrType_Fix_Var<RadioConnectionSwitchRequest> _var_type;

      
      ::CORBA::ULong TCPServerIndex;

      IRadioCorbaDef::EControlConnectionStatus controlConnectionStatus;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioConnectionSwitchRequest::_var_type RadioConnectionSwitchRequest_var;

    typedef RadioConnectionSwitchRequest& RadioConnectionSwitchRequest_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioConnectionSwitchRequest;

    struct MonitoredSubscriberDetailsType {
      typedef _CORBA_ConstrType_Fix_Var<MonitoredSubscriberDetailsType> _var_type;

      
      ::CORBA::ULong monitorReference;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef MonitoredSubscriberDetailsType::_var_type MonitoredSubscriberDetailsType_var;

    typedef MonitoredSubscriberDetailsType& MonitoredSubscriberDetailsType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MonitoredSubscriberDetailsType;

    struct MonitoredSubscriberDetailsTypeAndRef {
      typedef _CORBA_ConstrType_Fix_Var<MonitoredSubscriberDetailsTypeAndRef> _var_type;

      
      ::CORBA::ULong monitoredSubscriberDetailsRef;

      MonitoredSubscriberDetailsType monitoredSubscriberDetails;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef MonitoredSubscriberDetailsTypeAndRef::_var_type MonitoredSubscriberDetailsTypeAndRef_var;

    typedef MonitoredSubscriberDetailsTypeAndRef& MonitoredSubscriberDetailsTypeAndRef_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MonitoredSubscriberDetailsTypeAndRef;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MonitoredSubscriberDetailsTypeAndRefList;

    class MonitoredSubscriberDetailsTypeAndRefList_var;

    class MonitoredSubscriberDetailsTypeAndRefList : public _CORBA_Unbounded_Sequence< MonitoredSubscriberDetailsTypeAndRef >  {
    public:
      typedef MonitoredSubscriberDetailsTypeAndRefList_var _var_type;
      inline MonitoredSubscriberDetailsTypeAndRefList() {}
      inline MonitoredSubscriberDetailsTypeAndRefList(const MonitoredSubscriberDetailsTypeAndRefList& _s)
        : _CORBA_Unbounded_Sequence< MonitoredSubscriberDetailsTypeAndRef > (_s) {}

      inline MonitoredSubscriberDetailsTypeAndRefList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< MonitoredSubscriberDetailsTypeAndRef > (_max) {}
      inline MonitoredSubscriberDetailsTypeAndRefList(_CORBA_ULong _max, _CORBA_ULong _len, MonitoredSubscriberDetailsTypeAndRef* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< MonitoredSubscriberDetailsTypeAndRef > (_max, _len, _val, _rel) {}

    

      inline MonitoredSubscriberDetailsTypeAndRefList& operator = (const MonitoredSubscriberDetailsTypeAndRefList& _s) {
        _CORBA_Unbounded_Sequence< MonitoredSubscriberDetailsTypeAndRef > ::operator=(_s);
        return *this;
      }
    };

    class MonitoredSubscriberDetailsTypeAndRefList_out;

    class MonitoredSubscriberDetailsTypeAndRefList_var {
    public:
      inline MonitoredSubscriberDetailsTypeAndRefList_var() : _pd_seq(0) {}
      inline MonitoredSubscriberDetailsTypeAndRefList_var(MonitoredSubscriberDetailsTypeAndRefList* _s) : _pd_seq(_s) {}
      inline MonitoredSubscriberDetailsTypeAndRefList_var(const MonitoredSubscriberDetailsTypeAndRefList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new MonitoredSubscriberDetailsTypeAndRefList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~MonitoredSubscriberDetailsTypeAndRefList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline MonitoredSubscriberDetailsTypeAndRefList_var& operator = (MonitoredSubscriberDetailsTypeAndRefList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline MonitoredSubscriberDetailsTypeAndRefList_var& operator = (const MonitoredSubscriberDetailsTypeAndRefList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new MonitoredSubscriberDetailsTypeAndRefList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline MonitoredSubscriberDetailsTypeAndRef& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline MonitoredSubscriberDetailsTypeAndRefList* operator -> () { return _pd_seq; }
      inline const MonitoredSubscriberDetailsTypeAndRefList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator MonitoredSubscriberDetailsTypeAndRefList& () const { return *_pd_seq; }
#else
      inline operator const MonitoredSubscriberDetailsTypeAndRefList& () const { return *_pd_seq; }
      inline operator MonitoredSubscriberDetailsTypeAndRefList& () { return *_pd_seq; }
#endif
        
      inline const MonitoredSubscriberDetailsTypeAndRefList& in() const { return *_pd_seq; }
      inline MonitoredSubscriberDetailsTypeAndRefList&       inout()    { return *_pd_seq; }
      inline MonitoredSubscriberDetailsTypeAndRefList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline MonitoredSubscriberDetailsTypeAndRefList* _retn() { MonitoredSubscriberDetailsTypeAndRefList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class MonitoredSubscriberDetailsTypeAndRefList_out;
      
    private:
      MonitoredSubscriberDetailsTypeAndRefList* _pd_seq;
    };

    class MonitoredSubscriberDetailsTypeAndRefList_out {
    public:
      inline MonitoredSubscriberDetailsTypeAndRefList_out(MonitoredSubscriberDetailsTypeAndRefList*& _s) : _data(_s) { _data = 0; }
      inline MonitoredSubscriberDetailsTypeAndRefList_out(MonitoredSubscriberDetailsTypeAndRefList_var& _s)
        : _data(_s._pd_seq) { _s = (MonitoredSubscriberDetailsTypeAndRefList*) 0; }
      inline MonitoredSubscriberDetailsTypeAndRefList_out(const MonitoredSubscriberDetailsTypeAndRefList_out& _s) : _data(_s._data) {}
      inline MonitoredSubscriberDetailsTypeAndRefList_out& operator = (const MonitoredSubscriberDetailsTypeAndRefList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline MonitoredSubscriberDetailsTypeAndRefList_out& operator = (MonitoredSubscriberDetailsTypeAndRefList* _s) {
        _data = _s;
        return *this;
      }
      inline operator MonitoredSubscriberDetailsTypeAndRefList*&()  { return _data; }
      inline MonitoredSubscriberDetailsTypeAndRefList*& ptr()       { return _data; }
      inline MonitoredSubscriberDetailsTypeAndRefList* operator->() { return _data; }

      inline MonitoredSubscriberDetailsTypeAndRef& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      MonitoredSubscriberDetailsTypeAndRefList*& _data;

    private:
      MonitoredSubscriberDetailsTypeAndRefList_out();
      MonitoredSubscriberDetailsTypeAndRefList_out& operator=(const MonitoredSubscriberDetailsTypeAndRefList_var&);
    };

    struct RadioMonitorManagerType {
      typedef _CORBA_ConstrType_Variable_Var<RadioMonitorManagerType> _var_type;

      
      MonitoredSubscriberDetailsTypeAndRefList monitoredSubscriberDetailsAndRefList;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioMonitorManagerType::_var_type RadioMonitorManagerType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioMonitorManagerType,RadioMonitorManagerType_var > RadioMonitorManagerType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioMonitorManagerType;

    struct AudioEntryMap {
      typedef _CORBA_ConstrType_Fix_Var<AudioEntryMap> _var_type;

      
      IRadioCorbaDef::AudioReference audioRef;

      AudioEntry audio;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AudioEntryMap::_var_type AudioEntryMap_var;

    typedef AudioEntryMap& AudioEntryMap_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AudioEntryMap;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AudioEntryMapType;

    class AudioEntryMapType_var;

    class AudioEntryMapType : public _CORBA_Unbounded_Sequence< AudioEntryMap >  {
    public:
      typedef AudioEntryMapType_var _var_type;
      inline AudioEntryMapType() {}
      inline AudioEntryMapType(const AudioEntryMapType& _s)
        : _CORBA_Unbounded_Sequence< AudioEntryMap > (_s) {}

      inline AudioEntryMapType(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AudioEntryMap > (_max) {}
      inline AudioEntryMapType(_CORBA_ULong _max, _CORBA_ULong _len, AudioEntryMap* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AudioEntryMap > (_max, _len, _val, _rel) {}

    

      inline AudioEntryMapType& operator = (const AudioEntryMapType& _s) {
        _CORBA_Unbounded_Sequence< AudioEntryMap > ::operator=(_s);
        return *this;
      }
    };

    class AudioEntryMapType_out;

    class AudioEntryMapType_var {
    public:
      inline AudioEntryMapType_var() : _pd_seq(0) {}
      inline AudioEntryMapType_var(AudioEntryMapType* _s) : _pd_seq(_s) {}
      inline AudioEntryMapType_var(const AudioEntryMapType_var& _s) {
        if( _s._pd_seq )  _pd_seq = new AudioEntryMapType(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~AudioEntryMapType_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline AudioEntryMapType_var& operator = (AudioEntryMapType* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AudioEntryMapType_var& operator = (const AudioEntryMapType_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new AudioEntryMapType;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline AudioEntryMap& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AudioEntryMapType* operator -> () { return _pd_seq; }
      inline const AudioEntryMapType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AudioEntryMapType& () const { return *_pd_seq; }
#else
      inline operator const AudioEntryMapType& () const { return *_pd_seq; }
      inline operator AudioEntryMapType& () { return *_pd_seq; }
#endif
        
      inline const AudioEntryMapType& in() const { return *_pd_seq; }
      inline AudioEntryMapType&       inout()    { return *_pd_seq; }
      inline AudioEntryMapType*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AudioEntryMapType* _retn() { AudioEntryMapType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AudioEntryMapType_out;
      
    private:
      AudioEntryMapType* _pd_seq;
    };

    class AudioEntryMapType_out {
    public:
      inline AudioEntryMapType_out(AudioEntryMapType*& _s) : _data(_s) { _data = 0; }
      inline AudioEntryMapType_out(AudioEntryMapType_var& _s)
        : _data(_s._pd_seq) { _s = (AudioEntryMapType*) 0; }
      inline AudioEntryMapType_out(const AudioEntryMapType_out& _s) : _data(_s._data) {}
      inline AudioEntryMapType_out& operator = (const AudioEntryMapType_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AudioEntryMapType_out& operator = (AudioEntryMapType* _s) {
        _data = _s;
        return *this;
      }
      inline operator AudioEntryMapType*&()  { return _data; }
      inline AudioEntryMapType*& ptr()       { return _data; }
      inline AudioEntryMapType* operator->() { return _data; }

      inline AudioEntryMap& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AudioEntryMapType*& _data;

    private:
      AudioEntryMapType_out();
      AudioEntryMapType_out& operator=(const AudioEntryMapType_var&);
    };

    struct SessionAudioMap {
      typedef _CORBA_ConstrType_Variable_Var<SessionAudioMap> _var_type;

      
      IRadioCorbaDef::SessionReference sessionRef;

      ::CORBA::ULong consoleKey;

      AudioEntryMapType audioEntryMap;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SessionAudioMap::_var_type SessionAudioMap_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SessionAudioMap,SessionAudioMap_var > SessionAudioMap_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SessionAudioMap;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SessionAudioMapType;

    class SessionAudioMapType_var;

    class SessionAudioMapType : public _CORBA_Unbounded_Sequence< SessionAudioMap >  {
    public:
      typedef SessionAudioMapType_var _var_type;
      inline SessionAudioMapType() {}
      inline SessionAudioMapType(const SessionAudioMapType& _s)
        : _CORBA_Unbounded_Sequence< SessionAudioMap > (_s) {}

      inline SessionAudioMapType(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SessionAudioMap > (_max) {}
      inline SessionAudioMapType(_CORBA_ULong _max, _CORBA_ULong _len, SessionAudioMap* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SessionAudioMap > (_max, _len, _val, _rel) {}

    

      inline SessionAudioMapType& operator = (const SessionAudioMapType& _s) {
        _CORBA_Unbounded_Sequence< SessionAudioMap > ::operator=(_s);
        return *this;
      }
    };

    class SessionAudioMapType_out;

    class SessionAudioMapType_var {
    public:
      inline SessionAudioMapType_var() : _pd_seq(0) {}
      inline SessionAudioMapType_var(SessionAudioMapType* _s) : _pd_seq(_s) {}
      inline SessionAudioMapType_var(const SessionAudioMapType_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SessionAudioMapType(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SessionAudioMapType_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SessionAudioMapType_var& operator = (SessionAudioMapType* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SessionAudioMapType_var& operator = (const SessionAudioMapType_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SessionAudioMapType;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SessionAudioMap& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SessionAudioMapType* operator -> () { return _pd_seq; }
      inline const SessionAudioMapType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SessionAudioMapType& () const { return *_pd_seq; }
#else
      inline operator const SessionAudioMapType& () const { return *_pd_seq; }
      inline operator SessionAudioMapType& () { return *_pd_seq; }
#endif
        
      inline const SessionAudioMapType& in() const { return *_pd_seq; }
      inline SessionAudioMapType&       inout()    { return *_pd_seq; }
      inline SessionAudioMapType*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SessionAudioMapType* _retn() { SessionAudioMapType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SessionAudioMapType_out;
      
    private:
      SessionAudioMapType* _pd_seq;
    };

    class SessionAudioMapType_out {
    public:
      inline SessionAudioMapType_out(SessionAudioMapType*& _s) : _data(_s) { _data = 0; }
      inline SessionAudioMapType_out(SessionAudioMapType_var& _s)
        : _data(_s._pd_seq) { _s = (SessionAudioMapType*) 0; }
      inline SessionAudioMapType_out(const SessionAudioMapType_out& _s) : _data(_s._data) {}
      inline SessionAudioMapType_out& operator = (const SessionAudioMapType_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SessionAudioMapType_out& operator = (SessionAudioMapType* _s) {
        _data = _s;
        return *this;
      }
      inline operator SessionAudioMapType*&()  { return _data; }
      inline SessionAudioMapType*& ptr()       { return _data; }
      inline SessionAudioMapType* operator->() { return _data; }

      inline SessionAudioMap& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SessionAudioMapType*& _data;

    private:
      SessionAudioMapType_out();
      SessionAudioMapType_out& operator=(const SessionAudioMapType_var&);
    };

    struct RadioResourceManagerType {
      typedef _CORBA_ConstrType_Variable_Var<RadioResourceManagerType> _var_type;

      
      ::CORBA::Long currentAudioVolume;

      SessionAudioMapType sessionAudioMap;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioResourceManagerType::_var_type RadioResourceManagerType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioResourceManagerType,RadioResourceManagerType_var > RadioResourceManagerType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioResourceManagerType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AuthorisationRequestTypeList;

    class AuthorisationRequestTypeList_var;

    class AuthorisationRequestTypeList : public _CORBA_Unbounded_Sequence< AuthorisationRequestType >  {
    public:
      typedef AuthorisationRequestTypeList_var _var_type;
      inline AuthorisationRequestTypeList() {}
      inline AuthorisationRequestTypeList(const AuthorisationRequestTypeList& _s)
        : _CORBA_Unbounded_Sequence< AuthorisationRequestType > (_s) {}

      inline AuthorisationRequestTypeList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AuthorisationRequestType > (_max) {}
      inline AuthorisationRequestTypeList(_CORBA_ULong _max, _CORBA_ULong _len, AuthorisationRequestType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AuthorisationRequestType > (_max, _len, _val, _rel) {}

    

      inline AuthorisationRequestTypeList& operator = (const AuthorisationRequestTypeList& _s) {
        _CORBA_Unbounded_Sequence< AuthorisationRequestType > ::operator=(_s);
        return *this;
      }
    };

    class AuthorisationRequestTypeList_out;

    class AuthorisationRequestTypeList_var {
    public:
      inline AuthorisationRequestTypeList_var() : _pd_seq(0) {}
      inline AuthorisationRequestTypeList_var(AuthorisationRequestTypeList* _s) : _pd_seq(_s) {}
      inline AuthorisationRequestTypeList_var(const AuthorisationRequestTypeList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new AuthorisationRequestTypeList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~AuthorisationRequestTypeList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline AuthorisationRequestTypeList_var& operator = (AuthorisationRequestTypeList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AuthorisationRequestTypeList_var& operator = (const AuthorisationRequestTypeList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new AuthorisationRequestTypeList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline AuthorisationRequestType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AuthorisationRequestTypeList* operator -> () { return _pd_seq; }
      inline const AuthorisationRequestTypeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AuthorisationRequestTypeList& () const { return *_pd_seq; }
#else
      inline operator const AuthorisationRequestTypeList& () const { return *_pd_seq; }
      inline operator AuthorisationRequestTypeList& () { return *_pd_seq; }
#endif
        
      inline const AuthorisationRequestTypeList& in() const { return *_pd_seq; }
      inline AuthorisationRequestTypeList&       inout()    { return *_pd_seq; }
      inline AuthorisationRequestTypeList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AuthorisationRequestTypeList* _retn() { AuthorisationRequestTypeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AuthorisationRequestTypeList_out;
      
    private:
      AuthorisationRequestTypeList* _pd_seq;
    };

    class AuthorisationRequestTypeList_out {
    public:
      inline AuthorisationRequestTypeList_out(AuthorisationRequestTypeList*& _s) : _data(_s) { _data = 0; }
      inline AuthorisationRequestTypeList_out(AuthorisationRequestTypeList_var& _s)
        : _data(_s._pd_seq) { _s = (AuthorisationRequestTypeList*) 0; }
      inline AuthorisationRequestTypeList_out(const AuthorisationRequestTypeList_out& _s) : _data(_s._data) {}
      inline AuthorisationRequestTypeList_out& operator = (const AuthorisationRequestTypeList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AuthorisationRequestTypeList_out& operator = (AuthorisationRequestTypeList* _s) {
        _data = _s;
        return *this;
      }
      inline operator AuthorisationRequestTypeList*&()  { return _data; }
      inline AuthorisationRequestTypeList*& ptr()       { return _data; }
      inline AuthorisationRequestTypeList* operator->() { return _data; }

      inline AuthorisationRequestType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AuthorisationRequestTypeList*& _data;

    private:
      AuthorisationRequestTypeList_out();
      AuthorisationRequestTypeList_out& operator=(const AuthorisationRequestTypeList_var&);
    };

    struct RadioAuthorisationManagerType {
      typedef _CORBA_ConstrType_Variable_Var<RadioAuthorisationManagerType> _var_type;

      
      AuthorisationRequestTypeList radioAuthorisationStack;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioAuthorisationManagerType::_var_type RadioAuthorisationManagerType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioAuthorisationManagerType,RadioAuthorisationManagerType_var > RadioAuthorisationManagerType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioAuthorisationManagerType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallDetailsTypeList;

    class CallDetailsTypeList_var;

    class CallDetailsTypeList : public _CORBA_Unbounded_Sequence< IRadioCorbaDef::CallDetailsType >  {
    public:
      typedef CallDetailsTypeList_var _var_type;
      inline CallDetailsTypeList() {}
      inline CallDetailsTypeList(const CallDetailsTypeList& _s)
        : _CORBA_Unbounded_Sequence< IRadioCorbaDef::CallDetailsType > (_s) {}

      inline CallDetailsTypeList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< IRadioCorbaDef::CallDetailsType > (_max) {}
      inline CallDetailsTypeList(_CORBA_ULong _max, _CORBA_ULong _len, IRadioCorbaDef::CallDetailsType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< IRadioCorbaDef::CallDetailsType > (_max, _len, _val, _rel) {}

    

      inline CallDetailsTypeList& operator = (const CallDetailsTypeList& _s) {
        _CORBA_Unbounded_Sequence< IRadioCorbaDef::CallDetailsType > ::operator=(_s);
        return *this;
      }
    };

    class CallDetailsTypeList_out;

    class CallDetailsTypeList_var {
    public:
      inline CallDetailsTypeList_var() : _pd_seq(0) {}
      inline CallDetailsTypeList_var(CallDetailsTypeList* _s) : _pd_seq(_s) {}
      inline CallDetailsTypeList_var(const CallDetailsTypeList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new CallDetailsTypeList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~CallDetailsTypeList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline CallDetailsTypeList_var& operator = (CallDetailsTypeList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline CallDetailsTypeList_var& operator = (const CallDetailsTypeList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new CallDetailsTypeList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline IRadioCorbaDef::CallDetailsType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline CallDetailsTypeList* operator -> () { return _pd_seq; }
      inline const CallDetailsTypeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator CallDetailsTypeList& () const { return *_pd_seq; }
#else
      inline operator const CallDetailsTypeList& () const { return *_pd_seq; }
      inline operator CallDetailsTypeList& () { return *_pd_seq; }
#endif
        
      inline const CallDetailsTypeList& in() const { return *_pd_seq; }
      inline CallDetailsTypeList&       inout()    { return *_pd_seq; }
      inline CallDetailsTypeList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline CallDetailsTypeList* _retn() { CallDetailsTypeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class CallDetailsTypeList_out;
      
    private:
      CallDetailsTypeList* _pd_seq;
    };

    class CallDetailsTypeList_out {
    public:
      inline CallDetailsTypeList_out(CallDetailsTypeList*& _s) : _data(_s) { _data = 0; }
      inline CallDetailsTypeList_out(CallDetailsTypeList_var& _s)
        : _data(_s._pd_seq) { _s = (CallDetailsTypeList*) 0; }
      inline CallDetailsTypeList_out(const CallDetailsTypeList_out& _s) : _data(_s._data) {}
      inline CallDetailsTypeList_out& operator = (const CallDetailsTypeList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline CallDetailsTypeList_out& operator = (CallDetailsTypeList* _s) {
        _data = _s;
        return *this;
      }
      inline operator CallDetailsTypeList*&()  { return _data; }
      inline CallDetailsTypeList*& ptr()       { return _data; }
      inline CallDetailsTypeList* operator->() { return _data; }

      inline IRadioCorbaDef::CallDetailsType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      CallDetailsTypeList*& _data;

    private:
      CallDetailsTypeList_out();
      CallDetailsTypeList_out& operator=(const CallDetailsTypeList_var&);
    };

    struct TcpServerType {
      typedef _CORBA_ConstrType_Variable_Var<TcpServerType> _var_type;

      
      CallDetailsTypeList radioCallStack;

      RadioAuthorisationManagerType radioAuthorisationManager;

      RadioResourceManagerType radioResourceManager;

      RadioMonitorManagerType radioMonitorManager;

      IRadioCorbaDef::EControlConnectionStatus controlConnectionStatus;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TcpServerType::_var_type TcpServerType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TcpServerType,TcpServerType_var > TcpServerType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TcpServerType;

    struct Radio {
      typedef _CORBA_ConstrType_Variable_Var<Radio> _var_type;

      
      ::CORBA::Long serverIndex;

      TcpServerType tcpServer;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Radio::_var_type Radio_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Radio,Radio_var > Radio_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_Radio;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioType;

    class RadioType_var;

    class RadioType : public _CORBA_Unbounded_Sequence< Radio >  {
    public:
      typedef RadioType_var _var_type;
      inline RadioType() {}
      inline RadioType(const RadioType& _s)
        : _CORBA_Unbounded_Sequence< Radio > (_s) {}

      inline RadioType(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< Radio > (_max) {}
      inline RadioType(_CORBA_ULong _max, _CORBA_ULong _len, Radio* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< Radio > (_max, _len, _val, _rel) {}

    

      inline RadioType& operator = (const RadioType& _s) {
        _CORBA_Unbounded_Sequence< Radio > ::operator=(_s);
        return *this;
      }
    };

    class RadioType_out;

    class RadioType_var {
    public:
      inline RadioType_var() : _pd_seq(0) {}
      inline RadioType_var(RadioType* _s) : _pd_seq(_s) {}
      inline RadioType_var(const RadioType_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RadioType(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RadioType_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RadioType_var& operator = (RadioType* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RadioType_var& operator = (const RadioType_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RadioType;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Radio& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RadioType* operator -> () { return _pd_seq; }
      inline const RadioType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RadioType& () const { return *_pd_seq; }
#else
      inline operator const RadioType& () const { return *_pd_seq; }
      inline operator RadioType& () { return *_pd_seq; }
#endif
        
      inline const RadioType& in() const { return *_pd_seq; }
      inline RadioType&       inout()    { return *_pd_seq; }
      inline RadioType*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RadioType* _retn() { RadioType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RadioType_out;
      
    private:
      RadioType* _pd_seq;
    };

    class RadioType_out {
    public:
      inline RadioType_out(RadioType*& _s) : _data(_s) { _data = 0; }
      inline RadioType_out(RadioType_var& _s)
        : _data(_s._pd_seq) { _s = (RadioType*) 0; }
      inline RadioType_out(const RadioType_out& _s) : _data(_s._data) {}
      inline RadioType_out& operator = (const RadioType_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RadioType_out& operator = (RadioType* _s) {
        _data = _s;
        return *this;
      }
      inline operator RadioType*&()  { return _data; }
      inline RadioType*& ptr()       { return _data; }
      inline RadioType* operator->() { return _data; }

      inline Radio& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RadioType*& _data;

    private:
      RadioType_out();
      RadioType_out& operator=(const RadioType_var&);
    };

    struct RadioServantType {
      typedef _CORBA_ConstrType_Variable_Var<RadioServantType> _var_type;

      
      ::CORBA::ULong entityKey;

      RadioType radio;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioServantType::_var_type RadioServantType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioServantType,RadioServantType_var > RadioServantType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioServantType;

    struct RadioTetraAgentType {
      typedef _CORBA_ConstrType_Variable_Var<RadioTetraAgentType> _var_type;

      
      RadioServantType radioServant;

      RadioSessionServantTypeList radioSessionServants;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RadioTetraAgentType::_var_type RadioTetraAgentType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RadioTetraAgentType,RadioTetraAgentType_var > RadioTetraAgentType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RadioTetraAgentType;

  
  };

  class _objref_IRadioStateSynchronisationCorbaDef :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    IRadioStateSynchronisationCorbaDef::RadioTetraAgentType* requestFullState();
    void setMonitorAgentState(::CORBA::Boolean state);

    inline _objref_IRadioStateSynchronisationCorbaDef()  { _PR_setobj(0); }  // nil
    _objref_IRadioStateSynchronisationCorbaDef(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_IRadioStateSynchronisationCorbaDef();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_IRadioStateSynchronisationCorbaDef(const _objref_IRadioStateSynchronisationCorbaDef&);
    _objref_IRadioStateSynchronisationCorbaDef& operator = (const _objref_IRadioStateSynchronisationCorbaDef&);
    // not implemented

    friend class IRadioStateSynchronisationCorbaDef;
  };

  class _pof_IRadioStateSynchronisationCorbaDef : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_IRadioStateSynchronisationCorbaDef() : _OMNI_NS(proxyObjectFactory)(IRadioStateSynchronisationCorbaDef::_PD_repoId) {}
    virtual ~_pof_IRadioStateSynchronisationCorbaDef();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_IRadioStateSynchronisationCorbaDef :
    public virtual omniServant
  {
  public:
    virtual ~_impl_IRadioStateSynchronisationCorbaDef();

    virtual IRadioStateSynchronisationCorbaDef::RadioTetraAgentType* requestFullState() = 0;
    virtual void setMonitorAgentState(::CORBA::Boolean state) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IRadioStateSynchronisationCorbaDef;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  class IRadioStateSynchronisationCorbaDef :
    public virtual TA_Base_Bus::_impl_IRadioStateSynchronisationCorbaDef,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~IRadioStateSynchronisationCorbaDef();

    inline ::TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr _this() {
      return (::TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr) _do_this(::TA_Base_Bus::IRadioStateSynchronisationCorbaDef::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntry& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntry*& _sp);

inline void operator >>=(TA_Base_Bus::IRadioStateSynchronisationCorbaDef::ESessionState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::IRadioStateSynchronisationCorbaDef::ESessionState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionLoggedIn) {
    _e = (TA_Base_Bus::IRadioStateSynchronisationCorbaDef::ESessionState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::ESessionState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::ESessionState& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantType*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantTypeList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantTypeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantTypeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioSessionServantTypeList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateCallInRadioCallStack& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateCallInRadioCallStack* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateCallInRadioCallStack*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateCallInRadioCallStack*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveCallFromRadioCallStack& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveCallFromRadioCallStack* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveCallFromRadioCallStack*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveCallFromRadioCallStack*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioSession& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioSession* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioSession*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioSession*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateMonitoredCallProgression& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateMonitoredCallProgression* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateMonitoredCallProgression*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateMonitoredCallProgression*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveMonitoredSubscriberDetails& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveMonitoredSubscriberDetails* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveMonitoredSubscriberDetails*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveMonitoredSubscriberDetails*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveSessionFromAudioMap& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveSessionFromAudioMap* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveSessionFromAudioMap*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveSessionFromAudioMap*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAudioEntryInSessionAudioMap& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAudioEntryInSessionAudioMap* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAudioEntryInSessionAudioMap*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAudioEntryInSessionAudioMap*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioResourceManagerVars& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioResourceManagerVars* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioResourceManagerVars*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateRadioResourceManagerVars*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAuthorisationRequest& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAuthorisationRequest* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAuthorisationRequest*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioUpdateAuthorisationRequest*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveAuthorisationRequest& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveAuthorisationRequest* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveAuthorisationRequest*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioRemoveAuthorisationRequest*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioConnectionSwitchRequest& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioConnectionSwitchRequest* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioConnectionSwitchRequest*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioConnectionSwitchRequest*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRef& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRef*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRefList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRefList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRefList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::MonitoredSubscriberDetailsTypeAndRefList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioMonitorManagerType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioMonitorManagerType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioMonitorManagerType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioMonitorManagerType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMap& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMap* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMap*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMap*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMapType& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMapType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMapType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AudioEntryMapType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMap& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMap* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMap*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMap*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMapType& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMapType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMapType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::SessionAudioMapType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioResourceManagerType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioResourceManagerType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioResourceManagerType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioResourceManagerType*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestTypeList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestTypeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestTypeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::AuthorisationRequestTypeList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioAuthorisationManagerType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioAuthorisationManagerType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioAuthorisationManagerType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioAuthorisationManagerType*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::CallDetailsTypeList& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::CallDetailsTypeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::CallDetailsTypeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::CallDetailsTypeList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::TcpServerType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::TcpServerType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::TcpServerType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::TcpServerType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::Radio& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::Radio* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::Radio*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::Radio*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioType& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioServantType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioServantType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioServantType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioServantType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioTetraAgentType& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioTetraAgentType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioTetraAgentType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::IRadioStateSynchronisationCorbaDef::RadioTetraAgentType*& _sp);

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr& _s);



inline void
TA_Base_Bus::IRadioStateSynchronisationCorbaDef::_marshalObjRef(::TA_Base_Bus::IRadioStateSynchronisationCorbaDef_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_IRadioStateSynchronisationCorbaDef
#endif

#endif  // __IRadioStateSynchronisationCorbaDef_hh__

