// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __DutyAgentTypeCorbaDef_hh__
#define __DutyAgentTypeCorbaDef_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif



#ifndef __IDutyAgentRespCorbaDef_hh_EXTERNAL_GUARD__
#define __IDutyAgentRespCorbaDef_hh_EXTERNAL_GUARD__
#include <IDutyAgentRespCorbaDef.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

#ifndef __TA__Base__Bus_mDutyAgentTypeCorbaDef__
#define __TA__Base__Bus_mDutyAgentTypeCorbaDef__

  class DutyAgentTypeCorbaDef;
  class _objref_DutyAgentTypeCorbaDef;
  class _impl_DutyAgentTypeCorbaDef;
  
  typedef _objref_DutyAgentTypeCorbaDef* DutyAgentTypeCorbaDef_ptr;
  typedef DutyAgentTypeCorbaDef_ptr DutyAgentTypeCorbaDefRef;

  class DutyAgentTypeCorbaDef_Helper {
  public:
    typedef DutyAgentTypeCorbaDef_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DutyAgentTypeCorbaDef, DutyAgentTypeCorbaDef_Helper> DutyAgentTypeCorbaDef_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DutyAgentTypeCorbaDef,DutyAgentTypeCorbaDef_Helper > DutyAgentTypeCorbaDef_out;

#endif

  // interface DutyAgentTypeCorbaDef
  class DutyAgentTypeCorbaDef {
  public:
    // Declarations for this interface type.
    typedef DutyAgentTypeCorbaDef_ptr _ptr_type;
    typedef DutyAgentTypeCorbaDef_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnhandledException : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member reason;

    

      inline UnhandledException() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnhandledException(const UnhandledException&);
      UnhandledException(const char* i_reason);
      UnhandledException& operator=(const UnhandledException&);
      virtual ~UnhandledException();
      virtual void _raise() const;
      static UnhandledException* _downcast(::CORBA::Exception*);
      static const UnhandledException* _downcast(const ::CORBA::Exception*);
      static inline UnhandledException* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnhandledException;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SessionId;

    typedef char* SessionId;
    typedef ::CORBA::String_var SessionId_var;
    typedef ::CORBA::String_out SessionId_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActionId;

    typedef char* ActionId;
    typedef ::CORBA::String_var ActionId_var;
    typedef ::CORBA::String_out ActionId_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_Key;

    typedef ::CORBA::ULong Key;
    typedef ::CORBA::ULong_out Key_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_KeySequence;

    class KeySequence_var;

    class KeySequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< Key, 4, 4 >  {
    public:
      typedef KeySequence_var _var_type;
      inline KeySequence() {}
      inline KeySequence(const KeySequence& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< Key, 4, 4 > (_s) {}

      inline KeySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< Key, 4, 4 > (_max) {}
      inline KeySequence(_CORBA_ULong _max, _CORBA_ULong _len, Key* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< Key, 4, 4 > (_max, _len, _val, _rel) {}

    

      inline KeySequence& operator = (const KeySequence& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< Key, 4, 4 > ::operator=(_s);
        return *this;
      }
    };

    class KeySequence_out;

    class KeySequence_var {
    public:
      inline KeySequence_var() : _pd_seq(0) {}
      inline KeySequence_var(KeySequence* _s) : _pd_seq(_s) {}
      inline KeySequence_var(const KeySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new KeySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~KeySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline KeySequence_var& operator = (KeySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline KeySequence_var& operator = (const KeySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new KeySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Key& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline KeySequence* operator -> () { return _pd_seq; }
      inline const KeySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator KeySequence& () const { return *_pd_seq; }
#else
      inline operator const KeySequence& () const { return *_pd_seq; }
      inline operator KeySequence& () { return *_pd_seq; }
#endif
        
      inline const KeySequence& in() const { return *_pd_seq; }
      inline KeySequence&       inout()    { return *_pd_seq; }
      inline KeySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline KeySequence* _retn() { KeySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class KeySequence_out;
      
    private:
      KeySequence* _pd_seq;
    };

    class KeySequence_out {
    public:
      inline KeySequence_out(KeySequence*& _s) : _data(_s) { _data = 0; }
      inline KeySequence_out(KeySequence_var& _s)
        : _data(_s._pd_seq) { _s = (KeySequence*) 0; }
      inline KeySequence_out(const KeySequence_out& _s) : _data(_s._data) {}
      inline KeySequence_out& operator = (const KeySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline KeySequence_out& operator = (KeySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator KeySequence*&()  { return _data; }
      inline KeySequence*& ptr()       { return _data; }
      inline KeySequence* operator->() { return _data; }

      inline Key& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      KeySequence*& _data;

    private:
      KeySequence_out();
      KeySequence_out& operator=(const KeySequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SessionIdSequence;

    class SessionIdSequence_var;

    class SessionIdSequence : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef SessionIdSequence_var _var_type;
      inline SessionIdSequence() {}
      inline SessionIdSequence(const SessionIdSequence& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline SessionIdSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline SessionIdSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline SessionIdSequence& operator = (const SessionIdSequence& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class SessionIdSequence_out;

    class SessionIdSequence_var {
    public:
      inline SessionIdSequence_var() : _pd_seq(0) {}
      inline SessionIdSequence_var(SessionIdSequence* _s) : _pd_seq(_s) {}
      inline SessionIdSequence_var(const SessionIdSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SessionIdSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SessionIdSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SessionIdSequence_var& operator = (SessionIdSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SessionIdSequence_var& operator = (const SessionIdSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SessionIdSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SessionIdSequence* operator -> () { return _pd_seq; }
      inline const SessionIdSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SessionIdSequence& () const { return *_pd_seq; }
#else
      inline operator const SessionIdSequence& () const { return *_pd_seq; }
      inline operator SessionIdSequence& () { return *_pd_seq; }
#endif
        
      inline const SessionIdSequence& in() const { return *_pd_seq; }
      inline SessionIdSequence&       inout()    { return *_pd_seq; }
      inline SessionIdSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SessionIdSequence* _retn() { SessionIdSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SessionIdSequence_out;
      
    private:
      SessionIdSequence* _pd_seq;
    };

    class SessionIdSequence_out {
    public:
      inline SessionIdSequence_out(SessionIdSequence*& _s) : _data(_s) { _data = 0; }
      inline SessionIdSequence_out(SessionIdSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SessionIdSequence*) 0; }
      inline SessionIdSequence_out(const SessionIdSequence_out& _s) : _data(_s._data) {}
      inline SessionIdSequence_out& operator = (const SessionIdSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SessionIdSequence_out& operator = (SessionIdSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SessionIdSequence*&()  { return _data; }
      inline SessionIdSequence*& ptr()       { return _data; }
      inline SessionIdSequence* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SessionIdSequence*& _data;

    private:
      SessionIdSequence_out();
      SessionIdSequence_out& operator=(const SessionIdSequence_var&);
    };

    static _core_attr const ::CORBA::ULong INVALID_KEY _init_in_cldecl_( = 4294967295U );

    struct RegionDuty {
      typedef _CORBA_ConstrType_Variable_Var<RegionDuty> _var_type;

      
      Key regionKey;

      ::CORBA::String_member session;

      Key profileKey;

      Key profileTypeKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RegionDuty::_var_type RegionDuty_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RegionDuty,RegionDuty_var > RegionDuty_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegionDuty;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegionDutySequence;

    class RegionDutySequence_var;

    class RegionDutySequence : public _CORBA_Unbounded_Sequence< RegionDuty >  {
    public:
      typedef RegionDutySequence_var _var_type;
      inline RegionDutySequence() {}
      inline RegionDutySequence(const RegionDutySequence& _s)
        : _CORBA_Unbounded_Sequence< RegionDuty > (_s) {}

      inline RegionDutySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< RegionDuty > (_max) {}
      inline RegionDutySequence(_CORBA_ULong _max, _CORBA_ULong _len, RegionDuty* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< RegionDuty > (_max, _len, _val, _rel) {}

    

      inline RegionDutySequence& operator = (const RegionDutySequence& _s) {
        _CORBA_Unbounded_Sequence< RegionDuty > ::operator=(_s);
        return *this;
      }
    };

    class RegionDutySequence_out;

    class RegionDutySequence_var {
    public:
      inline RegionDutySequence_var() : _pd_seq(0) {}
      inline RegionDutySequence_var(RegionDutySequence* _s) : _pd_seq(_s) {}
      inline RegionDutySequence_var(const RegionDutySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RegionDutySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RegionDutySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RegionDutySequence_var& operator = (RegionDutySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RegionDutySequence_var& operator = (const RegionDutySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RegionDutySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline RegionDuty& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RegionDutySequence* operator -> () { return _pd_seq; }
      inline const RegionDutySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RegionDutySequence& () const { return *_pd_seq; }
#else
      inline operator const RegionDutySequence& () const { return *_pd_seq; }
      inline operator RegionDutySequence& () { return *_pd_seq; }
#endif
        
      inline const RegionDutySequence& in() const { return *_pd_seq; }
      inline RegionDutySequence&       inout()    { return *_pd_seq; }
      inline RegionDutySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RegionDutySequence* _retn() { RegionDutySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RegionDutySequence_out;
      
    private:
      RegionDutySequence* _pd_seq;
    };

    class RegionDutySequence_out {
    public:
      inline RegionDutySequence_out(RegionDutySequence*& _s) : _data(_s) { _data = 0; }
      inline RegionDutySequence_out(RegionDutySequence_var& _s)
        : _data(_s._pd_seq) { _s = (RegionDutySequence*) 0; }
      inline RegionDutySequence_out(const RegionDutySequence_out& _s) : _data(_s._data) {}
      inline RegionDutySequence_out& operator = (const RegionDutySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RegionDutySequence_out& operator = (RegionDutySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator RegionDutySequence*&()  { return _data; }
      inline RegionDutySequence*& ptr()       { return _data; }
      inline RegionDutySequence* operator->() { return _data; }

      inline RegionDuty& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RegionDutySequence*& _data;

    private:
      RegionDutySequence_out();
      RegionDutySequence_out& operator=(const RegionDutySequence_var&);
    };

    struct RegionDutyChanges {
      typedef _CORBA_ConstrType_Variable_Var<RegionDutyChanges> _var_type;

      
      RegionDutySequence add;

      RegionDutySequence rem;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RegionDutyChanges::_var_type RegionDutyChanges_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RegionDutyChanges,RegionDutyChanges_var > RegionDutyChanges_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegionDutyChanges;

    struct SubsystemDuty {
      typedef _CORBA_ConstrType_Variable_Var<SubsystemDuty> _var_type;

      
      Key regionKey;

      Key subsystemKey;

      ::CORBA::String_member session;

      Key profileKey;

      Key actionGroupKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SubsystemDuty::_var_type SubsystemDuty_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SubsystemDuty,SubsystemDuty_var > SubsystemDuty_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemDuty;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemDutySequence;

    class SubsystemDutySequence_var;

    class SubsystemDutySequence : public _CORBA_Unbounded_Sequence< SubsystemDuty >  {
    public:
      typedef SubsystemDutySequence_var _var_type;
      inline SubsystemDutySequence() {}
      inline SubsystemDutySequence(const SubsystemDutySequence& _s)
        : _CORBA_Unbounded_Sequence< SubsystemDuty > (_s) {}

      inline SubsystemDutySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SubsystemDuty > (_max) {}
      inline SubsystemDutySequence(_CORBA_ULong _max, _CORBA_ULong _len, SubsystemDuty* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SubsystemDuty > (_max, _len, _val, _rel) {}

    

      inline SubsystemDutySequence& operator = (const SubsystemDutySequence& _s) {
        _CORBA_Unbounded_Sequence< SubsystemDuty > ::operator=(_s);
        return *this;
      }
    };

    class SubsystemDutySequence_out;

    class SubsystemDutySequence_var {
    public:
      inline SubsystemDutySequence_var() : _pd_seq(0) {}
      inline SubsystemDutySequence_var(SubsystemDutySequence* _s) : _pd_seq(_s) {}
      inline SubsystemDutySequence_var(const SubsystemDutySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SubsystemDutySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SubsystemDutySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SubsystemDutySequence_var& operator = (SubsystemDutySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SubsystemDutySequence_var& operator = (const SubsystemDutySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SubsystemDutySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SubsystemDuty& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SubsystemDutySequence* operator -> () { return _pd_seq; }
      inline const SubsystemDutySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SubsystemDutySequence& () const { return *_pd_seq; }
#else
      inline operator const SubsystemDutySequence& () const { return *_pd_seq; }
      inline operator SubsystemDutySequence& () { return *_pd_seq; }
#endif
        
      inline const SubsystemDutySequence& in() const { return *_pd_seq; }
      inline SubsystemDutySequence&       inout()    { return *_pd_seq; }
      inline SubsystemDutySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SubsystemDutySequence* _retn() { SubsystemDutySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SubsystemDutySequence_out;
      
    private:
      SubsystemDutySequence* _pd_seq;
    };

    class SubsystemDutySequence_out {
    public:
      inline SubsystemDutySequence_out(SubsystemDutySequence*& _s) : _data(_s) { _data = 0; }
      inline SubsystemDutySequence_out(SubsystemDutySequence_var& _s)
        : _data(_s._pd_seq) { _s = (SubsystemDutySequence*) 0; }
      inline SubsystemDutySequence_out(const SubsystemDutySequence_out& _s) : _data(_s._data) {}
      inline SubsystemDutySequence_out& operator = (const SubsystemDutySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SubsystemDutySequence_out& operator = (SubsystemDutySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SubsystemDutySequence*&()  { return _data; }
      inline SubsystemDutySequence*& ptr()       { return _data; }
      inline SubsystemDutySequence* operator->() { return _data; }

      inline SubsystemDuty& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SubsystemDutySequence*& _data;

    private:
      SubsystemDutySequence_out();
      SubsystemDutySequence_out& operator=(const SubsystemDutySequence_var&);
    };

    struct TransferableRegion {
      typedef _CORBA_ConstrType_Fix_Var<TransferableRegion> _var_type;

      
      Key regionKey;

      Key operatorKey;

      Key profileKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TransferableRegion::_var_type TransferableRegion_var;

    typedef TransferableRegion& TransferableRegion_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransferableRegion;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransferableRegionSequence;

    class TransferableRegionSequence_var;

    class TransferableRegionSequence : public _CORBA_Unbounded_Sequence< TransferableRegion >  {
    public:
      typedef TransferableRegionSequence_var _var_type;
      inline TransferableRegionSequence() {}
      inline TransferableRegionSequence(const TransferableRegionSequence& _s)
        : _CORBA_Unbounded_Sequence< TransferableRegion > (_s) {}

      inline TransferableRegionSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TransferableRegion > (_max) {}
      inline TransferableRegionSequence(_CORBA_ULong _max, _CORBA_ULong _len, TransferableRegion* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TransferableRegion > (_max, _len, _val, _rel) {}

    

      inline TransferableRegionSequence& operator = (const TransferableRegionSequence& _s) {
        _CORBA_Unbounded_Sequence< TransferableRegion > ::operator=(_s);
        return *this;
      }
    };

    class TransferableRegionSequence_out;

    class TransferableRegionSequence_var {
    public:
      inline TransferableRegionSequence_var() : _pd_seq(0) {}
      inline TransferableRegionSequence_var(TransferableRegionSequence* _s) : _pd_seq(_s) {}
      inline TransferableRegionSequence_var(const TransferableRegionSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TransferableRegionSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TransferableRegionSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TransferableRegionSequence_var& operator = (TransferableRegionSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TransferableRegionSequence_var& operator = (const TransferableRegionSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TransferableRegionSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TransferableRegion& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TransferableRegionSequence* operator -> () { return _pd_seq; }
      inline const TransferableRegionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TransferableRegionSequence& () const { return *_pd_seq; }
#else
      inline operator const TransferableRegionSequence& () const { return *_pd_seq; }
      inline operator TransferableRegionSequence& () { return *_pd_seq; }
#endif
        
      inline const TransferableRegionSequence& in() const { return *_pd_seq; }
      inline TransferableRegionSequence&       inout()    { return *_pd_seq; }
      inline TransferableRegionSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TransferableRegionSequence* _retn() { TransferableRegionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TransferableRegionSequence_out;
      
    private:
      TransferableRegionSequence* _pd_seq;
    };

    class TransferableRegionSequence_out {
    public:
      inline TransferableRegionSequence_out(TransferableRegionSequence*& _s) : _data(_s) { _data = 0; }
      inline TransferableRegionSequence_out(TransferableRegionSequence_var& _s)
        : _data(_s._pd_seq) { _s = (TransferableRegionSequence*) 0; }
      inline TransferableRegionSequence_out(const TransferableRegionSequence_out& _s) : _data(_s._data) {}
      inline TransferableRegionSequence_out& operator = (const TransferableRegionSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TransferableRegionSequence_out& operator = (TransferableRegionSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator TransferableRegionSequence*&()  { return _data; }
      inline TransferableRegionSequence*& ptr()       { return _data; }
      inline TransferableRegionSequence* operator->() { return _data; }

      inline TransferableRegion& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TransferableRegionSequence*& _data;

    private:
      TransferableRegionSequence_out();
      TransferableRegionSequence_out& operator=(const TransferableRegionSequence_var&);
    };

    struct TransferableSubsystem {
      typedef _CORBA_ConstrType_Fix_Var<TransferableSubsystem> _var_type;

      
      Key regionKey;

      Key subsystemKey;

      Key operatorKey;

      Key profileKey;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TransferableSubsystem::_var_type TransferableSubsystem_var;

    typedef TransferableSubsystem& TransferableSubsystem_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransferableSubsystem;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransferableSubsystemSequence;

    class TransferableSubsystemSequence_var;

    class TransferableSubsystemSequence : public _CORBA_Unbounded_Sequence< TransferableSubsystem >  {
    public:
      typedef TransferableSubsystemSequence_var _var_type;
      inline TransferableSubsystemSequence() {}
      inline TransferableSubsystemSequence(const TransferableSubsystemSequence& _s)
        : _CORBA_Unbounded_Sequence< TransferableSubsystem > (_s) {}

      inline TransferableSubsystemSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TransferableSubsystem > (_max) {}
      inline TransferableSubsystemSequence(_CORBA_ULong _max, _CORBA_ULong _len, TransferableSubsystem* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TransferableSubsystem > (_max, _len, _val, _rel) {}

    

      inline TransferableSubsystemSequence& operator = (const TransferableSubsystemSequence& _s) {
        _CORBA_Unbounded_Sequence< TransferableSubsystem > ::operator=(_s);
        return *this;
      }
    };

    class TransferableSubsystemSequence_out;

    class TransferableSubsystemSequence_var {
    public:
      inline TransferableSubsystemSequence_var() : _pd_seq(0) {}
      inline TransferableSubsystemSequence_var(TransferableSubsystemSequence* _s) : _pd_seq(_s) {}
      inline TransferableSubsystemSequence_var(const TransferableSubsystemSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TransferableSubsystemSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TransferableSubsystemSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TransferableSubsystemSequence_var& operator = (TransferableSubsystemSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TransferableSubsystemSequence_var& operator = (const TransferableSubsystemSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TransferableSubsystemSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TransferableSubsystem& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TransferableSubsystemSequence* operator -> () { return _pd_seq; }
      inline const TransferableSubsystemSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TransferableSubsystemSequence& () const { return *_pd_seq; }
#else
      inline operator const TransferableSubsystemSequence& () const { return *_pd_seq; }
      inline operator TransferableSubsystemSequence& () { return *_pd_seq; }
#endif
        
      inline const TransferableSubsystemSequence& in() const { return *_pd_seq; }
      inline TransferableSubsystemSequence&       inout()    { return *_pd_seq; }
      inline TransferableSubsystemSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TransferableSubsystemSequence* _retn() { TransferableSubsystemSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TransferableSubsystemSequence_out;
      
    private:
      TransferableSubsystemSequence* _pd_seq;
    };

    class TransferableSubsystemSequence_out {
    public:
      inline TransferableSubsystemSequence_out(TransferableSubsystemSequence*& _s) : _data(_s) { _data = 0; }
      inline TransferableSubsystemSequence_out(TransferableSubsystemSequence_var& _s)
        : _data(_s._pd_seq) { _s = (TransferableSubsystemSequence*) 0; }
      inline TransferableSubsystemSequence_out(const TransferableSubsystemSequence_out& _s) : _data(_s._data) {}
      inline TransferableSubsystemSequence_out& operator = (const TransferableSubsystemSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TransferableSubsystemSequence_out& operator = (TransferableSubsystemSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator TransferableSubsystemSequence*&()  { return _data; }
      inline TransferableSubsystemSequence*& ptr()       { return _data; }
      inline TransferableSubsystemSequence* operator->() { return _data; }

      inline TransferableSubsystem& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TransferableSubsystemSequence*& _data;

    private:
      TransferableSubsystemSequence_out();
      TransferableSubsystemSequence_out& operator=(const TransferableSubsystemSequence_var&);
    };

    struct SubsystemTree {
      typedef _CORBA_ConstrType_Variable_Var<SubsystemTree> _var_type;

      
      Key region;

      KeySequence subsystems;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SubsystemTree::_var_type SubsystemTree_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SubsystemTree,SubsystemTree_var > SubsystemTree_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemTree;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemTreeSequence;

    class SubsystemTreeSequence_var;

    class SubsystemTreeSequence : public _CORBA_Unbounded_Sequence< SubsystemTree >  {
    public:
      typedef SubsystemTreeSequence_var _var_type;
      inline SubsystemTreeSequence() {}
      inline SubsystemTreeSequence(const SubsystemTreeSequence& _s)
        : _CORBA_Unbounded_Sequence< SubsystemTree > (_s) {}

      inline SubsystemTreeSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SubsystemTree > (_max) {}
      inline SubsystemTreeSequence(_CORBA_ULong _max, _CORBA_ULong _len, SubsystemTree* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SubsystemTree > (_max, _len, _val, _rel) {}

    

      inline SubsystemTreeSequence& operator = (const SubsystemTreeSequence& _s) {
        _CORBA_Unbounded_Sequence< SubsystemTree > ::operator=(_s);
        return *this;
      }
    };

    class SubsystemTreeSequence_out;

    class SubsystemTreeSequence_var {
    public:
      inline SubsystemTreeSequence_var() : _pd_seq(0) {}
      inline SubsystemTreeSequence_var(SubsystemTreeSequence* _s) : _pd_seq(_s) {}
      inline SubsystemTreeSequence_var(const SubsystemTreeSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SubsystemTreeSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SubsystemTreeSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SubsystemTreeSequence_var& operator = (SubsystemTreeSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SubsystemTreeSequence_var& operator = (const SubsystemTreeSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SubsystemTreeSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SubsystemTree& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SubsystemTreeSequence* operator -> () { return _pd_seq; }
      inline const SubsystemTreeSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SubsystemTreeSequence& () const { return *_pd_seq; }
#else
      inline operator const SubsystemTreeSequence& () const { return *_pd_seq; }
      inline operator SubsystemTreeSequence& () { return *_pd_seq; }
#endif
        
      inline const SubsystemTreeSequence& in() const { return *_pd_seq; }
      inline SubsystemTreeSequence&       inout()    { return *_pd_seq; }
      inline SubsystemTreeSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SubsystemTreeSequence* _retn() { SubsystemTreeSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SubsystemTreeSequence_out;
      
    private:
      SubsystemTreeSequence* _pd_seq;
    };

    class SubsystemTreeSequence_out {
    public:
      inline SubsystemTreeSequence_out(SubsystemTreeSequence*& _s) : _data(_s) { _data = 0; }
      inline SubsystemTreeSequence_out(SubsystemTreeSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SubsystemTreeSequence*) 0; }
      inline SubsystemTreeSequence_out(const SubsystemTreeSequence_out& _s) : _data(_s._data) {}
      inline SubsystemTreeSequence_out& operator = (const SubsystemTreeSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SubsystemTreeSequence_out& operator = (SubsystemTreeSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SubsystemTreeSequence*&()  { return _data; }
      inline SubsystemTreeSequence*& ptr()       { return _data; }
      inline SubsystemTreeSequence* operator->() { return _data; }

      inline SubsystemTree& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SubsystemTreeSequence*& _data;

    private:
      SubsystemTreeSequence_out();
      SubsystemTreeSequence_out& operator=(const SubsystemTreeSequence_var&);
    };

    struct SubsystemState {
      typedef _CORBA_ConstrType_Fix_Var<SubsystemState> _var_type;

      
      Key regionKey;

      Key subsystemKey;

      ::CORBA::ULong prevState;

      ::CORBA::ULong currState;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SubsystemState::_var_type SubsystemState_var;

    typedef SubsystemState& SubsystemState_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemState;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemStateSequence;

    class SubsystemStateSequence_var;

    class SubsystemStateSequence : public _CORBA_Unbounded_Sequence< SubsystemState >  {
    public:
      typedef SubsystemStateSequence_var _var_type;
      inline SubsystemStateSequence() {}
      inline SubsystemStateSequence(const SubsystemStateSequence& _s)
        : _CORBA_Unbounded_Sequence< SubsystemState > (_s) {}

      inline SubsystemStateSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SubsystemState > (_max) {}
      inline SubsystemStateSequence(_CORBA_ULong _max, _CORBA_ULong _len, SubsystemState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SubsystemState > (_max, _len, _val, _rel) {}

    

      inline SubsystemStateSequence& operator = (const SubsystemStateSequence& _s) {
        _CORBA_Unbounded_Sequence< SubsystemState > ::operator=(_s);
        return *this;
      }
    };

    class SubsystemStateSequence_out;

    class SubsystemStateSequence_var {
    public:
      inline SubsystemStateSequence_var() : _pd_seq(0) {}
      inline SubsystemStateSequence_var(SubsystemStateSequence* _s) : _pd_seq(_s) {}
      inline SubsystemStateSequence_var(const SubsystemStateSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SubsystemStateSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SubsystemStateSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SubsystemStateSequence_var& operator = (SubsystemStateSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SubsystemStateSequence_var& operator = (const SubsystemStateSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SubsystemStateSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SubsystemState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SubsystemStateSequence* operator -> () { return _pd_seq; }
      inline const SubsystemStateSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SubsystemStateSequence& () const { return *_pd_seq; }
#else
      inline operator const SubsystemStateSequence& () const { return *_pd_seq; }
      inline operator SubsystemStateSequence& () { return *_pd_seq; }
#endif
        
      inline const SubsystemStateSequence& in() const { return *_pd_seq; }
      inline SubsystemStateSequence&       inout()    { return *_pd_seq; }
      inline SubsystemStateSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SubsystemStateSequence* _retn() { SubsystemStateSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SubsystemStateSequence_out;
      
    private:
      SubsystemStateSequence* _pd_seq;
    };

    class SubsystemStateSequence_out {
    public:
      inline SubsystemStateSequence_out(SubsystemStateSequence*& _s) : _data(_s) { _data = 0; }
      inline SubsystemStateSequence_out(SubsystemStateSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SubsystemStateSequence*) 0; }
      inline SubsystemStateSequence_out(const SubsystemStateSequence_out& _s) : _data(_s._data) {}
      inline SubsystemStateSequence_out& operator = (const SubsystemStateSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SubsystemStateSequence_out& operator = (SubsystemStateSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SubsystemStateSequence*&()  { return _data; }
      inline SubsystemStateSequence*& ptr()       { return _data; }
      inline SubsystemStateSequence* operator->() { return _data; }

      inline SubsystemState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SubsystemStateSequence*& _data;

    private:
      SubsystemStateSequence_out();
      SubsystemStateSequence_out& operator=(const SubsystemStateSequence_var&);
    };

    struct SubSession {
      typedef _CORBA_ConstrType_Variable_Var<SubSession> _var_type;

      
      Key subsystem;

      SessionIdSequence sessions;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SubSession::_var_type SubSession_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SubSession,SubSession_var > SubSession_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubSession;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubSessionSequence;

    class SubSessionSequence_var;

    class SubSessionSequence : public _CORBA_Unbounded_Sequence< SubSession >  {
    public:
      typedef SubSessionSequence_var _var_type;
      inline SubSessionSequence() {}
      inline SubSessionSequence(const SubSessionSequence& _s)
        : _CORBA_Unbounded_Sequence< SubSession > (_s) {}

      inline SubSessionSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SubSession > (_max) {}
      inline SubSessionSequence(_CORBA_ULong _max, _CORBA_ULong _len, SubSession* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SubSession > (_max, _len, _val, _rel) {}

    

      inline SubSessionSequence& operator = (const SubSessionSequence& _s) {
        _CORBA_Unbounded_Sequence< SubSession > ::operator=(_s);
        return *this;
      }
    };

    class SubSessionSequence_out;

    class SubSessionSequence_var {
    public:
      inline SubSessionSequence_var() : _pd_seq(0) {}
      inline SubSessionSequence_var(SubSessionSequence* _s) : _pd_seq(_s) {}
      inline SubSessionSequence_var(const SubSessionSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SubSessionSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SubSessionSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SubSessionSequence_var& operator = (SubSessionSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SubSessionSequence_var& operator = (const SubSessionSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SubSessionSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SubSession& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SubSessionSequence* operator -> () { return _pd_seq; }
      inline const SubSessionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SubSessionSequence& () const { return *_pd_seq; }
#else
      inline operator const SubSessionSequence& () const { return *_pd_seq; }
      inline operator SubSessionSequence& () { return *_pd_seq; }
#endif
        
      inline const SubSessionSequence& in() const { return *_pd_seq; }
      inline SubSessionSequence&       inout()    { return *_pd_seq; }
      inline SubSessionSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SubSessionSequence* _retn() { SubSessionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SubSessionSequence_out;
      
    private:
      SubSessionSequence* _pd_seq;
    };

    class SubSessionSequence_out {
    public:
      inline SubSessionSequence_out(SubSessionSequence*& _s) : _data(_s) { _data = 0; }
      inline SubSessionSequence_out(SubSessionSequence_var& _s)
        : _data(_s._pd_seq) { _s = (SubSessionSequence*) 0; }
      inline SubSessionSequence_out(const SubSessionSequence_out& _s) : _data(_s._data) {}
      inline SubSessionSequence_out& operator = (const SubSessionSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SubSessionSequence_out& operator = (SubSessionSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator SubSessionSequence*&()  { return _data; }
      inline SubSessionSequence*& ptr()       { return _data; }
      inline SubSessionSequence* operator->() { return _data; }

      inline SubSession& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SubSessionSequence*& _data;

    private:
      SubSessionSequence_out();
      SubSessionSequence_out& operator=(const SubSessionSequence_var&);
    };

    struct RightsLibraryUpdate {
      typedef _CORBA_ConstrType_Variable_Var<RightsLibraryUpdate> _var_type;

      
      Key region;

      SubSessionSequence duty;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RightsLibraryUpdate::_var_type RightsLibraryUpdate_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< RightsLibraryUpdate,RightsLibraryUpdate_var > RightsLibraryUpdate_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RightsLibraryUpdate;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RightsLibraryUpdateSequence;

    class RightsLibraryUpdateSequence_var;

    class RightsLibraryUpdateSequence : public _CORBA_Unbounded_Sequence< RightsLibraryUpdate >  {
    public:
      typedef RightsLibraryUpdateSequence_var _var_type;
      inline RightsLibraryUpdateSequence() {}
      inline RightsLibraryUpdateSequence(const RightsLibraryUpdateSequence& _s)
        : _CORBA_Unbounded_Sequence< RightsLibraryUpdate > (_s) {}

      inline RightsLibraryUpdateSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< RightsLibraryUpdate > (_max) {}
      inline RightsLibraryUpdateSequence(_CORBA_ULong _max, _CORBA_ULong _len, RightsLibraryUpdate* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< RightsLibraryUpdate > (_max, _len, _val, _rel) {}

    

      inline RightsLibraryUpdateSequence& operator = (const RightsLibraryUpdateSequence& _s) {
        _CORBA_Unbounded_Sequence< RightsLibraryUpdate > ::operator=(_s);
        return *this;
      }
    };

    class RightsLibraryUpdateSequence_out;

    class RightsLibraryUpdateSequence_var {
    public:
      inline RightsLibraryUpdateSequence_var() : _pd_seq(0) {}
      inline RightsLibraryUpdateSequence_var(RightsLibraryUpdateSequence* _s) : _pd_seq(_s) {}
      inline RightsLibraryUpdateSequence_var(const RightsLibraryUpdateSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new RightsLibraryUpdateSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~RightsLibraryUpdateSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline RightsLibraryUpdateSequence_var& operator = (RightsLibraryUpdateSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline RightsLibraryUpdateSequence_var& operator = (const RightsLibraryUpdateSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new RightsLibraryUpdateSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline RightsLibraryUpdate& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline RightsLibraryUpdateSequence* operator -> () { return _pd_seq; }
      inline const RightsLibraryUpdateSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator RightsLibraryUpdateSequence& () const { return *_pd_seq; }
#else
      inline operator const RightsLibraryUpdateSequence& () const { return *_pd_seq; }
      inline operator RightsLibraryUpdateSequence& () { return *_pd_seq; }
#endif
        
      inline const RightsLibraryUpdateSequence& in() const { return *_pd_seq; }
      inline RightsLibraryUpdateSequence&       inout()    { return *_pd_seq; }
      inline RightsLibraryUpdateSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline RightsLibraryUpdateSequence* _retn() { RightsLibraryUpdateSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class RightsLibraryUpdateSequence_out;
      
    private:
      RightsLibraryUpdateSequence* _pd_seq;
    };

    class RightsLibraryUpdateSequence_out {
    public:
      inline RightsLibraryUpdateSequence_out(RightsLibraryUpdateSequence*& _s) : _data(_s) { _data = 0; }
      inline RightsLibraryUpdateSequence_out(RightsLibraryUpdateSequence_var& _s)
        : _data(_s._pd_seq) { _s = (RightsLibraryUpdateSequence*) 0; }
      inline RightsLibraryUpdateSequence_out(const RightsLibraryUpdateSequence_out& _s) : _data(_s._data) {}
      inline RightsLibraryUpdateSequence_out& operator = (const RightsLibraryUpdateSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline RightsLibraryUpdateSequence_out& operator = (RightsLibraryUpdateSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator RightsLibraryUpdateSequence*&()  { return _data; }
      inline RightsLibraryUpdateSequence*& ptr()       { return _data; }
      inline RightsLibraryUpdateSequence* operator->() { return _data; }

      inline RightsLibraryUpdate& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      RightsLibraryUpdateSequence*& _data;

    private:
      RightsLibraryUpdateSequence_out();
      RightsLibraryUpdateSequence_out& operator=(const RightsLibraryUpdateSequence_var&);
    };

    struct VersionedRightsLibraryUpdate {
      typedef _CORBA_ConstrType_Variable_Var<VersionedRightsLibraryUpdate> _var_type;

      
      ::CORBA::ULong versionNum;

      RightsLibraryUpdateSequence rightsUpdate;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef VersionedRightsLibraryUpdate::_var_type VersionedRightsLibraryUpdate_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< VersionedRightsLibraryUpdate,VersionedRightsLibraryUpdate_var > VersionedRightsLibraryUpdate_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_VersionedRightsLibraryUpdate;

    struct SubsystemDutyChanges {
      typedef _CORBA_ConstrType_Variable_Var<SubsystemDutyChanges> _var_type;

      
      SubsystemDutySequence add;

      SubsystemDutySequence remove;

      RightsLibraryUpdateSequence rightsUpdate;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SubsystemDutyChanges::_var_type SubsystemDutyChanges_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SubsystemDutyChanges,SubsystemDutyChanges_var > SubsystemDutyChanges_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubsystemDutyChanges;

    struct DaDutyPrimitive {
      typedef _CORBA_ConstrType_Variable_Var<DaDutyPrimitive> _var_type;

      
      ::CORBA::String_member session;

      Key profile;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DaDutyPrimitive::_var_type DaDutyPrimitive_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DaDutyPrimitive,DaDutyPrimitive_var > DaDutyPrimitive_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaDutyPrimitive;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaDutyPrimitiveSequence;

    class DaDutyPrimitiveSequence_var;

    class DaDutyPrimitiveSequence : public _CORBA_Unbounded_Sequence< DaDutyPrimitive >  {
    public:
      typedef DaDutyPrimitiveSequence_var _var_type;
      inline DaDutyPrimitiveSequence() {}
      inline DaDutyPrimitiveSequence(const DaDutyPrimitiveSequence& _s)
        : _CORBA_Unbounded_Sequence< DaDutyPrimitive > (_s) {}

      inline DaDutyPrimitiveSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DaDutyPrimitive > (_max) {}
      inline DaDutyPrimitiveSequence(_CORBA_ULong _max, _CORBA_ULong _len, DaDutyPrimitive* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DaDutyPrimitive > (_max, _len, _val, _rel) {}

    

      inline DaDutyPrimitiveSequence& operator = (const DaDutyPrimitiveSequence& _s) {
        _CORBA_Unbounded_Sequence< DaDutyPrimitive > ::operator=(_s);
        return *this;
      }
    };

    class DaDutyPrimitiveSequence_out;

    class DaDutyPrimitiveSequence_var {
    public:
      inline DaDutyPrimitiveSequence_var() : _pd_seq(0) {}
      inline DaDutyPrimitiveSequence_var(DaDutyPrimitiveSequence* _s) : _pd_seq(_s) {}
      inline DaDutyPrimitiveSequence_var(const DaDutyPrimitiveSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DaDutyPrimitiveSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DaDutyPrimitiveSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DaDutyPrimitiveSequence_var& operator = (DaDutyPrimitiveSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DaDutyPrimitiveSequence_var& operator = (const DaDutyPrimitiveSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DaDutyPrimitiveSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DaDutyPrimitive& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DaDutyPrimitiveSequence* operator -> () { return _pd_seq; }
      inline const DaDutyPrimitiveSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DaDutyPrimitiveSequence& () const { return *_pd_seq; }
#else
      inline operator const DaDutyPrimitiveSequence& () const { return *_pd_seq; }
      inline operator DaDutyPrimitiveSequence& () { return *_pd_seq; }
#endif
        
      inline const DaDutyPrimitiveSequence& in() const { return *_pd_seq; }
      inline DaDutyPrimitiveSequence&       inout()    { return *_pd_seq; }
      inline DaDutyPrimitiveSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DaDutyPrimitiveSequence* _retn() { DaDutyPrimitiveSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DaDutyPrimitiveSequence_out;
      
    private:
      DaDutyPrimitiveSequence* _pd_seq;
    };

    class DaDutyPrimitiveSequence_out {
    public:
      inline DaDutyPrimitiveSequence_out(DaDutyPrimitiveSequence*& _s) : _data(_s) { _data = 0; }
      inline DaDutyPrimitiveSequence_out(DaDutyPrimitiveSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DaDutyPrimitiveSequence*) 0; }
      inline DaDutyPrimitiveSequence_out(const DaDutyPrimitiveSequence_out& _s) : _data(_s._data) {}
      inline DaDutyPrimitiveSequence_out& operator = (const DaDutyPrimitiveSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DaDutyPrimitiveSequence_out& operator = (DaDutyPrimitiveSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DaDutyPrimitiveSequence*&()  { return _data; }
      inline DaDutyPrimitiveSequence*& ptr()       { return _data; }
      inline DaDutyPrimitiveSequence* operator->() { return _data; }

      inline DaDutyPrimitive& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DaDutyPrimitiveSequence*& _data;

    private:
      DaDutyPrimitiveSequence_out();
      DaDutyPrimitiveSequence_out& operator=(const DaDutyPrimitiveSequence_var&);
    };

    struct DaSubDuty {
      typedef _CORBA_ConstrType_Variable_Var<DaSubDuty> _var_type;

      
      Key subsystem;

      ::CORBA::ULong addState;

      ::CORBA::ULong remState;

      DaDutyPrimitiveSequence add;

      DaDutyPrimitiveSequence remove;

      DaDutyPrimitive deniedBy;

      DaDutyPrimitive timedOut;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DaSubDuty::_var_type DaSubDuty_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DaSubDuty,DaSubDuty_var > DaSubDuty_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaSubDuty;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaSubDutySequence;

    class DaSubDutySequence_var;

    class DaSubDutySequence : public _CORBA_Unbounded_Sequence< DaSubDuty >  {
    public:
      typedef DaSubDutySequence_var _var_type;
      inline DaSubDutySequence() {}
      inline DaSubDutySequence(const DaSubDutySequence& _s)
        : _CORBA_Unbounded_Sequence< DaSubDuty > (_s) {}

      inline DaSubDutySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DaSubDuty > (_max) {}
      inline DaSubDutySequence(_CORBA_ULong _max, _CORBA_ULong _len, DaSubDuty* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DaSubDuty > (_max, _len, _val, _rel) {}

    

      inline DaSubDutySequence& operator = (const DaSubDutySequence& _s) {
        _CORBA_Unbounded_Sequence< DaSubDuty > ::operator=(_s);
        return *this;
      }
    };

    class DaSubDutySequence_out;

    class DaSubDutySequence_var {
    public:
      inline DaSubDutySequence_var() : _pd_seq(0) {}
      inline DaSubDutySequence_var(DaSubDutySequence* _s) : _pd_seq(_s) {}
      inline DaSubDutySequence_var(const DaSubDutySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DaSubDutySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DaSubDutySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DaSubDutySequence_var& operator = (DaSubDutySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DaSubDutySequence_var& operator = (const DaSubDutySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DaSubDutySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DaSubDuty& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DaSubDutySequence* operator -> () { return _pd_seq; }
      inline const DaSubDutySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DaSubDutySequence& () const { return *_pd_seq; }
#else
      inline operator const DaSubDutySequence& () const { return *_pd_seq; }
      inline operator DaSubDutySequence& () { return *_pd_seq; }
#endif
        
      inline const DaSubDutySequence& in() const { return *_pd_seq; }
      inline DaSubDutySequence&       inout()    { return *_pd_seq; }
      inline DaSubDutySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DaSubDutySequence* _retn() { DaSubDutySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DaSubDutySequence_out;
      
    private:
      DaSubDutySequence* _pd_seq;
    };

    class DaSubDutySequence_out {
    public:
      inline DaSubDutySequence_out(DaSubDutySequence*& _s) : _data(_s) { _data = 0; }
      inline DaSubDutySequence_out(DaSubDutySequence_var& _s)
        : _data(_s._pd_seq) { _s = (DaSubDutySequence*) 0; }
      inline DaSubDutySequence_out(const DaSubDutySequence_out& _s) : _data(_s._data) {}
      inline DaSubDutySequence_out& operator = (const DaSubDutySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DaSubDutySequence_out& operator = (DaSubDutySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DaSubDutySequence*&()  { return _data; }
      inline DaSubDutySequence*& ptr()       { return _data; }
      inline DaSubDutySequence* operator->() { return _data; }

      inline DaSubDuty& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DaSubDutySequence*& _data;

    private:
      DaSubDutySequence_out();
      DaSubDutySequence_out& operator=(const DaSubDutySequence_var&);
    };

    struct DaRegDuty {
      typedef _CORBA_ConstrType_Variable_Var<DaRegDuty> _var_type;

      
      DaDutyPrimitiveSequence add;

      DaDutyPrimitiveSequence remove;

      DaDutyPrimitive replace;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DaRegDuty::_var_type DaRegDuty_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DaRegDuty,DaRegDuty_var > DaRegDuty_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaRegDuty;

    struct DaDuty {
      typedef _CORBA_ConstrType_Variable_Var<DaDuty> _var_type;

      
      Key region;

      DaRegDuty regDuty;

      DaSubDutySequence subDuty;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DaDuty::_var_type DaDuty_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DaDuty,DaDuty_var > DaDuty_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaDuty;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DaDutySequence;

    class DaDutySequence_var;

    class DaDutySequence : public _CORBA_Unbounded_Sequence< DaDuty >  {
    public:
      typedef DaDutySequence_var _var_type;
      inline DaDutySequence() {}
      inline DaDutySequence(const DaDutySequence& _s)
        : _CORBA_Unbounded_Sequence< DaDuty > (_s) {}

      inline DaDutySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DaDuty > (_max) {}
      inline DaDutySequence(_CORBA_ULong _max, _CORBA_ULong _len, DaDuty* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DaDuty > (_max, _len, _val, _rel) {}

    

      inline DaDutySequence& operator = (const DaDutySequence& _s) {
        _CORBA_Unbounded_Sequence< DaDuty > ::operator=(_s);
        return *this;
      }
    };

    class DaDutySequence_out;

    class DaDutySequence_var {
    public:
      inline DaDutySequence_var() : _pd_seq(0) {}
      inline DaDutySequence_var(DaDutySequence* _s) : _pd_seq(_s) {}
      inline DaDutySequence_var(const DaDutySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DaDutySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DaDutySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DaDutySequence_var& operator = (DaDutySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DaDutySequence_var& operator = (const DaDutySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DaDutySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DaDuty& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DaDutySequence* operator -> () { return _pd_seq; }
      inline const DaDutySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DaDutySequence& () const { return *_pd_seq; }
#else
      inline operator const DaDutySequence& () const { return *_pd_seq; }
      inline operator DaDutySequence& () { return *_pd_seq; }
#endif
        
      inline const DaDutySequence& in() const { return *_pd_seq; }
      inline DaDutySequence&       inout()    { return *_pd_seq; }
      inline DaDutySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DaDutySequence* _retn() { DaDutySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DaDutySequence_out;
      
    private:
      DaDutySequence* _pd_seq;
    };

    class DaDutySequence_out {
    public:
      inline DaDutySequence_out(DaDutySequence*& _s) : _data(_s) { _data = 0; }
      inline DaDutySequence_out(DaDutySequence_var& _s)
        : _data(_s._pd_seq) { _s = (DaDutySequence*) 0; }
      inline DaDutySequence_out(const DaDutySequence_out& _s) : _data(_s._data) {}
      inline DaDutySequence_out& operator = (const DaDutySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DaDutySequence_out& operator = (DaDutySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DaDutySequence*&()  { return _data; }
      inline DaDutySequence*& ptr()       { return _data; }
      inline DaDutySequence* operator->() { return _data; }

      inline DaDuty& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DaDutySequence*& _data;

    private:
      DaDutySequence_out();
      DaDutySequence_out& operator=(const DaDutySequence_var&);
    };

    struct DutyTree {
      typedef _CORBA_ConstrType_Variable_Var<DutyTree> _var_type;

      
      ::CORBA::String_member session;

      ::CORBA::ULong profile;

      SubsystemTreeSequence subsystems;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DutyTree::_var_type DutyTree_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DutyTree,DutyTree_var > DutyTree_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyTree;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyTreeSequence;

    class DutyTreeSequence_var;

    class DutyTreeSequence : public _CORBA_Unbounded_Sequence< DutyTree >  {
    public:
      typedef DutyTreeSequence_var _var_type;
      inline DutyTreeSequence() {}
      inline DutyTreeSequence(const DutyTreeSequence& _s)
        : _CORBA_Unbounded_Sequence< DutyTree > (_s) {}

      inline DutyTreeSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DutyTree > (_max) {}
      inline DutyTreeSequence(_CORBA_ULong _max, _CORBA_ULong _len, DutyTree* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DutyTree > (_max, _len, _val, _rel) {}

    

      inline DutyTreeSequence& operator = (const DutyTreeSequence& _s) {
        _CORBA_Unbounded_Sequence< DutyTree > ::operator=(_s);
        return *this;
      }
    };

    class DutyTreeSequence_out;

    class DutyTreeSequence_var {
    public:
      inline DutyTreeSequence_var() : _pd_seq(0) {}
      inline DutyTreeSequence_var(DutyTreeSequence* _s) : _pd_seq(_s) {}
      inline DutyTreeSequence_var(const DutyTreeSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DutyTreeSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DutyTreeSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DutyTreeSequence_var& operator = (DutyTreeSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DutyTreeSequence_var& operator = (const DutyTreeSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DutyTreeSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DutyTree& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DutyTreeSequence* operator -> () { return _pd_seq; }
      inline const DutyTreeSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DutyTreeSequence& () const { return *_pd_seq; }
#else
      inline operator const DutyTreeSequence& () const { return *_pd_seq; }
      inline operator DutyTreeSequence& () { return *_pd_seq; }
#endif
        
      inline const DutyTreeSequence& in() const { return *_pd_seq; }
      inline DutyTreeSequence&       inout()    { return *_pd_seq; }
      inline DutyTreeSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DutyTreeSequence* _retn() { DutyTreeSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DutyTreeSequence_out;
      
    private:
      DutyTreeSequence* _pd_seq;
    };

    class DutyTreeSequence_out {
    public:
      inline DutyTreeSequence_out(DutyTreeSequence*& _s) : _data(_s) { _data = 0; }
      inline DutyTreeSequence_out(DutyTreeSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DutyTreeSequence*) 0; }
      inline DutyTreeSequence_out(const DutyTreeSequence_out& _s) : _data(_s._data) {}
      inline DutyTreeSequence_out& operator = (const DutyTreeSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DutyTreeSequence_out& operator = (DutyTreeSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DutyTreeSequence*&()  { return _data; }
      inline DutyTreeSequence*& ptr()       { return _data; }
      inline DutyTreeSequence* operator->() { return _data; }

      inline DutyTree& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DutyTreeSequence*& _data;

    private:
      DutyTreeSequence_out();
      DutyTreeSequence_out& operator=(const DutyTreeSequence_var&);
    };

    struct DutyRequest {
      typedef _CORBA_ConstrType_Variable_Var<DutyRequest> _var_type;

      
      ::CORBA::String_member targetSession;

      ::CORBA::String_member uniqueId;

      DutyTree duty;

      _CORBA_ObjRef_Member< _objref_IDutyAgentRespCorbaDef, IDutyAgentRespCorbaDef_Helper>  dutyAgent;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DutyRequest::_var_type DutyRequest_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DutyRequest,DutyRequest_var > DutyRequest_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyRequest;

    struct DutyPopup {
      typedef _CORBA_ConstrType_Variable_Var<DutyPopup> _var_type;

      
      ::CORBA::String_member targetSession;

      DutyTreeSequence gained;

      DutyTreeSequence denied;

      DutyTreeSequence lost;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DutyPopup::_var_type DutyPopup_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DutyPopup,DutyPopup_var > DutyPopup_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyPopup;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyPopupSequence;

    class DutyPopupSequence_var;

    class DutyPopupSequence : public _CORBA_Unbounded_Sequence< DutyPopup >  {
    public:
      typedef DutyPopupSequence_var _var_type;
      inline DutyPopupSequence() {}
      inline DutyPopupSequence(const DutyPopupSequence& _s)
        : _CORBA_Unbounded_Sequence< DutyPopup > (_s) {}

      inline DutyPopupSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DutyPopup > (_max) {}
      inline DutyPopupSequence(_CORBA_ULong _max, _CORBA_ULong _len, DutyPopup* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DutyPopup > (_max, _len, _val, _rel) {}

    

      inline DutyPopupSequence& operator = (const DutyPopupSequence& _s) {
        _CORBA_Unbounded_Sequence< DutyPopup > ::operator=(_s);
        return *this;
      }
    };

    class DutyPopupSequence_out;

    class DutyPopupSequence_var {
    public:
      inline DutyPopupSequence_var() : _pd_seq(0) {}
      inline DutyPopupSequence_var(DutyPopupSequence* _s) : _pd_seq(_s) {}
      inline DutyPopupSequence_var(const DutyPopupSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DutyPopupSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DutyPopupSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DutyPopupSequence_var& operator = (DutyPopupSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DutyPopupSequence_var& operator = (const DutyPopupSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DutyPopupSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DutyPopup& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DutyPopupSequence* operator -> () { return _pd_seq; }
      inline const DutyPopupSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DutyPopupSequence& () const { return *_pd_seq; }
#else
      inline operator const DutyPopupSequence& () const { return *_pd_seq; }
      inline operator DutyPopupSequence& () { return *_pd_seq; }
#endif
        
      inline const DutyPopupSequence& in() const { return *_pd_seq; }
      inline DutyPopupSequence&       inout()    { return *_pd_seq; }
      inline DutyPopupSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DutyPopupSequence* _retn() { DutyPopupSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DutyPopupSequence_out;
      
    private:
      DutyPopupSequence* _pd_seq;
    };

    class DutyPopupSequence_out {
    public:
      inline DutyPopupSequence_out(DutyPopupSequence*& _s) : _data(_s) { _data = 0; }
      inline DutyPopupSequence_out(DutyPopupSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DutyPopupSequence*) 0; }
      inline DutyPopupSequence_out(const DutyPopupSequence_out& _s) : _data(_s._data) {}
      inline DutyPopupSequence_out& operator = (const DutyPopupSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DutyPopupSequence_out& operator = (DutyPopupSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DutyPopupSequence*&()  { return _data; }
      inline DutyPopupSequence*& ptr()       { return _data; }
      inline DutyPopupSequence* operator->() { return _data; }

      inline DutyPopup& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DutyPopupSequence*& _data;

    private:
      DutyPopupSequence_out();
      DutyPopupSequence_out& operator=(const DutyPopupSequence_var&);
    };

    struct DutyChangeDetail {
      typedef _CORBA_ConstrType_Variable_Var<DutyChangeDetail> _var_type;

      
      ::CORBA::String_member action;

      DutyPopupSequence dutySeq;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DutyChangeDetail::_var_type DutyChangeDetail_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DutyChangeDetail,DutyChangeDetail_var > DutyChangeDetail_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyChangeDetail;

    struct StationStatus {
      typedef _CORBA_ConstrType_Fix_Var<StationStatus> _var_type;

      
      Key regionKey;

      ::CORBA::Boolean isOnline;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef StationStatus::_var_type StationStatus_var;

    typedef StationStatus& StationStatus_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_StationStatus;

  
  };

  class _objref_DutyAgentTypeCorbaDef :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    

    inline _objref_DutyAgentTypeCorbaDef()  { _PR_setobj(0); }  // nil
    _objref_DutyAgentTypeCorbaDef(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DutyAgentTypeCorbaDef();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DutyAgentTypeCorbaDef(const _objref_DutyAgentTypeCorbaDef&);
    _objref_DutyAgentTypeCorbaDef& operator = (const _objref_DutyAgentTypeCorbaDef&);
    // not implemented

    friend class DutyAgentTypeCorbaDef;
  };

  class _pof_DutyAgentTypeCorbaDef : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DutyAgentTypeCorbaDef() : _OMNI_NS(proxyObjectFactory)(DutyAgentTypeCorbaDef::_PD_repoId) {}
    virtual ~_pof_DutyAgentTypeCorbaDef();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DutyAgentTypeCorbaDef :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DutyAgentTypeCorbaDef();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DutyAgentTypeCorbaDef;

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  class DutyAgentTypeCorbaDef :
    public virtual TA_Base_Bus::_impl_DutyAgentTypeCorbaDef,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DutyAgentTypeCorbaDef();

    inline ::TA_Base_Bus::DutyAgentTypeCorbaDef_ptr _this() {
      return (::TA_Base_Bus::DutyAgentTypeCorbaDef_ptr) _do_this(::TA_Base_Bus::DutyAgentTypeCorbaDef::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::UnhandledException& _s);
void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::UnhandledException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::UnhandledException*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::KeySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::KeySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::KeySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::KeySequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SessionIdSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SessionIdSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SessionIdSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SessionIdSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDuty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDuty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDuty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDuty*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutySequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutyChanges& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutyChanges* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutyChanges*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RegionDutyChanges*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDuty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDuty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDuty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDuty*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutySequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegion& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegion* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegion*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegion*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegionSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegionSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegionSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableRegionSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystem& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystem* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystem*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystem*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystemSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystemSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystemSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::TransferableSubsystemSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTree& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTree* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTree*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTree*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTreeSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTreeSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTreeSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemTreeSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemStateSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemStateSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemStateSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemStateSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubSession& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubSession* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubSession*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubSession*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubSessionSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubSessionSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubSessionSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubSessionSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdate*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdateSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdateSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdateSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::RightsLibraryUpdateSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::VersionedRightsLibraryUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::VersionedRightsLibraryUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::VersionedRightsLibraryUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::VersionedRightsLibraryUpdate*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutyChanges& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutyChanges* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutyChanges*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::SubsystemDutyChanges*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitive& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitive* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitive*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitive*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitiveSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitiveSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitiveSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutyPrimitiveSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDuty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDuty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDuty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDuty*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDutySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDutySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDutySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaSubDutySequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaRegDuty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaRegDuty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaRegDuty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaRegDuty*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDuty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDuty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDuty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDuty*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DaDutySequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTree& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTree* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTree*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTree*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTreeSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTreeSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTreeSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyTreeSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyRequest& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyRequest* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyRequest*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyRequest*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopup& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopup* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopup*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopup*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopupSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopupSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopupSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyPopupSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyChangeDetail& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyChangeDetail* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::DutyChangeDetail*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::DutyChangeDetail*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::StationStatus& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::StationStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef::StationStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DutyAgentTypeCorbaDef::StationStatus*& _sp);

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef_ptr _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DutyAgentTypeCorbaDef_ptr& _s);



inline void
TA_Base_Bus::DutyAgentTypeCorbaDef::_marshalObjRef(::TA_Base_Bus::DutyAgentTypeCorbaDef_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_DutyAgentTypeCorbaDef
#endif

#endif  // __DutyAgentTypeCorbaDef_hh__

