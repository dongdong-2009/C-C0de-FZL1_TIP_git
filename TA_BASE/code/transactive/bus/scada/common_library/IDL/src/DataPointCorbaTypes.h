// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __DataPointCorbaTypes_hh__
#define __DataPointCorbaTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif



#ifndef __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#define __CommonExceptionsCorbaDef_hh_EXTERNAL_GUARD__
#include <CommonExceptionsCorbaDef.h>
#endif
#ifndef __ScadaCorbaTypes_hh_EXTERNAL_GUARD__
#define __ScadaCorbaTypes_hh_EXTERNAL_GUARD__
#include <ScadaCorbaTypes.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE TA_Base_Bus

_CORBA_MODULE_BEG

  _CORBA_MODULE DataPointCorbaTypes

  _CORBA_MODULE_BEG

    enum EDatapointAlarm { NoAlarm, OverScaleHighAlarm, OverScaleLowAlarm, VeryHighAlarm, HighAlarm, LowAlarm, VeryLowAlarm, TrueAlarm, FalseAlarm, GeneralAlarm /*, __max_EDatapointAlarm=0xffffffff */ };
    typedef EDatapointAlarm& EDatapointAlarm_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EDatapointAlarm;

    enum EScadaAlarmAckState { ScadaAlarmNack, ScadaAlarmAck, ScadaAlarmNotPresent, ScadaAlarmUnknown /*, __max_EScadaAlarmAckState=0xffffffff */ };
    typedef EScadaAlarmAckState& EScadaAlarmAckState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EScadaAlarmAckState;

    enum EControlState { NoControl, ControlWritten, ControlPending, ControlConditionalSuccess, ControlSuccess, ControlFailed, ControlLccFailed, ControlRccFailed, ControlCommsFailed, ControlSelectCmdWritten, ControlSelectCmdConfirm, ControlSelectCmdConfirmTimeout, ControlOperateCmdTimeout, ControlExecCmdWritten, ControlExecCmdConfirm, ControlExecCmdSuccess, ControlExecCmdSuccessTimeout, ControlExecCmdConfirmTimeout, ControlCancelCmdWritten, ControlCancelCmdConfirm, ControlCancelCmdConfirmTimeout, ControlSelectCmdCfmNegative, ControlExecCmdCfmNegative, ControlCancelCmdCfmNegative, ControlDeviceControlException /*, __max_EControlState=0xffffffff */ };
    typedef EControlState& EControlState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EControlState;

    struct SControlState {
      typedef _CORBA_ConstrType_Variable_Var<SControlState> _var_type;

      
      EControlState controlState;

      ::CORBA::ULong triggerringDpKey;

      ::CORBA::String_member triggerringDpValue;

      ::CORBA::String_member lccResult;

      ::CORBA::Boolean rccResult;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SControlState::_var_type SControlState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SControlState,SControlState_var > SControlState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SControlState;

    struct SAlarmProperty {
      typedef _CORBA_ConstrType_Fix_Var<SAlarmProperty> _var_type;

      
      EDatapointAlarm type;

      ::CORBA::Boolean enabled;

      ::CORBA::Double threshold;

      ::CORBA::ULong enumValue;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SAlarmProperty::_var_type SAlarmProperty_var;

    typedef SAlarmProperty& SAlarmProperty_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SAlarmProperty;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlarmPropertySequence;

    class AlarmPropertySequence_var;

    class AlarmPropertySequence : public _CORBA_Unbounded_Sequence< SAlarmProperty >  {
    public:
      typedef AlarmPropertySequence_var _var_type;
      inline AlarmPropertySequence() {}
      inline AlarmPropertySequence(const AlarmPropertySequence& _s)
        : _CORBA_Unbounded_Sequence< SAlarmProperty > (_s) {}

      inline AlarmPropertySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SAlarmProperty > (_max) {}
      inline AlarmPropertySequence(_CORBA_ULong _max, _CORBA_ULong _len, SAlarmProperty* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SAlarmProperty > (_max, _len, _val, _rel) {}

    

      inline AlarmPropertySequence& operator = (const AlarmPropertySequence& _s) {
        _CORBA_Unbounded_Sequence< SAlarmProperty > ::operator=(_s);
        return *this;
      }
    };

    class AlarmPropertySequence_out;

    class AlarmPropertySequence_var {
    public:
      inline AlarmPropertySequence_var() : _pd_seq(0) {}
      inline AlarmPropertySequence_var(AlarmPropertySequence* _s) : _pd_seq(_s) {}
      inline AlarmPropertySequence_var(const AlarmPropertySequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new AlarmPropertySequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~AlarmPropertySequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline AlarmPropertySequence_var& operator = (AlarmPropertySequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AlarmPropertySequence_var& operator = (const AlarmPropertySequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new AlarmPropertySequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SAlarmProperty& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AlarmPropertySequence* operator -> () { return _pd_seq; }
      inline const AlarmPropertySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AlarmPropertySequence& () const { return *_pd_seq; }
#else
      inline operator const AlarmPropertySequence& () const { return *_pd_seq; }
      inline operator AlarmPropertySequence& () { return *_pd_seq; }
#endif
        
      inline const AlarmPropertySequence& in() const { return *_pd_seq; }
      inline AlarmPropertySequence&       inout()    { return *_pd_seq; }
      inline AlarmPropertySequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AlarmPropertySequence* _retn() { AlarmPropertySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AlarmPropertySequence_out;
      
    private:
      AlarmPropertySequence* _pd_seq;
    };

    class AlarmPropertySequence_out {
    public:
      inline AlarmPropertySequence_out(AlarmPropertySequence*& _s) : _data(_s) { _data = 0; }
      inline AlarmPropertySequence_out(AlarmPropertySequence_var& _s)
        : _data(_s._pd_seq) { _s = (AlarmPropertySequence*) 0; }
      inline AlarmPropertySequence_out(const AlarmPropertySequence_out& _s) : _data(_s._data) {}
      inline AlarmPropertySequence_out& operator = (const AlarmPropertySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AlarmPropertySequence_out& operator = (AlarmPropertySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator AlarmPropertySequence*&()  { return _data; }
      inline AlarmPropertySequence*& ptr()       { return _data; }
      inline AlarmPropertySequence* operator->() { return _data; }

      inline SAlarmProperty& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AlarmPropertySequence*& _data;

    private:
      AlarmPropertySequence_out();
      AlarmPropertySequence_out& operator=(const AlarmPropertySequence_var&);
    };

    struct SCompleteDynamicSyncState {
      typedef _CORBA_ConstrType_Variable_Var<SCompleteDynamicSyncState> _var_type;

      
      ScadaCorbaTypes::UTag engValue;

      EDatapointAlarm alarmState;

      EScadaAlarmAckState alarmAckState;

      AlarmPropertySequence alarmProperties;

      SControlState controlState;

      ScadaCorbaTypes::SInhibitState inhibitState;

      ScadaCorbaTypes::SLastOperatorInfo lastOperatorInfo;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SCompleteDynamicSyncState::_var_type SCompleteDynamicSyncState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SCompleteDynamicSyncState,SCompleteDynamicSyncState_var > SCompleteDynamicSyncState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SCompleteDynamicSyncState;

    enum EDynamicSyncUpdate { CompleteDynamicSyncStateUpdate, ValueUpdate, AlarmStateUpdate, AlarmAckStateUpdate, AlarmPropertiesUpdate, ControlUpdate, InhibitUpdate, LastOperatorUpdate /*, __max_EDynamicSyncUpdate=0xffffffff */ };
    typedef EDynamicSyncUpdate& EDynamicSyncUpdate_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EDynamicSyncUpdate;

    class UDynamicSyncUpdate {
    public:

      typedef _CORBA_ConstrType_Variable_Var<UDynamicSyncUpdate> _var_type;

      

      UDynamicSyncUpdate(): _pd__initialised(0) {
        
      }
      
      UDynamicSyncUpdate(const UDynamicSyncUpdate& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case CompleteDynamicSyncStateUpdate: syncCompleteState(_value._pd_syncCompleteState); break;

          case ValueUpdate: engValue(_value._pd_engValue); break;

          case AlarmStateUpdate: alarmState(_value._pd_alarmState); break;

          case AlarmAckStateUpdate: alarmAckState(_value._pd_alarmAckState); break;

          case AlarmPropertiesUpdate: alarmProperties(_value._pd_alarmProperties); break;

          case ControlUpdate: controlState(_value._pd_controlState); break;

          case InhibitUpdate: inhibitState(_value._pd_inhibitState); break;

          case LastOperatorUpdate: lastOperatorInfo(_value._pd_lastOperatorInfo); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~UDynamicSyncUpdate() {}

      UDynamicSyncUpdate& operator=(const UDynamicSyncUpdate& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case CompleteDynamicSyncStateUpdate: syncCompleteState(_value._pd_syncCompleteState); break;

          case ValueUpdate: engValue(_value._pd_engValue); break;

          case AlarmStateUpdate: alarmState(_value._pd_alarmState); break;

          case AlarmAckStateUpdate: alarmAckState(_value._pd_alarmAckState); break;

          case AlarmPropertiesUpdate: alarmProperties(_value._pd_alarmProperties); break;

          case ControlUpdate: controlState(_value._pd_controlState); break;

          case InhibitUpdate: inhibitState(_value._pd_inhibitState); break;

          case LastOperatorUpdate: lastOperatorInfo(_value._pd_lastOperatorInfo); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      EDynamicSyncUpdate _d() const { return _pd__d;}
      void _d(EDynamicSyncUpdate _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case CompleteDynamicSyncStateUpdate: goto fail;
          case ValueUpdate: goto fail;
          case AlarmStateUpdate: goto fail;
          case AlarmAckStateUpdate: goto fail;
          case AlarmPropertiesUpdate: goto fail;
          case ControlUpdate: goto fail;
          case InhibitUpdate: goto fail;
          case LastOperatorUpdate: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      const SCompleteDynamicSyncState &syncCompleteState () const { return _pd_syncCompleteState; }
      SCompleteDynamicSyncState &syncCompleteState () { return _pd_syncCompleteState; }
      void syncCompleteState (const SCompleteDynamicSyncState& _value) {
        _pd__initialised = 1;
        _pd__d = CompleteDynamicSyncStateUpdate;
        _pd__default = 0;
        _pd_syncCompleteState = _value;
      }

      const ScadaCorbaTypes::UTag &engValue () const { return _pd_engValue; }
      ScadaCorbaTypes::UTag &engValue () { return _pd_engValue; }
      void engValue (const ScadaCorbaTypes::UTag& _value) {
        _pd__initialised = 1;
        _pd__d = ValueUpdate;
        _pd__default = 0;
        _pd_engValue = _value;
      }

      EDatapointAlarm alarmState () const { return _pd_alarmState; }
      void alarmState (EDatapointAlarm  _value) {
        _pd__initialised = 1;
        _pd__d = AlarmStateUpdate;
        _pd__default = 0;
        _pd_alarmState = _value;
      }

      EScadaAlarmAckState alarmAckState () const { return _pd_alarmAckState; }
      void alarmAckState (EScadaAlarmAckState  _value) {
        _pd__initialised = 1;
        _pd__d = AlarmAckStateUpdate;
        _pd__default = 0;
        _pd_alarmAckState = _value;
      }

      const AlarmPropertySequence &alarmProperties () const { return _pd_alarmProperties; }
      AlarmPropertySequence &alarmProperties () { return _pd_alarmProperties; }
      void alarmProperties (const AlarmPropertySequence& _value) {
        _pd__initialised = 1;
        _pd__d = AlarmPropertiesUpdate;
        _pd__default = 0;
        _pd_alarmProperties = _value;
      }

      const SControlState &controlState () const { return _pd_controlState; }
      SControlState &controlState () { return _pd_controlState; }
      void controlState (const SControlState& _value) {
        _pd__initialised = 1;
        _pd__d = ControlUpdate;
        _pd__default = 0;
        _pd_controlState = _value;
      }

      const ScadaCorbaTypes::SInhibitState &inhibitState () const { return _pd_inhibitState; }
      ScadaCorbaTypes::SInhibitState &inhibitState () { return _pd_inhibitState; }
      void inhibitState (const ScadaCorbaTypes::SInhibitState& _value) {
        _pd__initialised = 1;
        _pd__d = InhibitUpdate;
        _pd__default = 0;
        _pd_inhibitState = _value;
      }

      const ScadaCorbaTypes::SLastOperatorInfo &lastOperatorInfo () const { return _pd_lastOperatorInfo; }
      ScadaCorbaTypes::SLastOperatorInfo &lastOperatorInfo () { return _pd_lastOperatorInfo; }
      void lastOperatorInfo (const ScadaCorbaTypes::SLastOperatorInfo& _value) {
        _pd__initialised = 1;
        _pd__d = LastOperatorUpdate;
        _pd__default = 0;
        _pd_lastOperatorInfo = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      EDynamicSyncUpdate _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        EDatapointAlarm _pd_alarmState;

        EScadaAlarmAckState _pd_alarmAckState;


      };

    
      SCompleteDynamicSyncState _pd_syncCompleteState;

      ScadaCorbaTypes::UTag _pd_engValue;

      AlarmPropertySequence _pd_alarmProperties;

      SControlState _pd_controlState;

      ScadaCorbaTypes::SInhibitState _pd_inhibitState;

      ScadaCorbaTypes::SLastOperatorInfo _pd_lastOperatorInfo;

    
    };

    typedef UDynamicSyncUpdate::_var_type UDynamicSyncUpdate_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< UDynamicSyncUpdate,UDynamicSyncUpdate_var > UDynamicSyncUpdate_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UDynamicSyncUpdate;

    struct SDynamicSyncUpdate {
      typedef _CORBA_ConstrType_Variable_Var<SDynamicSyncUpdate> _var_type;

      
      ::CORBA::ULong dpKey;

      UDynamicSyncUpdate syncUpdate;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef SDynamicSyncUpdate::_var_type SDynamicSyncUpdate_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< SDynamicSyncUpdate,SDynamicSyncUpdate_var > SDynamicSyncUpdate_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SDynamicSyncUpdate;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DynamicSyncUpdateSequence;

    class DynamicSyncUpdateSequence_var;

    class DynamicSyncUpdateSequence : public _CORBA_Unbounded_Sequence< SDynamicSyncUpdate >  {
    public:
      typedef DynamicSyncUpdateSequence_var _var_type;
      inline DynamicSyncUpdateSequence() {}
      inline DynamicSyncUpdateSequence(const DynamicSyncUpdateSequence& _s)
        : _CORBA_Unbounded_Sequence< SDynamicSyncUpdate > (_s) {}

      inline DynamicSyncUpdateSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< SDynamicSyncUpdate > (_max) {}
      inline DynamicSyncUpdateSequence(_CORBA_ULong _max, _CORBA_ULong _len, SDynamicSyncUpdate* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< SDynamicSyncUpdate > (_max, _len, _val, _rel) {}

    

      inline DynamicSyncUpdateSequence& operator = (const DynamicSyncUpdateSequence& _s) {
        _CORBA_Unbounded_Sequence< SDynamicSyncUpdate > ::operator=(_s);
        return *this;
      }
    };

    class DynamicSyncUpdateSequence_out;

    class DynamicSyncUpdateSequence_var {
    public:
      inline DynamicSyncUpdateSequence_var() : _pd_seq(0) {}
      inline DynamicSyncUpdateSequence_var(DynamicSyncUpdateSequence* _s) : _pd_seq(_s) {}
      inline DynamicSyncUpdateSequence_var(const DynamicSyncUpdateSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DynamicSyncUpdateSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DynamicSyncUpdateSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DynamicSyncUpdateSequence_var& operator = (DynamicSyncUpdateSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DynamicSyncUpdateSequence_var& operator = (const DynamicSyncUpdateSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DynamicSyncUpdateSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline SDynamicSyncUpdate& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DynamicSyncUpdateSequence* operator -> () { return _pd_seq; }
      inline const DynamicSyncUpdateSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DynamicSyncUpdateSequence& () const { return *_pd_seq; }
#else
      inline operator const DynamicSyncUpdateSequence& () const { return *_pd_seq; }
      inline operator DynamicSyncUpdateSequence& () { return *_pd_seq; }
#endif
        
      inline const DynamicSyncUpdateSequence& in() const { return *_pd_seq; }
      inline DynamicSyncUpdateSequence&       inout()    { return *_pd_seq; }
      inline DynamicSyncUpdateSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DynamicSyncUpdateSequence* _retn() { DynamicSyncUpdateSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DynamicSyncUpdateSequence_out;
      
    private:
      DynamicSyncUpdateSequence* _pd_seq;
    };

    class DynamicSyncUpdateSequence_out {
    public:
      inline DynamicSyncUpdateSequence_out(DynamicSyncUpdateSequence*& _s) : _data(_s) { _data = 0; }
      inline DynamicSyncUpdateSequence_out(DynamicSyncUpdateSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DynamicSyncUpdateSequence*) 0; }
      inline DynamicSyncUpdateSequence_out(const DynamicSyncUpdateSequence_out& _s) : _data(_s._data) {}
      inline DynamicSyncUpdateSequence_out& operator = (const DynamicSyncUpdateSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DynamicSyncUpdateSequence_out& operator = (DynamicSyncUpdateSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DynamicSyncUpdateSequence*&()  { return _data; }
      inline DynamicSyncUpdateSequence*& ptr()       { return _data; }
      inline DynamicSyncUpdateSequence* operator->() { return _data; }

      inline SDynamicSyncUpdate& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DynamicSyncUpdateSequence*& _data;

    private:
      DynamicSyncUpdateSequence_out();
      DynamicSyncUpdateSequence_out& operator=(const DynamicSyncUpdateSequence_var&);
    };

    class UDataPointValue {
    public:

      typedef _CORBA_ConstrType_Variable_Var<UDataPointValue> _var_type;

      

      UDataPointValue(): _pd__initialised(0) {
        
      }
      
      UDataPointValue(const UDataPointValue& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case ScadaCorbaTypes::AnalogueTagType: floatValue(_value._pd_floatValue); break;

          case ScadaCorbaTypes::EnumTagType: enumValue(_value._pd_enumValue); break;

          case ScadaCorbaTypes::BooleanTagType: booleanValue(_value._pd_booleanValue); break;

          case ScadaCorbaTypes::TextTagType: stringValue(_value._pd_stringValue); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~UDataPointValue() {}

      UDataPointValue& operator=(const UDataPointValue& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case ScadaCorbaTypes::AnalogueTagType: floatValue(_value._pd_floatValue); break;

          case ScadaCorbaTypes::EnumTagType: enumValue(_value._pd_enumValue); break;

          case ScadaCorbaTypes::BooleanTagType: booleanValue(_value._pd_booleanValue); break;

          case ScadaCorbaTypes::TextTagType: stringValue(_value._pd_stringValue); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      ScadaCorbaTypes::ETagType _d() const { return _pd__d;}
      void _d(ScadaCorbaTypes::ETagType _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case ScadaCorbaTypes::AnalogueTagType: goto fail;
          case ScadaCorbaTypes::EnumTagType: goto fail;
          case ScadaCorbaTypes::BooleanTagType: goto fail;
          case ScadaCorbaTypes::TextTagType: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      ::CORBA::Double floatValue () const { return _pd_floatValue; }
      void floatValue (::CORBA::Double  _value) {
        _pd__initialised = 1;
        _pd__d = ScadaCorbaTypes::AnalogueTagType;
        _pd__default = 0;
        _pd_floatValue = _value;
      }

      ::CORBA::ULong enumValue () const { return _pd_enumValue; }
      void enumValue (::CORBA::ULong  _value) {
        _pd__initialised = 1;
        _pd__d = ScadaCorbaTypes::EnumTagType;
        _pd__default = 0;
        _pd_enumValue = _value;
      }

      ::CORBA::Boolean booleanValue () const { return _pd_booleanValue; }
      void booleanValue (::CORBA::Boolean  _value) {
        _pd__initialised = 1;
        _pd__d = ScadaCorbaTypes::BooleanTagType;
        _pd__default = 0;
        _pd_booleanValue = _value;
      }

      const ScadaCorbaTypes::ByteSequence &stringValue () const { return _pd_stringValue; }
      ScadaCorbaTypes::ByteSequence &stringValue () { return _pd_stringValue; }
      void stringValue (const ScadaCorbaTypes::ByteSequence& _value) {
        _pd__initialised = 1;
        _pd__d = ScadaCorbaTypes::TextTagType;
        _pd__default = 0;
        _pd_stringValue = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      ScadaCorbaTypes::ETagType _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        
#ifndef USING_PROXY_FLOAT
          ::CORBA::Double _pd_floatValue;
#endif

        ::CORBA::ULong _pd_enumValue;

        ::CORBA::Boolean _pd_booleanValue;


      };

    
      
#ifdef USING_PROXY_FLOAT
        ::CORBA::Double _pd_floatValue;
#endif

      ScadaCorbaTypes::ByteSequence _pd_stringValue;

    
    };

    typedef UDataPointValue::_var_type UDataPointValue_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< UDataPointValue,UDataPointValue_var > UDataPointValue_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UDataPointValue;

    struct DataPointDisplayState {
      typedef _CORBA_ConstrType_Variable_Var<DataPointDisplayState> _var_type;

      
      ::CORBA::ULong entityKey;

      UDataPointValue value;

      ::CORBA::ULong dataPointStatus;

      ::CORBA::Boolean alarmState;

      EScadaAlarmAckState alarmAckState;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DataPointDisplayState::_var_type DataPointDisplayState_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DataPointDisplayState,DataPointDisplayState_var > DataPointDisplayState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataPointDisplayState;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisplayStateSequence;

    class DisplayStateSequence_var;

    class DisplayStateSequence : public _CORBA_Unbounded_Sequence< DataPointDisplayState >  {
    public:
      typedef DisplayStateSequence_var _var_type;
      inline DisplayStateSequence() {}
      inline DisplayStateSequence(const DisplayStateSequence& _s)
        : _CORBA_Unbounded_Sequence< DataPointDisplayState > (_s) {}

      inline DisplayStateSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DataPointDisplayState > (_max) {}
      inline DisplayStateSequence(_CORBA_ULong _max, _CORBA_ULong _len, DataPointDisplayState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DataPointDisplayState > (_max, _len, _val, _rel) {}

    

      inline DisplayStateSequence& operator = (const DisplayStateSequence& _s) {
        _CORBA_Unbounded_Sequence< DataPointDisplayState > ::operator=(_s);
        return *this;
      }
    };

    class DisplayStateSequence_out;

    class DisplayStateSequence_var {
    public:
      inline DisplayStateSequence_var() : _pd_seq(0) {}
      inline DisplayStateSequence_var(DisplayStateSequence* _s) : _pd_seq(_s) {}
      inline DisplayStateSequence_var(const DisplayStateSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DisplayStateSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DisplayStateSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DisplayStateSequence_var& operator = (DisplayStateSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DisplayStateSequence_var& operator = (const DisplayStateSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DisplayStateSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DataPointDisplayState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DisplayStateSequence* operator -> () { return _pd_seq; }
      inline const DisplayStateSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DisplayStateSequence& () const { return *_pd_seq; }
#else
      inline operator const DisplayStateSequence& () const { return *_pd_seq; }
      inline operator DisplayStateSequence& () { return *_pd_seq; }
#endif
        
      inline const DisplayStateSequence& in() const { return *_pd_seq; }
      inline DisplayStateSequence&       inout()    { return *_pd_seq; }
      inline DisplayStateSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DisplayStateSequence* _retn() { DisplayStateSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DisplayStateSequence_out;
      
    private:
      DisplayStateSequence* _pd_seq;
    };

    class DisplayStateSequence_out {
    public:
      inline DisplayStateSequence_out(DisplayStateSequence*& _s) : _data(_s) { _data = 0; }
      inline DisplayStateSequence_out(DisplayStateSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DisplayStateSequence*) 0; }
      inline DisplayStateSequence_out(const DisplayStateSequence_out& _s) : _data(_s._data) {}
      inline DisplayStateSequence_out& operator = (const DisplayStateSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DisplayStateSequence_out& operator = (DisplayStateSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DisplayStateSequence*&()  { return _data; }
      inline DisplayStateSequence*& ptr()       { return _data; }
      inline DisplayStateSequence* operator->() { return _data; }

      inline DataPointDisplayState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DisplayStateSequence*& _data;

    private:
      DisplayStateSequence_out();
      DisplayStateSequence_out& operator=(const DisplayStateSequence_var&);
    };

    enum ECommandError { PermisionDenied, OtherError /*, __max_ECommandError=0xffffffff */ };
    typedef ECommandError& ECommandError_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ECommandError;

    enum EControlCommandState { JustReceived, BeingExecuted, CompletedWithError, CompletedWithSuccess /*, __max_EControlCommandState=0xffffffff */ };
    typedef EControlCommandState& EControlCommandState_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EControlCommandState;

    struct DataPointWriteStateUpdate {
      typedef _CORBA_ConstrType_Variable_Var<DataPointWriteStateUpdate> _var_type;

      
      ::CORBA::ULong commandId;

      ::CORBA::ULong dpKey;

      ::CORBA::String_member sessionId;

      ScadaCorbaTypes::UTag dpValue;

      ::CORBA::Boolean auditEventLoggingEnabled;

      ::CORBA::ULong triggeringDpKey;

      ::CORBA::String_member triggeringDpValue;

      EControlCommandState controlCommandState;

      EControlState controlState;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DataPointWriteStateUpdate::_var_type DataPointWriteStateUpdate_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DataPointWriteStateUpdate,DataPointWriteStateUpdate_var > DataPointWriteStateUpdate_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataPointWriteStateUpdate;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataPointWriteStateUpdateSequence;

    class DataPointWriteStateUpdateSequence_var;

    class DataPointWriteStateUpdateSequence : public _CORBA_Unbounded_Sequence< DataPointWriteStateUpdate >  {
    public:
      typedef DataPointWriteStateUpdateSequence_var _var_type;
      inline DataPointWriteStateUpdateSequence() {}
      inline DataPointWriteStateUpdateSequence(const DataPointWriteStateUpdateSequence& _s)
        : _CORBA_Unbounded_Sequence< DataPointWriteStateUpdate > (_s) {}

      inline DataPointWriteStateUpdateSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DataPointWriteStateUpdate > (_max) {}
      inline DataPointWriteStateUpdateSequence(_CORBA_ULong _max, _CORBA_ULong _len, DataPointWriteStateUpdate* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DataPointWriteStateUpdate > (_max, _len, _val, _rel) {}

    

      inline DataPointWriteStateUpdateSequence& operator = (const DataPointWriteStateUpdateSequence& _s) {
        _CORBA_Unbounded_Sequence< DataPointWriteStateUpdate > ::operator=(_s);
        return *this;
      }
    };

    class DataPointWriteStateUpdateSequence_out;

    class DataPointWriteStateUpdateSequence_var {
    public:
      inline DataPointWriteStateUpdateSequence_var() : _pd_seq(0) {}
      inline DataPointWriteStateUpdateSequence_var(DataPointWriteStateUpdateSequence* _s) : _pd_seq(_s) {}
      inline DataPointWriteStateUpdateSequence_var(const DataPointWriteStateUpdateSequence_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DataPointWriteStateUpdateSequence(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DataPointWriteStateUpdateSequence_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DataPointWriteStateUpdateSequence_var& operator = (DataPointWriteStateUpdateSequence* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DataPointWriteStateUpdateSequence_var& operator = (const DataPointWriteStateUpdateSequence_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DataPointWriteStateUpdateSequence;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DataPointWriteStateUpdate& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DataPointWriteStateUpdateSequence* operator -> () { return _pd_seq; }
      inline const DataPointWriteStateUpdateSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DataPointWriteStateUpdateSequence& () const { return *_pd_seq; }
#else
      inline operator const DataPointWriteStateUpdateSequence& () const { return *_pd_seq; }
      inline operator DataPointWriteStateUpdateSequence& () { return *_pd_seq; }
#endif
        
      inline const DataPointWriteStateUpdateSequence& in() const { return *_pd_seq; }
      inline DataPointWriteStateUpdateSequence&       inout()    { return *_pd_seq; }
      inline DataPointWriteStateUpdateSequence*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DataPointWriteStateUpdateSequence* _retn() { DataPointWriteStateUpdateSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DataPointWriteStateUpdateSequence_out;
      
    private:
      DataPointWriteStateUpdateSequence* _pd_seq;
    };

    class DataPointWriteStateUpdateSequence_out {
    public:
      inline DataPointWriteStateUpdateSequence_out(DataPointWriteStateUpdateSequence*& _s) : _data(_s) { _data = 0; }
      inline DataPointWriteStateUpdateSequence_out(DataPointWriteStateUpdateSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DataPointWriteStateUpdateSequence*) 0; }
      inline DataPointWriteStateUpdateSequence_out(const DataPointWriteStateUpdateSequence_out& _s) : _data(_s._data) {}
      inline DataPointWriteStateUpdateSequence_out& operator = (const DataPointWriteStateUpdateSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DataPointWriteStateUpdateSequence_out& operator = (DataPointWriteStateUpdateSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DataPointWriteStateUpdateSequence*&()  { return _data; }
      inline DataPointWriteStateUpdateSequence*& ptr()       { return _data; }
      inline DataPointWriteStateUpdateSequence* operator->() { return _data; }

      inline DataPointWriteStateUpdate& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DataPointWriteStateUpdateSequence*& _data;

    private:
      DataPointWriteStateUpdateSequence_out();
      DataPointWriteStateUpdateSequence_out& operator=(const DataPointWriteStateUpdateSequence_var&);
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_TA_Base_Bus
_CORBA_MODULE_BEG

  _CORBA_MODULE DataPointCorbaTypes
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_TA_Base_Bus
_CORBA_MODULE_BEG

  _CORBA_MODULE DataPointCorbaTypes
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::EDatapointAlarm _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::EDatapointAlarm& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::GeneralAlarm) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::EDatapointAlarm) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EDatapointAlarm _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EDatapointAlarm& _s);

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::EScadaAlarmAckState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::EScadaAlarmAckState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::ScadaAlarmUnknown) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::EScadaAlarmAckState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EScadaAlarmAckState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EScadaAlarmAckState& _s);

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::EControlState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::EControlState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::ControlDeviceControlException) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::EControlState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EControlState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EControlState& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SControlState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SControlState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SControlState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SControlState*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SAlarmProperty& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SAlarmProperty* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SAlarmProperty*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SAlarmProperty*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::AlarmPropertySequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::AlarmPropertySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::AlarmPropertySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::AlarmPropertySequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SCompleteDynamicSyncState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SCompleteDynamicSyncState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SCompleteDynamicSyncState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SCompleteDynamicSyncState*& _sp);

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::EDynamicSyncUpdate _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::EDynamicSyncUpdate& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::LastOperatorUpdate) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::EDynamicSyncUpdate) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EDynamicSyncUpdate _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EDynamicSyncUpdate& _s);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::UDynamicSyncUpdate& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::UDynamicSyncUpdate* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::UDynamicSyncUpdate*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::UDynamicSyncUpdate*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SDynamicSyncUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SDynamicSyncUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::SDynamicSyncUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::SDynamicSyncUpdate*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DynamicSyncUpdateSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DynamicSyncUpdateSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DynamicSyncUpdateSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DynamicSyncUpdateSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::UDataPointValue& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::UDataPointValue* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::UDataPointValue*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::UDataPointValue*& _sp);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointDisplayState& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointDisplayState* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointDisplayState*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointDisplayState*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DisplayStateSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DisplayStateSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DisplayStateSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DisplayStateSequence*& _sp);

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::ECommandError _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::ECommandError& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::OtherError) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::ECommandError) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::ECommandError _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::ECommandError& _s);

inline void operator >>=(TA_Base_Bus::DataPointCorbaTypes::EControlCommandState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (TA_Base_Bus::DataPointCorbaTypes::EControlCommandState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= TA_Base_Bus::DataPointCorbaTypes::CompletedWithSuccess) {
    _e = (TA_Base_Bus::DataPointCorbaTypes::EControlCommandState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EControlCommandState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::EControlCommandState& _s);

extern void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdate& _s);
extern void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdate* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdate*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdate*& _sp);

void operator<<=(::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdateSequence& _s);
void operator<<=(::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdateSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdateSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const TA_Base_Bus::DataPointCorbaTypes::DataPointWriteStateUpdateSequence*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_DataPointCorbaTypes
#endif

#endif  // __DataPointCorbaTypes_hh__

