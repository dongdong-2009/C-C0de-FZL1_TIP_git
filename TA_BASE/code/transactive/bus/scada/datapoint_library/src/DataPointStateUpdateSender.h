/**
 * The source code in this file is the property of 
 * Ripple Systems and is not for redistribution
 * in any form.
 *
 * Source:   $Source:  $
 * @author:  
 * @version: $Revision:  $
 *
 * Last modification: $Date: $
 * Last modified by:  $Author: $
 * 
 * This class has two resposiblities depending upon the mode of the operation.
 * This class sendis the dataPointStateUpdate to the monitor agent, when the agent
 * is in the Control mode. This keeps reference to the NamedObject of the servant
 * running in the monitor agent.
 * 
 * In monitor mode, this class keeps reference to the NamedObject of the Control
 * Agent and registers with the control agent with a unique id(uuid). The
 * registration is refreshed periodically(every minute). The uuid is generated
 * only on startup and the same uuid is used when refreshing registration.
 * 
 * This class should translate the internal structures to CORBA structures.
 */

#if !defined DataPointStateUpdateSender__INCLUDED_
#define DataPointStateUpdateSender__INCLUDED_

#include "core/threads/src/Thread.h"
#include "core/naming/src/NamedObject.h"
#include "core/timers/src/AbstractThreadedTimeoutUser.h"

#include "bus/scada/common_library/src/CommonDefs.h"
#include "bus/scada/common_library/IDL/src/DataPointCorbaTypes.h"
#include "bus/scada/common_library/IDL/src/IDataPointAccessCorbaDef.h"

#include "core/process_management/IDL/src/ProcessManagementDataDefinitionsCorbaDef.h"

namespace TA_Base_Bus
{
    class DataPointStateUpdateSender : 
					public TA_Base_Core::AbstractThreadedTimeoutUser
    {

    public:
	    virtual ~DataPointStateUpdateSender();

    public:
	    /**
	     * 
	     * @param agentName
	     */
	    DataPointStateUpdateSender(const std::string& agentName, DataPointFactory& m_factory);
	    
        /**
	     * Monitor Mode Only:
	     * This is used only in the monitor mode to register with Control Agent. This
	     * should be used in the run method every minute to refresh registration.
	     * 
	     * @param uniqueId
	     */
	    void registerWithControlAgentForStateUpdates();

		//
		// operations required by the AbstractThreadedTimeoutUser class
		//


		/**
		*
		* threadedTimerExpired
		*
		* To be implemented by users of TimerUtil.  This operation will be called
		* when the registered timeout period has expired.
		*
		*/
		virtual void threadedTimerExpired(long timerId, void* userData);

	    /**
	     * Before sending update, it must check m_isMonitorAgentAvailable. No sync is sent
	     * if monitor agent is not available to receive.
	     * If monitoring agent is registered and the corba call for update fails, it will
	     * set m_isMonitorAgentAvailable to false.
	     * 
	     * @param dpStateUpdate
	     */
	    void sendDataPointStateUpdate(DataPointStateUpdate& dpStateUpdate);
	    
        /**
	     * Before sending update, it must check m_isMonitorAgentAvailable. No sync is sent
	     * if monitor agent is not available to receive.
	     * If monitoring agent is registered and the corba call for update fails, it will
	     * set m_isMonitorAgentAvailable to false.
	     * 
	     * @param dpStateUpdates
	     */
	    void sendDataPointStateUpdates(const std::vector<DataPointStateUpdate>& dpStateUpdates);
	    
        /**
        * This method replaces m_monitorAgentStateUpdateRef with the new value and sets
        * the member variable m_isMonitorAgentAvailable to true.
        * 
        * @param monitorAgentStateUpdateRef
        */
        void setMonitorAgentStateUpdateRef(TA_Base_Bus::IDataPointStateUpdateCorbaDef_ptr monitorAgentStateUpdateRef);

        void setToControl();
	    void setToMonitor();

		void setOperationMode(TA_Base_Core::EOperationMode mode);

    private:
        DataPointStateUpdateSender();
        DataPointStateUpdateSender(DataPointStateUpdateSender&);
        
        bool m_isMonitorAgentAvailabe;
        typedef TA_Base_Core::NamedObject<IDataPointAccessCorbaDef, 
            IDataPointAccessCorbaDef_ptr, 
            IDataPointAccessCorbaDef_var> DataPointAccessInterface;

        DataPointAccessInterface* m_namedObjectControlAgent;

        //This reference is used to send state updates to Monitor Agent.
        TA_Base_Bus::IDataPointStateUpdateCorbaDef_ptr m_monitorAgentStateUpdateRef;

        //This reference is used to register with the Controling Agent.
        TA_Base_Bus::IDataPointStateUpdateCorbaDef_ptr m_myDataPointStateUpdateServantRef;
        
	    //In monitor mode, this is uuid generated by the monitor agent on startup and
	    //stored for refreshing the registration periodically.
	    std::string m_uuid;
        std::string m_agentName;
		TA_Base_Core::EOperationMode	m_operationMode;

        bool m_isTerminating;

		DataPointFactory& m_dataPointFactory;
    };
}

#endif 